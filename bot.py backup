# =========================
# Imports and Setup
# =========================
import discord
from discord.ext import commands
import json
import random
from datetime import datetime, timedelta, timezone as dt_timezone
import os
from dotenv import load_dotenv
from discord import app_commands
import time
import requests
import re
import asyncio
import io
from discord.ui import View, Button
import functools

# =========================
# Intents and Bot Instance
# =========================
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.presences = True

bot = commands.Bot(command_prefix="?", intents=intents, help_command=None)

# =========================
# Constants and Globals
# =========================
CURRENCY_NAME = "dOLLARIANAS"
DATA_FILE = "balances.json"
XP_FILE = "xp.json"
CONFIG_FILE = "config.json"
BIRTHDAY_FILE = "birthdays.json"
RELATIONSHIPS_FILE = "relationships.json"
REMINDERS_FILE = "reminders.json"
THRIFT_FILE = "thrift.json"
AFK_FILE = "afk.json"

balances = {}
user_xp = {}
config = {}

beg_cooldowns = {}
work_cooldowns = {}
daily_cooldowns = {}

OWNER_ID = 755846396208218174

# Server restriction - Set to your server ID
ALLOWED_SERVER_ID = 1390109232677785674  # Your server ID

ROLE_MESSAGE_ID = None
EMOJI_TO_ROLE = {
    "üíô": "mALE",
    "üíó": "fEMALE",
    "ü§ç": "oTHER (AKS)"
}

SERPAPI_KEY = os.getenv("SERPAPI_KEY")

# AFK system
AFK_STATUS = {}  # user_id: {"reason": str, "since": datetime, "mentions": set(user_id)}

# Runway system
RUNWAY_CHANNEL_ID = None  # Set this to your runway channel ID

# Chat logs system
CHAT_LOGS_CHANNEL_ID = None  # Set by ?setchatlogs

# International days dictionary (all 365 days, placeholder names)
INTERNATIONAL_DAYS = {
    "04-01": "wORLD bRAILLE dAY",
    "24-01": "iNTERNATIONAL dAY oF eDUCATION",
    "26-01": "iNTERNATIONAL dAY oF cLEAN eNERGY",
    "27-01": "iNTERNATIONAL dAY oF cOMMEMORATION iN mEMORY oF tHE vICTIMS oF tHE hOLOCAUST",
    "28-01": "iNTERNATIONAL dAY oF pEACEFUL cOEXISTENCE",
    "01-02": "wORLD iNTERFAITH hARMONY wEEK (1-7 fEBRUARY)",
    "02-02": "wORLD wETLANDS dAY",
    "04-02": "iNTERNATIONAL dAY oF hUMAN fRATERNITY",
    "06-02": "iNTERNATIONAL dAY oF zERO tOLERANCE tO fEMALE gENITAL mUTILATION",
    "10-02": "wORLD pULSES dAY",
    "11-02": "iNTERNATIONAL dAY oF wOMEN aND gIRLS iN sCIENCE",
    "12-02": "iNTERNATIONAL dAY fOR tHE pREVENTION oF vIOLENT eXTREMISM aS aND wHEN cONDUCIVE tO tERRORISM",
    "13-02": "wORLD rADIO dAY",
    "17-02": "gLOBAL tOURISM rESILIENCE dAY",
    "20-02": "wORLD dAY oF sOCIAL jUSTICE",
    "21-02": "iNTERNATIONAL mOTHER lANGUAGE dAY",
    "01-03": "zERO dISCRIMINATION dAY",
    "03-03": "wORLD wILDLIFE dAY",
    "05-03": "iNTERNATIONAL dAY fOR dISARMAMENT aND nON-pROLIFERATION aWARENESS",
    "08-03": "iNTERNATIONAL wOMEN'S dAY",
    "10-03": "iNTERNATIONAL dAY oF wOMEN jUDGES",
    "15-03": "iNTERNATIONAL dAY tO cOMBAT iSLAMOPHOBIA",
    "20-03": "iNTERNATIONAL dAY oF hAPPINESS",
    "21-03": "wORLD dAY fOR gLACIERS",
    "22-03": "wORLD wATER dAY",
    "23-03": "wORLD mETEOROLOGICAL dAY",
    "24-03": "wORLD tUBERCULOSIS dAY",
    "25-03": "iNTERNATIONAL dAY oF rEMEMBRANCE oF tHE vICTIMS oF sLAVERY aND tHE tRANSATLANTIC sLAVE tRADE",
    "30-03": "iNTERNATIONAL dAY oF zERO wASTE",
    "02-04": "wORLD aUTISM aWARENESS dAY",
    "04-04": "iNTERNATIONAL dAY fOR mINE aWARENESS aND aSSISTANCE iN mINE aCTION",
    "05-04": "iNTERNATIONAL dAY oF cONSCIENCE",
    "06-04": "iNTERNATIONAL dAY oF sPORT fOR dEVELOPMENT aND pEACE",
    "07-04": "wORLD hEALTH dAY",
    "12-04": "iNTERNATIONAL dAY oF hUMAN sPACE fLIGHT",
    "14-04": "wORLD cHAGAS dISEASE dAY",
    "20-04": "cHINESE lANGUAGE dAY",
    "21-04": "wORLD cREATIVITY aND iNNOVATION dAY",
    "22-04": "iNTERNATIONAL mOTHER eARTH dAY",
    "23-04": "wORLD bOOK aND cOPYRIGHT dAY",
    "24-04": "iNTERNATIONAL gIRLS iN iCT dAY",
    "25-04": "wORLD mALARIA dAY",
    "26-04": "iNTERNATIONAL cHERNOBYL dISASTER rEMEMBRANCE dAY",
    "28-04": "wORLD dAY fOR sAFETY aND hEALTH aT wORK",
    "29-04": "iNTERNATIONAL dAY iN mEMORY oF tHE vICTIMS oF eARTHQUAKES",
    "30-04": "iNTERNATIONAL jAZZ dAY",
    "02-05": "wORLD tUNA dAY",
    "03-05": "wORLD pRESS fREEDOM dAY",
    "05-05": "wORLD pORTUGUESE lANGUAGE dAY",
    "08-05": "tIME oF rEMEMBRANCE aND rECONCILIATION fOR tHOSE wHO lOST tHEIR lIVES dURING tHE sECOND wORLD wAR",
    "10-05": "iNTERNATIONAL dAY oF aRGANIA",
    "12-05": "uN gLOBAL rOAD sAFETY wEEK",
    "15-05": "iNTERNATIONAL dAY oF lIVING tOGETHER iN pEACE",
    "16-05": "iNTERNATIONAL dAY oF lIGHT",
    "17-05": "wORLD fAIR pLAY dAY",
    "19-05": "wORLD bEE dAY",
    "20-05": "iNTERNATIONAL tEA dAY",
    "21-05": "wORLD dAY fOR cULTURAL dIVERSITY fOR dIALOGUE aND dEVELOPMENT",
    "22-05": "iNTERNATIONAL dAY fOR bIOLOGICAL dIVERSITY",
    "23-05": "iNTERNATIONAL dAY tO eND oBSTETRIC fISTULA",
    "24-05": "iNTERNATIONAL dAY oF tHE mARKHOR",
    "25-05": "wORLD fOOTBALL dAY",
    "29-05": "iNTERNATIONAL dAY oF uN pEACEKEEPERS",
    "30-05": "iNTERNATIONAL dAY oF pOTATO",
    "31-05": "wORLD nO-tOBACCO dAY",
    "01-06": "gLOBAL dAY oF pARENTS",
    "03-06": "wORLD bICYCLE dAY",
    "04-06": "iNTERNATIONAL dAY oF iNNOCENT cHILDREN vICTIMS oF aGGRESSION",
    "05-06": "wORLD eNVIRONMENT dAY",
    "06-06": "rUSSIAN lANGUAGE dAY",
    "07-06": "wORLD fOOD sAFETY dAY",
    "08-06": "wORLD oCEANS dAY",
    "10-06": "iNTERNATIONAL dAY fOR dIALOGUE aMONG cIVILIZATIONS",
    "11-06": "iNTERNATIONAL dAY oF pLAY",
    "12-06": "wORLD dAY aGAINST cHILD lABOUR",
    "13-06": "iNTERNATIONAL aLBINISM aWARENESS dAY",
    "14-06": "wORLD bLOOD dONOR dAY",
    "15-06": "wORLD eLDER aBUSE aWARENESS dAY",
    "16-06": "iNTERNATIONAL dAY oF fAMILY rEMITTANCES",
    "17-06": "wORLD dAY tO cOMBAT dESERTIFICATION aND dROUGHT",
    "18-06": "sUSTAINABLE gASTRONOMY dAY",
    "19-06": "iNTERNATIONAL dAY fOR tHE eLIMINATION oF sEXUAL vIOLENCE iN cONFLICT",
    "20-06": "wORLD rEFUGEE dAY",
    "21-06": "iNTERNATIONAL dAY oF yOGA",
    "23-06": "uN pUBLIC sERVICE dAY",
    "24-06": "iNTERNATIONAL dAY oF wOMEN iN dIPLOMACY",
    "25-06": "dAY oF tHE sEAFARER",
    "26-06": "iNTERNATIONAL dAY aGAINST dRUG aBUSE aND iLLICIT tRAFFICKING",
    "27-06": "iNTERNATIONAL dAY oF dEAFBLINDNESS",
    "29-06": "iNTERNATIONAL dAY oF tHE tROPICS",
    "30-06": "iNTERNATIONAL aSTEROID dAY",
    "05-07": "iNTERNATIONAL dAY oF cOOPERATIVES",
    "06-07": "wORLD rURAL dEVELOPMENT dAY",
    "07-07": "wORLD kISWAHILI lANGUAGE dAY",
    "11-07": "wORLD hORSE dAY",
    "12-07": "iNTERNATIONAL dAY oF cOMbATING sAND aND dUST sTORMS",
    "15-07": "nELSON mANDELA iNTERNATIONAL dAY",
    "18-07": "wORLD cHESS dAY",
    "20-07": "iNTERNATIONAL mOON dAY",
    "25-07": "wORLD dROWNING pREVENTION dAY",
    "28-07": "wORLD hEPATITIS dAY",
    "30-07": "iNTERNATIONAL dAY oF fRIENDSHIP",
    "01-08": "wORLD bREASTFEEDING wEEK",
    "09-08": "iNTERNATIONAL dAY oF tHE wORLD'S iNDIGENOUS pEOPLES",
    "11-08": "wORLD sTEELPAN dAY",
    "12-08": "iNTERNATIONAL yOUTH dAY",
    "19-08": "wORLD hUMANITARIAN dAY",
    "21-08": "iNTERNATIONAL dAY oF rEMEMBRANCE aND tRIBUTE tO tHE vICTIMS oF tERRORISM",
    "22-08": "iNTERNATIONAL dAY cOMMEMORATING tHE vICTIMS oF aCTS oF vIOLENCE bASED oN rELIGION oR bELIEF",
    "23-08": "wORLD lAKE dAY",
    "27-08": "iNTERNATIONAL dAY aGAINST nUCLEAR tESTS",
    "29-08": "iNTERNATIONAL dAY oF tHE vICTIMS oF eNFORCED dISAPPEARANCES",
    "30-08": "iNTERNATIONAL dAY fOR pEOPLE oF aFRICAN dESCENT",
    "31-08": "iNTERNATIONAL dAY 243",
    "02-11": "iNTERNATIONAL dAY tO eND iMPUNITY fOR cRIMES aGAINST jOURNALISTS",
    "05-11": "wORLD tSUNAMI aWARENESS dAY",
    "06-11": "iNTERNATIONAL dAY fOR pREVENTING tHE eXPLOITATION oF tHE eNVIRONMENT iN wAR aND aRMED cONFLICT",
    "09-11": "wORLD sCIENCE dAY fOR pEACE aND dEVELOPMENT",
    "10-11": "wORLD dIABETES dAY",
    "14-11": "iNTERNATIONAL dAY fOR tHE pREVENTION oF aND fIGHT aGAINST aLL fORMS oF tRANSNATIONAL oRGANIZED cRIME",
    "15-11": "iNTERNATIONAL dAY fOR tOLERANCE",
    "16-11": "wORLD dAY oF rEMEMBRANCE fOR rOAD tRAFFIC vICTIMS",
    "18-11": "wORLD tOILET dAY",
    "19-11": "wORLD pHILOSOPHY dAY",
    "20-11": "wORLD cHILDREN'S dAY",
    "21-11": "wORLD cONJOINED tWINS dAY",
    "24-11": "iNTERNATIONAL dAY fOR tHE eLIMINATION oF vIOLENCE aGAINST wOMEN",
    "25-11": "wORLD sUSTAINABLE tRANSPORT dAY",
    "26-11": "iNTERNATIONAL dAY oF sOLIDARITY wITH tHE pALESTINIAN pEOPLE",
    "29-11": "dAY oF rEMEMBRANCE fOR aLL vICTIMS oF cHEMICAL wARFARE",
    "30-11": "iNTERNATIONAL dAY 334",
    "01-12": "wORLD aIDS dAY",
    "02-12": "iNTERNATIONAL dAY fOR tHE aBOLITION oF sLAVERY",
    "03-12": "iNTERNATIONAL dAY oF pERSONS wITH dISABILITIES",
    "04-12": "iNTERNATIONAL dAY oF bANKS",
    "05-12": "iNTERNATIONAL dAY aGAINST uNILATERAL cOERCIVE mEASURES",
    "07-12": "wORLD sOIL dAY",
    "09-12": "iNTERNATIONAL dAY oF cOMMEMORATION aND dIGNITY oF tHE vICTIMS oF tHE cRIME oF gENOCIDE aND oF tHE pREVENTION oF tHIS cRIME",
    "10-12": "hUMAN rIGHTS dAY",
    "11-12": "iNTERNATIONAL mOUNTAIN dAY",
    "12-12": "iNTERNATIONAL dAY oF nEUTRALITY",
    "18-12": "iNTERNATIONAL mIGRANTS dAY",
    "20-12": "iNTERNATIONAL hUMAN sOLIDARITY dAY",
    "21-12": "wORLD mEDITATION dAY",
    "27-12": "iNTERNATIONAL dAY oF ePIDEMIC pREPAREDNESS",
    "25-12": "cHRISTMAS dAY"
}

# =========================
# Helper Functions
# =========================

def load_config():
    """Load configuration from CONFIG_FILE into the global config dict."""
    global config, CHAT_LOGS_CHANNEL_ID, WELCOME_CHANNEL_ID, FAREWELL_CHANNEL_ID, RUNWAY_CHANNEL_ID, TICKET_CATEGORY_ID, SUPPORT_ROLE_ID, TICKET_LOGS_CHANNEL_ID
    try:
        with open(CONFIG_FILE, "r") as f:
            config = json.load(f)
            CHAT_LOGS_CHANNEL_ID = config.get("chat_logs_channel_id")
            WELCOME_CHANNEL_ID = config.get("welcome_channel_id")
            FAREWELL_CHANNEL_ID = config.get("farewell_channel_id")
            RUNWAY_CHANNEL_ID = config.get("runway_channel_id")
            TICKET_CATEGORY_ID = config.get("ticket_category_id")
            SUPPORT_ROLE_ID = config.get("support_role_id")
            TICKET_LOGS_CHANNEL_ID = config.get("ticket_logs_channel_id")
    except FileNotFoundError:
        config = {"mod_role_id": None, "admin_role_id": None, "chat_logs_channel_id": None, "welcome_channel_id": None, "farewell_channel_id": None, "runway_channel_id": None, "ticket_category_id": None, "support_role_id": None, "ticket_logs_channel_id": None}
        CHAT_LOGS_CHANNEL_ID = None
        WELCOME_CHANNEL_ID = None
        FAREWELL_CHANNEL_ID = None
        RUNWAY_CHANNEL_ID = None
        TICKET_CATEGORY_ID = None
        SUPPORT_ROLE_ID = None
        TICKET_LOGS_CHANNEL_ID = None

def save_config():
    """Save the current config dict to CONFIG_FILE."""
    global CHAT_LOGS_CHANNEL_ID, WELCOME_CHANNEL_ID, FAREWELL_CHANNEL_ID, RUNWAY_CHANNEL_ID, TICKET_CATEGORY_ID, SUPPORT_ROLE_ID, TICKET_LOGS_CHANNEL_ID
    config["chat_logs_channel_id"] = CHAT_LOGS_CHANNEL_ID
    config["welcome_channel_id"] = WELCOME_CHANNEL_ID
    config["farewell_channel_id"] = FAREWELL_CHANNEL_ID
    config["runway_channel_id"] = RUNWAY_CHANNEL_ID
    config["ticket_category_id"] = TICKET_CATEGORY_ID
    config["support_role_id"] = SUPPORT_ROLE_ID
    config["ticket_logs_channel_id"] = TICKET_LOGS_CHANNEL_ID
    with open(CONFIG_FILE, "w") as f:
        json.dump(config, f)

def load_balances():
    """Load user balances from DATA_FILE into the global balances dict."""
    global balances
    try:
        with open(DATA_FILE, "r") as f:
            balances = json.load(f)
    except FileNotFoundError:
        balances = {}

def save_balances():
    """Save the current balances dict to DATA_FILE."""
    with open(DATA_FILE, "w") as f:
        json.dump(balances, f)

def get_balance(user_id):
    """Get the balance for a user by their ID."""
    return balances.get(str(user_id), 0)

def change_balance(user_id, amount):
    """Change a user's balance by a given amount. Prevents negative balances."""
    user_id = str(user_id)
    balances[user_id] = balances.get(user_id, 0) + amount
    if balances[user_id] < 0:
        balances[user_id] = 0
    save_balances()

def load_xp():
    """Load user XP data from XP_FILE into the global user_xp dict."""
    global user_xp
    try:
        with open(XP_FILE, "r") as f:
            user_xp = json.load(f)
    except FileNotFoundError:
        user_xp = {}

def save_xp():
    """Save the current user_xp dict to XP_FILE."""
    with open(XP_FILE, "w") as f:
        json.dump(user_xp, f)

def add_xp(user_id, amount):
    """Add XP to a user and handle level-ups."""
    user_id = str(user_id)
    xp_data = user_xp.get(user_id, {"xp": 0, "level": 1})
    xp_data["xp"] += amount
    # Level up every 100 XP
    if xp_data["xp"] >= xp_data["level"] * 100:
        xp_data["xp"] = 0
        xp_data["level"] += 1
    user_xp[user_id] = xp_data
    save_xp()

def get_level(user_id):
    """Get the level and XP for a user by their ID."""
    return user_xp.get(str(user_id), {"xp": 0, "level": 1})

def has_mod_or_admin(ctx):
    """Check if the user has mod or admin privileges or is the owner."""
    if ctx.author.id == OWNER_ID:
        return True
    mod_role_id = config.get("mod_role_id")
    admin_role_id = config.get("admin_role_id")
    user_role_ids = [role.id for role in ctx.author.roles]
    return (mod_role_id and mod_role_id in user_role_ids) or (admin_role_id and admin_role_id in user_role_ids)

def load_birthdays():
    try:
        with open(BIRTHDAY_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_birthdays(birthdays):
    with open(BIRTHDAY_FILE, "w") as f:
        json.dump(birthdays, f)

# Nova embed helper

def nova_embed(title, description=None, color=0xff69b4, footer="nOVA"):
    embed = discord.Embed(title=title, description=description, color=color)
    embed.set_footer(text=footer)
    return embed

# Birthday format helper
def format_birthday(date_str):
    """Convert DD-MM format to readable format like 'June 9th'"""
    try:
        day, month = map(int, date_str.split("-"))
        months = [
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ]
        
        # Add ordinal suffix to day
        if 10 <= day % 100 <= 20:
            suffix = "th"
        else:
            suffix = {1: "st", 2: "nd", 3: "rd"}.get(day % 10, "th")
        
        return f"{months[month-1]} {day}{suffix}"
    except:
        return date_str  # Return original if parsing fails

# AFK system persistence
def load_afk():
    """Load AFK status from AFK_FILE into the global AFK_STATUS dict."""
    global AFK_STATUS
    try:
        with open(AFK_FILE, "r") as f:
            data = json.load(f)
            # Convert string keys back to int and datetime strings back to datetime objects
            AFK_STATUS = {}
            for user_id_str, afk_data in data.items():
                user_id = int(user_id_str)
                AFK_STATUS[user_id] = {
                    "reason": afk_data["reason"],
                    "since": datetime.fromisoformat(afk_data["since"]),
                    "mentions": set(afk_data.get("mentions", []))
                }
    except FileNotFoundError:
        AFK_STATUS = {}

def save_afk():
    """Save the current AFK_STATUS dict to AFK_FILE."""
    # Convert datetime objects to ISO format strings and sets to lists for JSON serialization
    data = {}
    for user_id, afk_data in AFK_STATUS.items():
        data[str(user_id)] = {
            "reason": afk_data["reason"],
            "since": afk_data["since"].isoformat(),
            "mentions": list(afk_data["mentions"])
        }
    with open(AFK_FILE, "w") as f:
        json.dump(data, f)

# Example usage in commands:
# await ctx.send(embed=nova_embed("TITLE", "description"))
# await interaction.response.send_message(embed=nova_embed("TITLE", "description"))

# =========================
# Event Handlers
# =========================

@bot.event
async def on_ready():
    print(f'{bot.user} has connected to Discord!')
    load_config()
    load_balances()
    load_xp()
    load_birthdays()
    load_afk()
    
    # Debug: Show loaded config values
    print(f"DEBUG: CHAT_LOGS_CHANNEL_ID = {CHAT_LOGS_CHANNEL_ID}")
    print(f"DEBUG: TICKET_LOGS_CHANNEL_ID = {TICKET_LOGS_CHANNEL_ID}")
    print(f"DEBUG: Config loaded: {config}")
    
    # Validate channels exist and bot has permissions
    for guild in bot.guilds:
        if CHAT_LOGS_CHANNEL_ID:
            chat_channel = guild.get_channel(CHAT_LOGS_CHANNEL_ID)
            if chat_channel:
                print(f"‚úÖ Chat logs channel found: {chat_channel.name}")
                try:
                    await chat_channel.send("üîß Chat logs system online!")
                    print("‚úÖ Chat logs test message sent successfully")
                except Exception as e:
                    print(f"‚ùå Chat logs permission error: {e}")
            else:
                print(f"‚ùå Chat logs channel not found with ID: {CHAT_LOGS_CHANNEL_ID}")
        
        if TICKET_LOGS_CHANNEL_ID:
            ticket_channel = guild.get_channel(TICKET_LOGS_CHANNEL_ID)
            if ticket_channel:
                print(f"‚úÖ Ticket logs channel found: {ticket_channel.name}")
                try:
                    await ticket_channel.send("üé´ Ticket logs system online!")
                    print("‚úÖ Ticket logs test message sent successfully")
                except Exception as e:
                    print(f"‚ùå Ticket logs permission error: {e}")
            else:
                print(f"‚ùå Ticket logs channel not found with ID: {TICKET_LOGS_CHANNEL_ID}")
    
    # Sync slash commands
    try:
        synced = await bot.tree.sync()
        print(f"Synced {len(synced)} command(s)")
    except Exception as e:
        print(f"Failed to sync commands: {e}")

def is_server_allowed(guild_id):
    """Check if the server is allowed to use Nova."""
    if ALLOWED_SERVER_ID is None:
        return True  # No restriction set
    return guild_id == ALLOWED_SERVER_ID

def check_server_restriction():
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(interaction: discord.Interaction):
            guild_id = interaction.guild.id if interaction.guild else None
            if not is_server_allowed(guild_id):
                await interaction.response.send_message(
                    embed=nova_embed("üîí sERVER lOCKED", "nOVA iS lOCKED tO a dIFFERENT sERVER!"),
                    ephemeral=True
                )
                return
            return await func(interaction)
        return wrapper
    return decorator

@bot.event
async def on_message(message):
    """Event: Called on every message. Adds XP and processes commands."""
    if message.author.bot:
        return
    
    # Check if server is allowed
    if not is_server_allowed(message.guild.id):
        return  # Ignore messages from unauthorized servers
    # AFK return logic
    if message.author.id in AFK_STATUS:
        afk = AFK_STATUS.pop(message.author.id)
        save_afk()  # Save AFK data after removing user
        since = afk["since"]
        delta = datetime.now(datetime.timezone.utc) - since
        mins = int(delta.total_seconds() // 60)
        hours = mins // 60
        mins = mins % 60
        time_str = f"{hours}h {mins}m" if hours else f"{mins}m"
        view = MentionsView(message.author.id)
        await message.channel.send(embed=nova_embed("aFK", f"wELCOME bACK, {message.author.display_name}! yOU wERE gONE fOR {time_str}."), view=view)
    # Notify if mentioning AFK users
    mentioned_ids = [user.id for user in message.mentions]
    for uid in mentioned_ids:
        if uid in AFK_STATUS:
            AFK_STATUS[uid]["mentions"].add(message.author.id)
            save_afk()  # Save AFK data after adding mention
            afk = AFK_STATUS[uid]
            member = message.guild.get_member(uid)
            if member:
                since = afk["since"]
                delta = datetime.now(datetime.timezone.utc) - since
                mins = int(delta.total_seconds() // 60)
                hours = mins // 60
                mins = mins % 60
                time_str = f"{hours}h {mins}m" if hours else f"{mins}m"
                await message.channel.send(embed=nova_embed("aFK", f"{member.display_name} iS aFK: {afk['reason']} ({time_str})"))
    add_xp(message.author.id, random.randint(5, 15))
    
    # Check for blacklisted words and auto-delete
    message_lower = message.content.lower()
    for word in BLACKLIST_WORDS:
        if word in message_lower:
            try:
                await message.delete()
                # Send a warning message that deletes after 5 seconds
                warning = await message.channel.send(
                    embed=nova_embed(
                        "‚ö†Ô∏è mESSAGE dELETED",
                        f"{message.author.mention}, yOUR mESSAGE cONTAINED a bLACKLISTED wORD!"
                    ),
                    delete_after=5
                )
                return  # Don't process commands if message was deleted
            except discord.errors.NotFound:
                pass  # Message was already deleted
            except discord.errors.Forbidden:
                pass  # Bot doesn't have permission to delete
    
    # React with cute Nova emoji when someone mentions "Nova"
    if "nova" in message_lower:
        try:
            await message.add_reaction("<:cute_nova:1398830405691637800>")
        except discord.errors.HTTPException:
            pass  # Emoji not found or other error
    
    # Check if message starts with "nova:" to make Nova say the text
    if message.content.lower().startswith("nova:"):
        # Only allow the owner to use this feature
        if message.author.id == OWNER_ID:
            content = message.content[5:].strip()  # Remove "nova:" and get the rest
            if content:
                # Delete the original message
                await message.delete()
                # Make Nova say the text
                await message.channel.send(content)
        else:
            # If someone else tries to use it, delete their message and warn them
            await message.delete()
            await message.channel.send(f"{message.author.mention}, only the owner can make Nova speak!", delete_after=3)
    await bot.process_commands(message)

@bot.event
async def on_raw_reaction_add(payload):
    """Event: Called when a reaction is added. Handles role assignment and runway emoji forwarding."""
    # --- Runway emoji forwarding ---
    # Only act on server messages
    if payload.guild_id and str(payload.emoji) == "üò≠":
        guild = bot.get_guild(payload.guild_id)
        if guild and RUNWAY_CHANNEL_ID:
            channel = guild.get_channel(payload.channel_id)
            if channel:
                try:
                    message = await channel.fetch_message(payload.message_id)
                    # Count loudly crying emoji reactions
                    for reaction in message.reactions:
                        if (str(reaction.emoji) == "üò≠") and (reaction.count >= 4):
                            # Only forward if not already forwarded (avoid spam)
                            # Optionally, you could keep a set of forwarded message IDs
                            runway_channel = guild.get_channel(RUNWAY_CHANNEL_ID)
                            if runway_channel:
                                embed = nova_embed(
                                    title=f"üò≠ #{message.id}",
                                    description=message.content
                                )
                                embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
                                embed.add_field(name="oRIGINAL cHANNEL", value=channel.mention, inline=True)
                                embed.add_field(name="jUMP tO mESSAGE", value=f"[Click here]({message.jump_url})", inline=True)
                                embed.set_footer(text=f"Message ID: {message.id}")
                                files = []
                                for attachment in message.attachments:
                                    try:
                                        file_data = await attachment.read()
                                        files.append(discord.File(io.BytesIO(file_data), filename=attachment.filename))
                                    except Exception:
                                        continue
                                await runway_channel.send(embed=embed, files=files)
                            break  # Only forward once per event
                except Exception:
                    pass  # Silently ignore errors for this feature
    # --- Role assignment (existing logic) ---
    if payload.message_id != ROLE_MESSAGE_ID:
        return
    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return
    role_name = EMOJI_TO_ROLE.get(str(payload.emoji))
    if not role_name:
        return
    role = discord.utils.get(guild.roles, name=role_name)
    member = guild.get_member(payload.user_id)
    if role and member and not member.bot:
        try:
            await member.add_roles(role)
        except discord.Forbidden:
            print(f"Missing permission to add role {role_name} to {member}")

@bot.event
async def on_raw_reaction_remove(payload):
    """Event: Called when a reaction is removed. Handles role removal and rsnipe storage."""
    # Store the last removed reaction for rsnipe - Enhanced debugging
    print(f"DEBUG: Reaction removed - Emoji: {payload.emoji}, User ID: {payload.user_id}, Guild ID: {payload.guild_id}")
    
    if payload.guild_id:
        guild = bot.get_guild(payload.guild_id)
        print(f"DEBUG: Guild found: {guild}")
        if guild:
            user = guild.get_member(payload.user_id)
            print(f"DEBUG: User found: {user}, Is bot: {user.bot if user else 'None'}")
            if user and not user.bot:
                channel = guild.get_channel(payload.channel_id)
                print(f"DEBUG: Channel found: {channel}")
                if channel:
                    try:
                        message = await channel.fetch_message(payload.message_id)
                        jump_url = message.jump_url
                        print(f"DEBUG: Message fetched successfully, jump_url: {jump_url}")
                    except Exception as e:
                        jump_url = None
                        print(f"DEBUG: Failed to fetch message: {e}")
                    
                    rsnipes[payload.channel_id] = {
                        'emoji': str(payload.emoji),
                        'user': str(user),
                        'message_id': payload.message_id,
                        'jump_url': jump_url,
                        'time': datetime.now(datetime.timezone.utc)
                    }
                    print(f"DEBUG: RSnipe data stored for channel {payload.channel_id}: {rsnipes[payload.channel_id]}")
                else:
                    print(f"DEBUG: Channel not found with ID: {payload.channel_id}")
            else:
                print(f"DEBUG: User is bot or not found, skipping rsnipe storage")
        else:
            print(f"DEBUG: Guild not found with ID: {payload.guild_id}")
    else:
        print("DEBUG: No guild_id in payload, skipping rsnipe storage")
    
    # Handle role removal (existing logic)
    if payload.message_id != ROLE_MESSAGE_ID:
        return
    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return
    role_name = EMOJI_TO_ROLE.get(str(payload.emoji))
    if not role_name:
        return
    role = discord.utils.get(guild.roles, name=role_name)
    member = guild.get_member(payload.user_id)
    if role and member:
        try:
            await member.remove_roles(role)
        except discord.Forbidden:
            print(f"Missing permission to remove role {role_name} from {member}")

# =========================
# Text Commands
# =========================

@bot.command()
async def setmodrole(ctx, role_input):
    """Set the moderator role by ID or mention. Owner only."""
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    # Try to parse role from mention or ID
    role = None
    if role_input.startswith('<@&') and role_input.endswith('>'):
        role_id = int(role_input[3:-1])
        role = ctx.guild.get_role(role_id)
    else:
        try:
            role_id = int(role_input)
            role = ctx.guild.get_role(role_id)
        except ValueError:
            await ctx.send("Invalid role ID or mention format.")
            return
    if not role:
        await ctx.send("Role not found.")
        return
    config["mod_role_id"] = role.id
    save_config()
    await ctx.send(f"Moderator role set to {role.name} (ID: {role.id})")

@bot.command()
async def setadminrole(ctx, role_input):
    """Set the admin role by ID or mention. Owner only."""
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    # Try to parse role from mention or ID
    role = None
    if role_input.startswith('<@&') and role_input.endswith('>'):
        role_id = int(role_input[3:-1])
        role = ctx.guild.get_role(role_id)
    else:
        try:
            role_id = int(role_input)
            role = ctx.guild.get_role(role_id)
        except ValueError:
            await ctx.send("Invalid role ID or mention format.")
            return
    if not role:
        await ctx.send("Role not found.")
        return
    config["admin_role_id"] = role.id
    save_config()
    await ctx.send(f"Admin role set to {role.name} (ID: {role.id})")

@bot.command()
async def setserver(ctx):
    """Set the allowed server ID. Owner only."""
    global ALLOWED_SERVER_ID
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    ALLOWED_SERVER_ID = ctx.guild.id
    await ctx.send(embed=nova_embed("üîí sERVER lOCKED", f"‚úÖ nOVA iS nOW lOCKED tO tHIS sERVER: {ctx.guild.name} (ID: {ctx.guild.id})"))

@bot.command()
async def removeserverlock(ctx):
    """Remove server restriction. Owner only."""
    global ALLOWED_SERVER_ID
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    ALLOWED_SERVER_ID = None
    await ctx.send("‚úÖ Server restriction removed. Nova can now work in any server.")

@bot.command()
async def serverstatus(ctx):
    """Check current server restriction status. Owner only."""
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    if ALLOWED_SERVER_ID is None:
        await ctx.send("üîì **Server Status:** No restriction set - Nova works in all servers")
    else:
        guild = bot.get_guild(ALLOWED_SERVER_ID)
        guild_name = guild.name if guild else "Unknown Server"
        await ctx.send(f"üîí **Server Status:** Nova is locked to {guild_name} (ID: {ALLOWED_SERVER_ID})")

@bot.command()
async def help(ctx):
    help_text = """
Prefix & Slash Commands:
/balance, /beg, /daily, /work, /pay, /shop, /buy, /inventory
/setbday, /birthday, /birthdays, /today, /welcome, /rules, /ping, /about, /uptime
/marry, /divorce, /adopt, /emancipate, /getemancipated, /familytree, /kiss, /slap, /whoasked, /voguebattle, /afk
/mute, /unmute, /case, /snipe, /edsnipe, /slowmode, /lock, /unlock
/reactionroles, /nicki, /level, /leaderboard, /spotify
"""
    await ctx.send(embed=nova_embed("nOVA'S cOMMANDS", help_text))

@bot.tree.command(name="help", description="Show all Nova commands")
@check_server_restriction()
async def help_slash(interaction: discord.Interaction):
    help_text = """
Prefix & Slash Commands:
/balance, /beg, /daily, /work, /pay, /shop, /buy, /inventory
/setbday, /birthday, /birthdays, /today, /welcome, /rules, /ping, /about, /uptime
/marry, /divorce, /adopt, /emancipate, /getemancipated, /familytree, /kiss, /slap, /whoasked, /voguebattle, /afk
/mute, /unmute, /case, /snipe, /edsnipe, /slowmode, /lock, /unlock
/reactionroles, /nicki, /level, /leaderboard, /spotify
"""
    await interaction.response.send_message(embed=nova_embed("nOVA'S cOMMANDS", help_text))

@bot.command()
async def balance(ctx):
    """Check your dOLLARIANAS balance."""
    bal = get_balance(ctx.author.id)
    await ctx.send(f"{ctx.author.mention}, you have {bal} {CURRENCY_NAME}.")

# Slash command version of balance
@bot.tree.command(name="balance", description="Check your dOLLARIANAS balance (slash command)")
async def balance_slash(interaction: discord.Interaction):
    bal = get_balance(interaction.user.id)
    await interaction.response.send_message(f"{interaction.user.mention}, you have {bal} {CURRENCY_NAME}.")

@bot.command()
async def beg(ctx):
    now = datetime.now(datetime.timezone.utc)
    user_id = ctx.author.id
    last = beg_cooldowns.get(user_id)
    if last and now - last < timedelta(minutes=10):
        rem = timedelta(minutes=10) - (now - last)
        await ctx.send(f"{ctx.author.mention}, you can beg again in {str(rem).split('.')[0]}.")
        return
    beg_cooldowns[user_id] = now
    if random.random() < 0.5:
        await ctx.send(f"{ctx.author.mention}, no one gave you anything this time.")
    else:
        amount = random.randint(1, 20)
        change_balance(user_id, amount)
        await ctx.send(f"{ctx.author.mention}, you begged and got {amount} {CURRENCY_NAME}!")

@bot.command()
async def daily(ctx):
    user_id = str(ctx.author.id)
    now = datetime.utcnow()
    last = daily_cooldowns.get(user_id)
    if last and (now - last).total_seconds() < 86400:
        remaining = 86400 - (now - last).total_seconds()
        hours = int(remaining // 3600)
        mins = int((remaining % 3600) // 60)
        await ctx.send(embed=nova_embed("dAILY", f"yOU aLREADY cLAIMED yOUR dAILY! tRY aGAIN iN {hours}h {mins}m."))
        return
    daily_cooldowns[user_id] = now
    change_balance(ctx.author.id, 100)
    await ctx.send(embed=nova_embed("dAILY", f"yOU cLAIMED yOUR dAILY 100 {CURRENCY_NAME}!"))

@bot.tree.command(name="daily", description="Claim daily reward (24h cooldown)")
async def daily_slash(interaction: discord.Interaction):
    user_id = str(interaction.user.id)
    now = datetime.utcnow()
    last = daily_cooldowns.get(user_id)
    if last and (now - last).total_seconds() < 86400:
        remaining = 86400 - (now - last).total_seconds()
        hours = int(remaining // 3600)
        mins = int((remaining % 3600) // 60)
        await interaction.response.send_message(embed=nova_embed("dAILY", f"yOU aLREADY cLAIMED yOUR dAILY! tRY aGAIN iN {hours}h {mins}m."), ephemeral=True)
        return
    daily_cooldowns[user_id] = now
    change_balance(interaction.user.id, 100)
    await interaction.response.send_message(embed=nova_embed("dAILY", f"yOU cLAIMED yOUR dAILY 100 {CURRENCY_NAME}!"))

@bot.command()
async def work(ctx):
    now = datetime.now(datetime.timezone.utc)
    user_id = ctx.author.id
    last = work_cooldowns.get(user_id)
    if last and now - last < timedelta(minutes=20):
        rem = timedelta(minutes=20) - (now - last)
        await ctx.send(f"{ctx.author.mention}, you can work again in {str(rem).split('.')[0]}.")
        return
    work_cooldowns[user_id] = now
    jobs = ["chef", "barista", "programmer", "driver", "artist", "bjs"]
    job = random.choice(jobs)
    amount = random.randint(10, 50)
    change_balance(user_id, amount)
    await ctx.send(f"{ctx.author.mention}, you worked as a {job} and earned {amount} {CURRENCY_NAME}!")

@bot.command()
async def impregnate(ctx, partner: discord.Member):
    if partner.bot:
        await ctx.send("You cannot impregnate a bot!")
        return
    if partner.id == ctx.author.id:
        await ctx.send("You cannot impregnate yourself!")
        return
    payer_is_author = random.choice([True, False])
    child_support = 50
    payer = ctx.author if payer_is_author else partner
    receiver = partner if payer_is_author else ctx.author
    if get_balance(payer.id) < child_support:
        await ctx.send(f"{payer.mention} does not have enough {CURRENCY_NAME} to pay child support!")
        return
    change_balance(payer.id, -child_support)
    change_balance(receiver.id, child_support)
    await ctx.send(f"{ctx.author.mention} impregnated {partner.mention}!\n{payer.mention} pays {child_support} {CURRENCY_NAME} as child support to {receiver.mention}.")

@bot.command()
async def nuke(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    await ctx.channel.purge(limit=1000)
    await ctx.send("boom")
    await ctx.send("Usage: ?nuke - Deletes all messages in the channel. Only mods/admins can use this.")

@bot.command()
async def kick(ctx, member: discord.Member, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    try:
        await member.kick(reason=reason)
        await ctx.send(f"Kicked {member} for: {reason}")
    except Exception as e:
        await ctx.send(f"Failed to kick: {e}")

@bot.command()
async def ban(ctx, member: discord.Member = None, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    if member is None:
        await ctx.send("Usage: ?ban @user [reason] - Bans a member from the server. Only mods/admins can use this.")
        return
    try:
        await member.ban(reason=reason)
        await ctx.send(f"Banned {member} for: {reason}")
    except Exception as e:
        await ctx.send(f"Failed to ban: {e}")

@bot.command()
async def clear(ctx, amount: int = None):
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    if amount is None:
        await ctx.send("Usage: ?clear [amount] - Deletes a number of messages. Only mods/admins can use this.")
        return
    deleted = await ctx.channel.purge(limit=amount)
    await ctx.send(f"Cleared {len(deleted)} messages", delete_after=3)

@bot.command()
async def reactionroles(ctx):
    embed = discord.Embed(title="Choose your gender role by reacting", color=0x00ff00)
    embed.description = (
        "React with the emoji to get the role:\n"
        "üíô for mALE\n"
        "üíó for fEMALE\n"
        "ü§ç for oTHER (AKS)\n"
        "Remove your reaction to remove the role."
    )
    msg = await ctx.send(embed=embed)
    global ROLE_MESSAGE_ID
    ROLE_MESSAGE_ID = msg.id
    for emoji in EMOJI_TO_ROLE:
        await msg.add_reaction(emoji)

@bot.command()
async def nicki(ctx):
    lyrics = [
        "lIKE mJ dOCTOR, tHEY kILLIN mE. pROPOFOl, i kNOW tHEY hOPE i fALL.bUT tELL eM wINNIN iS mY mUTHUFUCKIN pROTOCOL..",
        "mE, nICKI m, i gOT tOO mANY m'S!!!",
        "aYO tONIGHT iS tHE nIGHT tHAT iMMMA gET tWISTED, mYX mOSCATO n vODKA iMA mIX iT.",
        "yOUR fLOW iS sUCH a bORE...",
        "aND i wILL rETIRE wITH tHE cROWN... yES!",
        "bE wHO yOU iS nEVER bE wHO yOU aRENT nEVA."
    ]
    lyric = random.choice(lyrics)
    embed = discord.Embed(
        title="nICKI mINAJ lYRIC",
        description=lyric,
        color=0xff69b4
    )
    # Removed footer message per user request
    await ctx.send(embed=embed)

@bot.command()
async def level(ctx):
    data = get_level(ctx.author.id)
    await ctx.send(f"{ctx.author.mention}, you are level {data['level']} with {data['xp']} XP.")

@bot.command()
async def leaderboard(ctx):
    sorted_users = sorted(user_xp.items(), key=lambda x: x[1]['level'] * 100 + x[1]['xp'], reverse=True)
    top = "Top 5 users:\n"
    for i, (user_id, data) in enumerate(sorted_users[:5]):
        member = ctx.guild.get_member(int(user_id))
        if member:
            top += f"{i+1}. {member.display_name} - Level {data['level']}\n"
    await ctx.send(top)

@bot.command()
async def spotify(ctx, member: discord.Member = None):
    member = member or ctx.author
    for activity in member.activities:
        if isinstance(activity, discord.Spotify):
            embed = discord.Embed(
                title=f"{member.display_name} is listening to Spotify!",
                description=f"**{activity.title}** by {activity.artist}\nAlbum: {activity.album}",
                color=0x1DB954
            )
            embed.set_thumbnail(url=activity.album_cover_url)
            embed.add_field(name="Track URL", value=f"[Open in Spotify](https://open.spotify.com/track/{activity.track_id})")
            msg = await ctx.send(embed=embed)
            await msg.add_reaction("<:bop:1399081053800501358>")
            await msg.add_reaction("<:flop:1398830540832116737>")
            return
    await ctx.send(f"{member.display_name} is not listening to Spotify right now.")

# Alias for spotify command
@bot.command(name="fm")
async def fm(ctx, member: discord.Member = None):
    """Show Spotify status for a user (alias for ?spotify)"""
    await spotify(ctx, member)

# Load environment variables
load_dotenv()

# Get token from environment variable
TOKEN = os.getenv("TOKEN")
if not TOKEN:
    print("Error: TOKEN not found in .env file")
    exit(1)

# Slash command version of beg
@bot.tree.command(name="beg", description="Beg for money (10 min cooldown)")
async def beg_slash(interaction: discord.Interaction):
    now = datetime.now(datetime.timezone.utc)
    user_id = interaction.user.id
    last = beg_cooldowns.get(user_id)
    if last and now - last < timedelta(minutes=10):
        rem = timedelta(minutes=10) - (now - last)
        await interaction.response.send_message(f"{interaction.user.mention}, you can beg again in {str(rem).split('.')[0]}", ephemeral=True)
        return
    beg_cooldowns[user_id] = now
    if random.random() < 0.5:
        await interaction.response.send_message(f"{interaction.user.mention}, no one gave you anything this time.")
    else:
        amount = random.randint(1, 20)
        change_balance(user_id, amount)
        await interaction.response.send_message(f"{interaction.user.mention}, you begged and got {amount} {CURRENCY_NAME}!")

# Slash command version of work
@bot.tree.command(name="work", description="Work a job to earn money (20 min cooldown)")
async def work_slash(interaction: discord.Interaction):
    now = datetime.now(datetime.timezone.utc)
    user_id = interaction.user.id
    last = work_cooldowns.get(user_id)
    if last and now - last < timedelta(minutes=20):
        rem = timedelta(minutes=20) - (now - last)
        await interaction.response.send_message(f"{interaction.user.mention}, you can work again in {str(rem).split('.')[0]}", ephemeral=True)
        return
    work_cooldowns[user_id] = now
    jobs = ["chef", "barista", "programmer", "driver", "artist", "bjs"]
    job = random.choice(jobs)
    amount = random.randint(10, 50)
    change_balance(user_id, amount)
    await interaction.response.send_message(f"{interaction.user.mention}, you worked as a {job} and earned {amount} {CURRENCY_NAME}!")

# Slash command version of impregnate
@bot.tree.command(name="impregnate", description="Impregnate someone, child support paid randomly")
@app_commands.describe(partner="The user to impregnate")
async def impregnate_slash(interaction: discord.Interaction, partner: discord.Member):
    if partner.bot:
        await interaction.response.send_message("You cannot impregnate a bot!", ephemeral=True)
        return
    if partner.id == interaction.user.id:
        await interaction.response.send_message("You cannot impregnate yourself!", ephemeral=True)
        return
    payer_is_author = random.choice([True, False])
    child_support = 50
    payer = interaction.user if payer_is_author else partner
    receiver = partner if payer_is_author else interaction.user
    if get_balance(payer.id) < child_support:
        await interaction.response.send_message(f"{payer.mention} does not have enough {CURRENCY_NAME} to pay child support!", ephemeral=True)
        return
    change_balance(payer.id, -child_support)
    change_balance(receiver.id, child_support)
    await interaction.response.send_message(f"{interaction.user.mention} impregnated {partner.mention}!\n{payer.mention} pays {child_support} {CURRENCY_NAME} as child support to {receiver.mention}.")

# Slash command version of nuke
@bot.tree.command(name="nuke", description="Delete all messages in channel (mods only)")
async def nuke_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    await interaction.channel.purge(limit=1000)
    await interaction.response.send_message("boom")
    await interaction.followup.send("Usage: /nuke - Deletes all messages in the channel. Only mods/admins can use this.", ephemeral=True)

# Slash command version of kick
@bot.tree.command(name="kick", description="Kick a member (mods only)")
@app_commands.describe(member="The member to kick", reason="Reason for kick")
async def kick_slash(interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    try:
        await member.kick(reason=reason)
        await interaction.response.send_message(f"Kicked {member} for: {reason}")
    except Exception as e:
        await interaction.response.send_message(f"Failed to kick: {e}", ephemeral=True)

# Slash command version of ban
@bot.tree.command(name="ban", description="Ban a member (mods only)")
@app_commands.describe(member="The member to ban", reason="Reason for ban")
async def ban_slash(interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    try:
        await member.ban(reason=reason)
        await interaction.response.send_message(f"Banned {member} for: {reason}")
    except Exception as e:
        await interaction.response.send_message(f"Failed to ban: {e}", ephemeral=True)

# Slash command version of reactionroles
@bot.tree.command(name="reactionroles", description="Post gender role selection message")
async def reactionroles_slash(interaction: discord.Interaction):
    embed = discord.Embed(title="Choose your gender role by reacting", color=0x00ff00)
    embed.description = (
        "React with the emoji to get the role:\n"
        "üíô for mALE\n"
        "üíó for fEMALE\n"
        "ü§ç for oTHER (AKS)\n"
        "Remove your reaction to remove the role."
    )
    msg = await interaction.channel.send(embed=embed)
    global ROLE_MESSAGE_ID
    ROLE_MESSAGE_ID = msg.id
    for emoji in EMOJI_TO_ROLE:
        await msg.add_reaction(emoji)
    await interaction.response.send_message("Reaction roles message posted!", ephemeral=True)

# Slash command version of nicki
@bot.tree.command(name="nicki", description="Get a random Nicki Minaj lyric")
async def nicki_slash(interaction: discord.Interaction):
    lyrics = [
        "lIKE mJ dOCTOR, tHEY kILLIN mE. pROPOFOl, i kNOW tHEY hOPE i fALL.bUT tELL eM wINNIN iS mY mUTHUFUCKIN pROTOCOL..",
        "mE, nICKI m, i gOT tOO mANY wINS!!!",
        "aYO tONIGHT iS tHE nIGHT tHAT iMMMA gET tWISTED, mYX mOSCATO n vODKA iMA mIX iT.",
        "yOUR fLOW iS sUCH a bORE...",
        "aND i wILL rETIRE wITH tHE cROWN... yES!",
        "bE wHO yOU iS nEVER bE wHO yOU aRENT nEVA."
    ]
    await interaction.response.send_message(random.choice(lyrics))

# Slash command version of level
@bot.tree.command(name="level", description="Show your level and XP")
async def level_slash(interaction: discord.Interaction):
    data = get_level(interaction.user.id)
    await interaction.response.send_message(f"{interaction.user.mention}, you are level {data['level']} with {data['xp']} XP.")

# Slash command version of leaderboard
@bot.tree.command(name="leaderboard", description="Show top 5 users by level")
async def leaderboard_slash(interaction: discord.Interaction):
    sorted_users = sorted(user_xp.items(), key=lambda x: x[1]['level'] * 100 + x[1]['xp'], reverse=True)
    top = "Top 5 users:\n"
    for i, (user_id, data) in enumerate(sorted_users[:5]):
        guild = interaction.guild
        member = guild.get_member(int(user_id)) if guild else None
        if member:
            top += f"{i+1}. {member.display_name} - Level {data['level']}\n"
    await interaction.response.send_message(top)

# Slash command version of spotify
@bot.tree.command(name="spotify", description="Show Spotify status for a user (or yourself)")
@app_commands.describe(member="The member to check (optional)")
async def spotify_slash(interaction: discord.Interaction, member: discord.Member = None):
    member = member or interaction.user
    # Get the full member object from the guild
    if interaction.guild:
        member = interaction.guild.get_member(member.id)
    if not member:
        await interaction.response.send_message("Could not find that member.", ephemeral=True)
        return
    for activity in member.activities:
        if isinstance(activity, discord.Spotify):
            embed = discord.Embed(
                title=f"{member.display_name} is listening to Spotify!",
                description=f"**{activity.title}** by {activity.artist}\nAlbum: {activity.album}",
                color=0x1DB954
            )
            embed.set_thumbnail(url=activity.album_cover_url)
            embed.add_field(name="Track URL", value=f"[Open in Spotify](https://open.spotify.com/track/{activity.track_id})")
            msg = await interaction.channel.send(embed=embed)
            await msg.add_reaction("<:bop:1399081053800501358>")
            await msg.add_reaction("<:flop:1398830540832116737>")
            return
    await interaction.response.send_message(f"{member.display_name} is not listening to Spotify right now.")

# Slash command for fm (alias for spotify)
@bot.tree.command(name="fm", description="Show Spotify status for a user (alias for /spotify)")
@app_commands.describe(member="The member to check (optional)")
async def fm_slash(interaction: discord.Interaction, member: discord.Member = None):
    await spotify_slash(interaction, member)

# =========================
# Command Stubs for All Requested Features
# =========================

start_time = time.time()

# Utility
@bot.command()
async def ping(ctx):
    """Checks if Nova is online and returns latency."""
    await ctx.send(f'Pong! üèì Latency: {round(bot.latency * 1000)}ms')

@bot.command()
async def about(ctx):
    """Info about Nova."""
    embed = discord.Embed(
        title="aBOUT nOVA",
        description="i'M nOVA, yOUR aLL-iN-oNE dISCORD bOT. sASS, hELP, aND cHAOS iN oNE pACKAGE!",
        color=0xff69b4
    )
    embed.set_footer(text="cREATED bY mOTHER üíÖ")
    await ctx.send(embed=embed)

@bot.command()
async def uptime(ctx):
    """Shows how long Nova has been running."""
    up = int(time.time() - start_time)
    hours, remainder = divmod(up, 3600)
    minutes, seconds = divmod(remainder, 60)
    await ctx.send(f"Uptime: {hours}h {minutes}m {seconds}s")

# Relationship/Roleplay
@bot.command()
async def divorce(ctx, user: discord.Member):
    relationships = load_relationships()
    key = f"married:{ctx.author.id}"
    if key not in relationships or relationships[key] != user.id:
        await ctx.send(embed=nova_embed("dIVORCE", "yOU'RE nOT mARRIED tO tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await ctx.send(embed=nova_embed("dIVORCE", f"üíî {ctx.author.display_name} dIVORCED {user.display_name}!"))

@bot.tree.command(name="divorce", description="End your marriage with a user")
async def divorce_slash(interaction: discord.Interaction, user: discord.Member):
    relationships = load_relationships()
    key = f"married:{interaction.user.id}"
    if key not in relationships or relationships[key] != user.id:
        await interaction.response.send_message(embed=nova_embed("dIVORCE", "yOU'RE nOT mARRIED tO tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await interaction.response.send_message(embed=nova_embed("dIVORCE", f"üíî {interaction.user.display_name} dIVORCED {user.display_name}!"))

@bot.command()
async def marry(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("mARRY", "yOU cAN'T mARRY yOURSELF, bABY!"))
        return
    relationships = load_relationships()
    key = f"married:{ctx.author.id}"
    if key in relationships:
        await ctx.send(embed=nova_embed("mARRY", "yOU'RE aLREADY mARRIED!"))
        return
    if user.id in pending_marriages:
        await ctx.send(embed=nova_embed("mARRY", "tHAT uSER aLREADY hAS a pENDING pROPOSAL!"))
        return
    pending_marriages[user.id] = ctx.author.id
    await ctx.send(embed=nova_embed("mARRY", f"üíç {ctx.author.display_name} pROPOSED tO {user.display_name}! {user.mention}, tYPE `?acceptmarry` tO aCCEPT. yOU hAVE 30 sECONDS!"))
    async def expire():
        await asyncio.sleep(30)
        if user.id in pending_marriages and pending_marriages[user.id] == ctx.author.id:
            del pending_marriages[user.id]
            await ctx.send(embed=nova_embed("mARRY", f"{user.display_name} dIDN'T rESPOND iN tIME! tRY aGAIN lATER."))
    ctx.bot.loop.create_task(expire())

@bot.tree.command(name="marry", description="Send a marriage proposal to a user")
@app_commands.describe(user="The user to marry")
async def marry_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("mARRY", "yOU cAN'T mARRY yOURSELF, bABY!"))
        return
    relationships = load_relationships()
    key = f"married:{interaction.user.id}"
    if key in relationships:
        await interaction.response.send_message(embed=nova_embed("mARRY", "yOU'RE aLREADY mARRIED!"))
        return
    if user.id in pending_marriages:
        await interaction.response.send_message(embed=nova_embed("mARRY", "tHAT uSER aLREADY hAS a pENDING pROPOSAL!"))
        return
    pending_marriages[user.id] = interaction.user.id
    await interaction.response.send_message(embed=nova_embed("mARRY", f"üíç {interaction.user.display_name} pROPOSED tO {user.display_name}! {user.mention}, uSE `/acceptmarry` tO aCCEPT. yOU hAVE 30 sECONDS!"))
    async def expire():
        await asyncio.sleep(30)
        if user.id in pending_marriages and pending_marriages[user.id] == interaction.user.id:
            del pending_marriages[user.id]
            await interaction.followup.send(embed=nova_embed("mARRY", f"{user.display_name} dIDN'T rESPOND iN tIME! tRY aGAIN lATER."))
    interaction.client.loop.create_task(expire())

@bot.command()
async def adopt(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("aDOPT", "yOU cAN'T aDOPT yOURSELF!"))
        return
    relationships = load_relationships()
    
    # Check if user is already adopted by someone
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == user.id:
            adopter_id = int(key.split(":")[1])
            adopter = ctx.guild.get_member(adopter_id)
            if adopter:
                await ctx.send(embed=nova_embed("aDOPT", f"{user.display_name} iS aLREADY aDOPTED bY {adopter.display_name}!"))
                return
    
    if user.id in pending_adoptions:
        await ctx.send(embed=nova_embed("aDOPT", "tHAT uSER aLREADY hAS a pENDING aDOPTION!"))
        return
    pending_adoptions[user.id] = ctx.author.id
    view = AdoptionView(ctx.author.id, user.id)
    await ctx.send(embed=nova_embed("aDOPT", f"üçº {ctx.author.display_name} wANTS tO aDOPT {user.display_name}! {user.mention}, cLICK tHE bUTTONS bELOW!"), view=view)

@bot.tree.command(name="adopt", description="Adopt a user (fun roleplay)")
@app_commands.describe(user="The user to adopt")
async def adopt_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("aDOPT", "yOU cAN'T aDOPT yOURSELF!"))
        return
    relationships = load_relationships()
    
    # Check if user is already adopted by someone
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == user.id:
            adopter_id = int(key.split(":")[1])
            adopter = interaction.guild.get_member(adopter_id)
            if adopter:
                await interaction.response.send_message(embed=nova_embed("aDOPT", f"{user.display_name} iS aLREADY aDOPTED bY {adopter.display_name}!"))
                return
    
    if user.id in pending_adoptions:
        await interaction.response.send_message(embed=nova_embed("aDOPT", "tHAT uSER aLREADY hAS a pENDING aDOPTION!"))
        return
    pending_adoptions[user.id] = interaction.user.id
    view = AdoptionView(interaction.user.id, user.id)
    await interaction.response.send_message(embed=nova_embed("aDOPT", f"üçº {interaction.user.display_name} wANTS tO aDOPT {user.display_name}! {user.mention}, cLICK tHE bUTTONS bELOW!"), view=view)

class AdoptionView(View):
    def __init__(self, adopter_id, adoptee_id):
        super().__init__(timeout=30)
        self.adopter_id = adopter_id
        self.adoptee_id = adoptee_id

    @discord.ui.button(label="aCCEPT", style=discord.ButtonStyle.green, emoji="‚úÖ")
    async def accept_adoption(self, interaction: discord.Interaction, button: Button):
        if interaction.user.id != self.adoptee_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION iS nOT fOR yOU!"), ephemeral=True)
            return
        
        if self.adoptee_id not in pending_adoptions or pending_adoptions[self.adoptee_id] != self.adopter_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION hAS eXPIRED!"), ephemeral=True)
            return
        
        adopter = interaction.guild.get_member(self.adopter_id)
        if not adopter:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "aDOPTER nOT fOUND!"), ephemeral=True)
            return
        
        relationships = load_relationships()
        key = f"adopted:{self.adopter_id}"
        relationships[key] = self.adoptee_id
        save_relationships(relationships)
        
        del pending_adoptions[self.adoptee_id]
        
        # Disable all buttons
        for child in self.children:
            child.disabled = True
        
        await interaction.response.edit_message(
            embed=nova_embed("aDOPTION aCCEPTED", f"üçº {interaction.user.display_name} hAS bEEN aDOPTED bY {adopter.display_name}!"),
            view=self
        )

    @discord.ui.button(label="dECLINE", style=discord.ButtonStyle.red, emoji="‚ùå")
    async def decline_adoption(self, interaction: discord.Interaction, button: Button):
        if interaction.user.id != self.adoptee_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION iS nOT fOR yOU!"), ephemeral=True)
            return
        
        if self.adoptee_id not in pending_adoptions or pending_adoptions[self.adoptee_id] != self.adopter_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION hAS eXPIRED!"), ephemeral=True)
            return
        
        adopter = interaction.guild.get_member(self.adopter_id)
        adopter_name = adopter.display_name if adopter else "Unknown"
        
        del pending_adoptions[self.adoptee_id]
        
        # Disable all buttons
        for child in self.children:
            child.disabled = True
        
        await interaction.response.edit_message(
            embed=nova_embed("aDOPTION dECLINED", f"üòî {interaction.user.display_name} dECLINED tHE aDOPTION fROM {adopter_name}!"),
            view=self
        )

@bot.command()
async def emancipate(ctx, user: discord.Member):
    relationships = load_relationships()
    key = f"adopted:{ctx.author.id}"
    if key not in relationships or relationships[key] != user.id:
        await ctx.send(embed=nova_embed("eMANCIPATE", "yOU hAVEN'T aDOPTED tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await ctx.send(embed=nova_embed("eMANCIPATE", f"{user.display_name} hAS bEEN eMANCIPATED bY {ctx.author.display_name}!"))

@bot.tree.command(name="emancipate", description="Free a previously adopted user")
async def emancipate_slash(interaction: discord.Interaction, user: discord.Member):
    relationships = load_relationships()
    key = f"adopted:{interaction.user.id}"
    if key not in relationships or relationships[key] != user.id:
        await interaction.response.send_message(embed=nova_embed("eMANCIPATE", "yOU hAVEN'T aDOPTED tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await interaction.response.send_message(embed=nova_embed("eMANCIPATE", f"{user.display_name} hAS bEEN eMANCIPATED bY {interaction.user.display_name}!"))

@bot.command()
async def getemancipated(ctx):
    relationships = load_relationships()
    
    # Find if user is adopted by someone
    adopted_by = None
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == ctx.author.id:
            adopter_id = int(key.split(":")[1])
            adopted_by = ctx.guild.get_member(adopter_id)
            break
    
    if not adopted_by:
        await ctx.send(embed=nova_embed("gET eMANCIPATED", "yOU aREN'T aDOPTED bY aNYONE!"))
        return
    
    # Remove the adoption
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == ctx.author.id:
            del relationships[key]
            break
    
    save_relationships(relationships)
    await ctx.send(embed=nova_embed("gET eMANCIPATED", f"üèõÔ∏è {ctx.author.display_name} hAS bEEN eMANCIPATED fROM {adopted_by.display_name}! yOU aRE nOW fREE!"))

@bot.tree.command(name="getemancipated", description="Emancipate yourself from your adoptive parent")
async def getemancipated_slash(interaction: discord.Interaction):
    relationships = load_relationships()
    
    # Find if user is adopted by someone
    adopted_by = None
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == interaction.user.id:
            adopter_id = int(key.split(":")[1])
            adopted_by = interaction.guild.get_member(adopter_id)
            break
    
    if not adopted_by:
        await interaction.response.send_message(embed=nova_embed("gET eMANCIPATED", "yOU aREN'T aDOPTED bY aNYONE!"), ephemeral=True)
        return
    
    # Remove the adoption
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == interaction.user.id:
            del relationships[key]
            break
    
    save_relationships(relationships)
    await interaction.response.send_message(embed=nova_embed("gET eMANCIPATED", f"üèõÔ∏è {interaction.user.display_name} hAS bEEN eMANCIPATED fROM {adopted_by.display_name}! yOU aRE nOW fREE!"))

@bot.command()
async def familytree(ctx, user: discord.Member = None):
    user = user or ctx.author
    relationships = load_relationships()
    
    # Find spouse
    spouse = None
    for key, value in relationships.items():
        if key.startswith("married:"):
            user_id = int(key.split(":")[1])
            if user_id == user.id:
                spouse = ctx.guild.get_member(value)
                break
            elif value == user.id:
                spouse = ctx.guild.get_member(user_id)
                break
    
    # Find children (people this user has adopted)
    children = []
    for key, value in relationships.items():
        if key.startswith("adopted:"):
            adopter_id = int(key.split(":")[1])
            if adopter_id == user.id:
                child = ctx.guild.get_member(value)
                if child:
                    children.append(child)
    
    # Find parents (people who adopted this user)
    parents = []
    for key, value in relationships.items():
        if key.startswith("adopted:"):
            if value == user.id:
                adopter_id = int(key.split(":")[1])
                parent = ctx.guild.get_member(adopter_id)
                if parent:
                    parents.append(parent)
    
    # Build family tree
    tree = f"**fAMILY tREE fOR {user.display_name}**\n\n"
    
    if spouse:
        tree += f"üíç **sPOUSE:** {spouse.display_name}\n"
    else:
        tree += "üíç **sPOUSE:** nONE\n"
    
    if children:
        tree += f"üë∂ **cHILDREN:** {', '.join([child.display_name for child in children])}\n"
    else:
        tree += "üë∂ **cHILDREN:** nONE\n"
    
    if parents:
        tree += f"üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **pARENTS:** {', '.join([parent.display_name for parent in parents])}\n"
    else:
        tree += "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **pARENTS:** nONE\n"
    
    await ctx.send(embed=nova_embed("fAMILY tREE", tree))

@bot.tree.command(name="familytree", description="Show family tree for a user")
@app_commands.describe(user="The user to check (optional - shows your own)")
async def familytree_slash(interaction: discord.Interaction, user: discord.Member = None):
    user = user or interaction.user
    relationships = load_relationships()
    
    # Find spouse
    spouse = None
    for key, value in relationships.items():
        if key.startswith("married:"):
            user_id = int(key.split(":")[1])
            if user_id == user.id:
                spouse = interaction.guild.get_member(value)
                break
            elif value == user.id:
                spouse = interaction.guild.get_member(user_id)
                break
    
    # Find children (people this user has adopted)
    children = []
    for key, value in relationships.items():
        if key.startswith("adopted:"):
            adopter_id = int(key.split(":")[1])
            if adopter_id == user.id:
                child = interaction.guild.get_member(value)
                if child:
                    children.append(child)
    
    # Find parents (people who adopted this user)
    parents = []
    for key, value in relationships.items():
        if key.startswith("adopted:"):
            if value == user.id:
                adopter_id = int(key.split(":")[1])
                parent = interaction.guild.get_member(adopter_id)
                if parent:
                    parents.append(parent)
    
    # Build family tree
    tree = f"**fAMILY tREE fOR {user.display_name}**\n\n"
    
    if spouse:
        tree += f"üíç **sPOUSE:** {spouse.display_name}\n"
    else:
        tree += "üíç **sPOUSE:** nONE\n"
    
    if children:
        tree += f"üë∂ **cHILDREN:** {', '.join([child.display_name for child in children])}\n"
    else:
        tree += "üë∂ **cHILDREN:** nONE\n"
    
    if parents:
        tree += f"üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **pARENTS:** {', '.join([parent.display_name for parent in parents])}\n"
    else:
        tree += "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **pARENTS:** nONE\n"
    
    await interaction.response.send_message(embed=nova_embed("fAMILY tREE", tree))

@bot.command()
async def kiss(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("kISS", "yOU cAN'T kISS yOURSELF!"))
        return
    responses = [
        f"üíã {ctx.author.mention} kISSES {user.mention} gENTLY!",
        f"üòò {ctx.author.mention} gIVES {user.mention} a sWEET kISS!",
        f"üíï {ctx.author.mention} pLANTS a kISS oN {user.display_name}'s cHEEK!",
        f"ü•∞ {ctx.author.mention} kISSES {user.display_name} pASSIONATELY!"
    ]
    await ctx.send(embed=nova_embed("kISS", random.choice(responses)))

@bot.tree.command(name="kiss", description="Kiss a user (fun roleplay)")
@app_commands.describe(user="The user to kiss")
async def kiss_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("kISS", "yOU cAN'T kISS yOURSELF!"))
        return
    responses = [
        f"ÔøΩÔøΩ {interaction.user.mention} kISSES {user.mention} gENTLY!",
        f"üòò {interaction.user.mention} gIVES {user.mention} a sWEET kISS!",
        f"üíï {interaction.user.mention} pLANTS a kISS oN {user.display_name}'s cHEEK!",
        f"ü•∞ {interaction.user.mention} kISSES {user.display_name} pASSIONATELY!"
    ]
    await interaction.response.send_message(embed=nova_embed("kISS", random.choice(responses)))

@bot.command()
async def slap(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("sLAP", "yOU cAN'T sLAP yOURSELF!"))
        return
    responses = [
        f"üëã {ctx.author.mention} sLAPS {user.mention} aCROSS tHE fACE!",
        f"üí• {ctx.author.mention} gIVES {user.mention} a hARD sLAP!",
        f"ü§ö {ctx.author.mention} sLAPS {user.mention} wITH a tOWEL!",
        f"üí¢ {ctx.author.mention} sLAPS {user.display_name} fOR bEING nAUGHTY!"
    ]
    await ctx.send(embed=nova_embed("sLAP", random.choice(responses)))

@bot.tree.command(name="slap", description="Slap a user (fun roleplay)")
@app_commands.describe(user="The user to slap")
async def slap_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("sLAP", "yOU cAN'T sLAP yOURSELF!"))
        return
    responses = [
        f"ÔøΩÔøΩ {interaction.user.mention} sLAPS {user.mention} aCROSS tHE fACE!",
        f"üí• {interaction.user.mention} gIVES {user.mention} a hARD sLAP!",
        f"ü§ö {interaction.user.mention} sLAPS {user.mention} wITH a tOWEL!",
        f"üí¢ {interaction.user.mention} sLAPS {user.display_name} fOR bEING nAUGHTY!"
    ]
    await interaction.response.send_message(embed=nova_embed("sLAP", random.choice(responses)))

@bot.command()
async def whoasked(ctx, user: discord.Member = None):
    if not user:
        await ctx.send(embed=nova_embed("wHO aSKED", "nOBODY aSKED fOR yOUR oPINION!"))
        return
    responses = [
        f"ü§î wHO aSKED {user.display_name}?",
        f"‚ùì dID aNYONE aSK {user.display_name}?",
        f"ü§∑‚Äç‚ôÄÔ∏è nOBODY aSKED {user.display_name}!",
        f"üôÑ wHO eVEN aSKED {user.display_name}?"
    ]
    await ctx.send(embed=nova_embed("wHO aSKED", random.choice(responses)))

@bot.tree.command(name="whoasked", description="Ask who asked for someone's opinion")
@app_commands.describe(user="The user to question (optional)")
async def whoasked_slash(interaction: discord.Interaction, user: discord.Member = None):
    if not user:
        await interaction.response.send_message(embed=nova_embed("wHO aSKED", "nOBODY aSKED fOR yOUR oPINION!"))
        return
    responses = [
        f"ü§î wHO aSKED {user.display_name}?",
        f"‚ùì dID aNYONE aSK {user.display_name}?",
        f"ü§∑‚Äç‚ôÄÔ∏è nOBODY aSKED {user.display_name}!",
        f"üôÑ wHO eVEN aSKED {user.display_name}?"
    ]
    await interaction.response.send_message(embed=nova_embed("wHO aSKED", random.choice(responses)))

@bot.command()
async def voguebattle(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("vOGUE bATTLE", "yOU cAN'T bATTLE yOURSELF!"))
        return
    
    # Vogue battle moves
    moves = [
        "DUCK WALK",
        "DEATH DROP", 
        "HAND PERFORMANCE",
        "CATWALK",
        "FACE",
        "LIPSYNC",
        "SHABLAM",
        "FIERCE POSE",
        "DIAMOND POSE",
        "STAR POSE"
    ]
    
    # Battle results
    results = [
        f"üèÜ **{ctx.author.display_name}** WINS THE VOGUE BATTLE! {user.display_name} COULDN'T HANDLE THE FIERCENESS!",
        f"üíÄ **{user.display_name}** DESTROYS {ctx.author.display_name} IN THE BATTLE! TOTAL ANNIHILATION!",
        f"ü§ù IT'S A TIE! BOTH **{ctx.author.display_name}** AND **{user.display_name}** ARE EQUALLY FIERCE!",
        f"üî• **{ctx.author.display_name}** SERVES FACE AND WINS! {user.display_name} IS SHOOK!",
        f"üíÖ **{user.display_name}** TURNS IT OUT AND WINS! {ctx.author.display_name} IS GAGGED!"
    ]
    
    # Random moves for both users
    author_move = random.choice(moves)
    opponent_move = random.choice(moves)
    
    # Determine winner (random with slight bias to author)
    winner = random.choice(results)
    
    battle_text = f"**VOGUE BATTLE: {ctx.author.display_name} vs {user.display_name}**\n\n"
    battle_text += f"üíÉ **{ctx.author.display_name}**: {author_move}\n"
    battle_text += f"üï∫ **{user.display_name}**: {opponent_move}\n\n"
    battle_text += f"**RESULT:** {winner}"
    
    await ctx.send(embed=nova_embed("vOGUE bATTLE", battle_text))

@bot.tree.command(name="voguebattle", description="Start a vogue battle with another user")
@app_commands.describe(user="The user to battle")
async def voguebattle_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("vOGUE bATTLE", "yOU cAN'T bATTLE yOURSELF!"))
        return
    
    # Vogue battle moves
    moves = [
        "DUCK WALK",
        "DEATH DROP", 
        "HAND PERFORMANCE",
        "CATWALK",
        "FACE",
        "LIPSYNC",
        "SHABLAM",
        "FIERCE POSE",
        "DIAMOND POSE",
        "STAR POSE"
    ]
    
    # Battle results
    results = [
        f"üèÜ **{interaction.user.display_name}** WINS THE VOGUE BATTLE! {user.display_name} COULDN'T HANDLE THE FIERCENESS!",
        f"üíÄ **{user.display_name}** DESTROYS {interaction.user.display_name} IN THE BATTLE! TOTAL ANNIHILATION!",
        f"ü§ù IT'S A TIE! BOTH **{interaction.user.display_name}** AND **{user.display_name}** ARE EQUALLY FIERCE!",
        f"üî• **{interaction.user.display_name}** SERVES FACE AND WINS! {user.display_name} IS SHOOK!",
        f"üíÖ **{user.display_name}** TURNS IT OUT AND WINS! {interaction.user.display_name} IS GAGGED!"
    ]
    
    # Random moves for both users
    author_move = random.choice(moves)
    opponent_move = random.choice(moves)
    
    # Determine winner (random with slight bias to author)
    winner = random.choice(results)
    
    battle_text = f"**VOGUE BATTLE: {interaction.user.display_name} vs {user.display_name}**\n\n"
    battle_text += f"üíÉ **{interaction.user.display_name}**: {author_move}\n"
    battle_text += f"üï∫ **{user.display_name}**: {opponent_move}\n\n"
    battle_text += f"**RESULT:** {winner}"
    
    await interaction.response.send_message(embed=nova_embed("vOGUE BATTLE", battle_text))
@bot.command()
async def lock(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("lOCK", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        await ctx.channel.set_permissions(ctx.guild.default_role, send_messages=False)
        await ctx.send(embed=nova_embed("lOCK", f"üîí {ctx.channel.mention} hAS bEEN lOCKED!"))
        await ctx.send("Usage: ?lock - Locks the current channel. Only mods/admins can use this.")
    except Exception:
        await ctx.send(embed=nova_embed("lOCK", "cOULD nOT lOCK tHE cHANNEL!"))

@bot.tree.command(name="lock", description="Lock the current channel (mods only)")
async def lock_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("lOCK", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        await interaction.channel.set_permissions(interaction.guild.default_role, send_messages=False)
        await interaction.response.send_message(embed=nova_embed("lOCK", f"üîí {interaction.channel.mention} hAS bEEN lOCKED!"))
        await interaction.followup.send("Usage: /lock - Locks the current channel. Only mods/admins can use this.", ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("lOCK", "cOULD nOT lOCK tHE cHANNEL!"), ephemeral=True)

@bot.command()
async def unlock(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("uNLOCK", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        await ctx.channel.set_permissions(ctx.guild.default_role, send_messages=None)
        await ctx.send(embed=nova_embed("uNLOCK", f"üîì {ctx.channel.mention} hAS bEEN uNLOCKED!"))
        await ctx.send("Usage: ?unlock - Unlocks the current channel. Only mods/admins can use this.")
    except Exception:
        await ctx.send(embed=nova_embed("uNLOCK", "cOULD nOT uNLOCK tHE cHANNEL!"))

@bot.tree.command(name="unlock", description="Unlock the current channel (mods only)")
async def unlock_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("uNLOCK", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        await interaction.channel.set_permissions(interaction.guild.default_role, send_messages=None)
        await interaction.response.send_message(embed=nova_embed("uNLOCK", f"üîì {interaction.channel.mention} hAS bEEN uNLOCKED!"))
        await interaction.followup.send("Usage: /unlock - Unlocks the current channel. Only mods/admins can use this.", ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("uNLOCK", "cOULD nOT uNLOCK tHE cHANNEL!"), ephemeral=True)

# Pending adoptions
pending_adoptions = {}  # user_id: adopter_id

@bot.command()
async def afk(ctx, *, reason: str = "aFK"):
    AFK_STATUS[ctx.author.id] = {"reason": reason, "since": datetime.now(datetime.timezone.utc), "mentions": set()}
    save_afk()  # Save AFK data after setting status
    await ctx.send(embed=nova_embed("aFK", f"{ctx.author.display_name} iS nOW aFK: {reason}"))

@bot.tree.command(name="afk", description="Set your AFK status")
@app_commands.describe(reason="Reason for being AFK")
async def afk_slash(interaction: discord.Interaction, reason: str = "aFK"):
    AFK_STATUS[interaction.user.id] = {"reason": reason, "since": datetime.now(datetime.timezone.utc), "mentions": set()}
    save_afk()  # Save AFK data after setting status
    await interaction.response.send_message(embed=nova_embed("aFK", f"{interaction.user.display_name} iS nOW aFK: {reason}"))

class MentionsView(View):
    def __init__(self, user_id):
        super().__init__(timeout=60)
        self.user_id = user_id

    @discord.ui.button(label="cHECK mENTIONS", style=discord.ButtonStyle.primary)
    async def check_mentions(self, interaction: discord.Interaction, button: Button):
        afk = AFK_STATUS.get(self.user_id)
        if not afk or not afk["mentions"]:
            await interaction.response.send_message(embed=nova_embed("aFK", "nO oNE mENTIONED yOU wHILE yOU wERE aWAY!"), ephemeral=True)
            return
        guild = interaction.guild
        names = []
        for uid in afk["mentions"]:
            member = guild.get_member(uid)
            if member:
                names.append(member.display_name)
        if names:
            await interaction.response.send_message(embed=nova_embed("aFK mENTIONS", f"yOU wERE mENTIONED bY: {', '.join(names)}"), ephemeral=True)
        else:
            await interaction.response.send_message(embed=nova_embed("aFK", "nO oNE mENTIONED yOU wHILE yOU wERE aWAY!"), ephemeral=True)



@bot.command()
async def mute(ctx, member: discord.Member = None):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("mUTE", "yOU dON'T hAVE pERMISSION!"))
        return
    if not member:
        await ctx.send(embed=nova_embed("mUTE", "yOU nEED tO mENTION sOMEONE!"))
        return
    if member == ctx.author:
        await ctx.send(embed=nova_embed("mUTE", "nICE tRY, bUT yOU cAN'T mUTE yOURSELF!"))
        return
    role = await get_or_create_muted_role(ctx.guild)
    if not role:
        await ctx.send(embed=nova_embed("mUTE", "cOULD nOT cREATE oR fIND tHE mUTED rOLE!"))
        return
    if role in member.roles:
        await ctx.send(embed=nova_embed("mUTE", f"{member.mention} iS aLREADY mUTED!"))
        return
    try:
        await member.add_roles(role, reason="Muted by Nova")
        await ctx.send(embed=nova_embed("mUTE", f"{member.mention} hAS bEEN mUTED sERVER-WIDE!"))
        await ctx.send("Usage: ?mute @user - Mutes a member server-wide. Only mods/admins can use this.")
    except Exception:
        await ctx.send(embed=nova_embed("mUTE", "cOULD nOT mUTE tHAT uSER!"))

@bot.tree.command(name="mute", description="Mute a member server-wide (admin only)")
@app_commands.describe(member="Member to mute")
async def mute_slash(interaction: discord.Interaction, member: discord.Member):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("mUTE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    if member == interaction.user:
        await interaction.response.send_message(embed=nova_embed("mUTE", "nICE tRY, bUT yOU cAN'T mUTE yOURSELF!"), ephemeral=True)
        return
    role = await get_or_create_muted_role(interaction.guild)
    if not role:
        await interaction.response.send_message(embed=nova_embed("mUTE", "cOULD nOT cREATE oR fIND tHE mUTED rOLE!"), ephemeral=True)
        return
    if role in member.roles:
        await interaction.response.send_message(embed=nova_embed("mUTE", f"{member.mention} iS aLREADY mUTED!"), ephemeral=True)
        return
    try:
        await member.add_roles(role, reason="Muted by Nova")
        await interaction.response.send_message(embed=nova_embed("mUTE", f"{member.mention} hAS bEEN mUTED sERVER-WIDE!"))
        await interaction.followup.send("Usage: /mute @user - Mutes a member server-wide. Only mods/admins can use this.", ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("mUTE", "cOULD nOT mUTE tHAT uSER!"), ephemeral=True)

@bot.command()
async def unmute(ctx, member: discord.Member = None):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("uNMUTE", "yOU dON'T hAVE pERMISSION!"))
        return
    if not member:
        await ctx.send(embed=nova_embed("uNMUTE", "yOU nEED tO mENTION sOMEONE!"))
        return
    role = discord.utils.get(ctx.guild.roles, name="Muted")
    if not role or role not in member.roles:
        await ctx.send(embed=nova_embed("uNMUTE", f"{member.mention} iS nOT mUTED!"))
        return
    try:
        await member.remove_roles(role, reason="Unmuted by Nova")
        await ctx.send(embed=nova_embed("uNMUTE", f"{member.mention} hAS bEEN uNMUTED!"))
        await ctx.send("Usage: ?unmute @user - Unmutes a member server-wide. Only mods/admins can use this.")
    except Exception:
        await ctx.send(embed=nova_embed("uNMUTE", "cOULD nOT uNMUTE tHAT uSER!"))

@bot.tree.command(name="unmute", description="Unmute a member server-wide (admin only)")
@app_commands.describe(member="Member to unmute")
async def unmute_slash(interaction: discord.Interaction, member: discord.Member):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("uNMUTE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    role = discord.utils.get(interaction.guild.roles, name="Muted")
    if not role or role not in member.roles:
        await interaction.response.send_message(embed=nova_embed("uNMUTE", f"{member.mention} iS nOT mUTED!"), ephemeral=True)
        return
    try:
        await member.remove_roles(role, reason="Unmuted by Nova")
        await interaction.response.send_message(embed=nova_embed("uNMUTE", f"{member.mention} hAS bEEN uNMUTED!"))
        await interaction.followup.send("Usage: /unmute @user - Unmutes a member server-wide. Only mods/admins can use this.", ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("uNMUTE", "cOULD nOT uNMUTE tHAT uSER!"), ephemeral=True)

@bot.command()
async def case(ctx, member: discord.Member = None):
    """Show a member's past infractions"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("cASE", "Only mods/admins can view cases!"))
        return
    
    if member is None:
        await ctx.send(embed=nova_embed("cASE", "pLEASE sPECIFY a mEMBER!"))
        return
    
    user_id = str(member.id)
    
    if user_id not in INFRACTIONS or not INFRACTIONS[user_id]:
        embed = nova_embed(
            f"üìã cASE fILE: {member.display_name}",
            "nO iNFRACTIONS oN rECORD! üéâ"
        )
        embed.set_thumbnail(url=member.avatar.url if member.avatar else None)
        await ctx.send(embed=embed)
        return
    
    infractions = INFRACTIONS[user_id]
    infraction_list = []
    
    for i, infraction in enumerate(infractions[-10:], 1):  # Show last 10
        date_str = infraction["date"].strftime("%Y-%m-%d")
        infraction_list.append(
            f"**{i}.** {infraction['type'].upper()} - {date_str}\n"
            f"   rEASON: {infraction['reason']}\n"
            f"   mOD: {infraction['moderator']}"
        )
    
    embed = nova_embed(
        f"üìã cASE fILE: {member.display_name}",
        f"tOTAL iNFRACTIONS: {len(infractions)}\n\n" + "\n\n".join(infraction_list)
    )
    embed.set_thumbnail(url=member.avatar.url if member.avatar else None)
    
    if len(infractions) > 10:
        embed.set_footer(text=f"sHOWING lAST 10 oF {len(infractions)} iNFRACTIONS")
    
    await ctx.send(embed=embed)

@bot.tree.command(name="case", description="Show all moderation actions in this server (up to 20)")
async def case_slash(interaction: discord.Interaction):
    cases = mod_cases.get(interaction.guild.id, [])
    if not cases:
        await interaction.response.send_message(embed=nova_embed("cASES", "nO mODERATION cASES fOUND!"), ephemeral=True)
        return
    desc = ""
    for i, c in enumerate(cases, 1):
        desc += f"**{i}.** `{c['action']}` by {c['user']} in {c['channel']} ‚Ä¢ {c['time'].strftime('%Y-%m-%d %H:%M:%S')}\n"
    await interaction.response.send_message(embed=nova_embed("cASES", desc))
    await interaction.response.send_message("Usage: /case - Shows the last 20 moderation actions. Only mods/admins can use this.", ephemeral=True)

@bot.command()
async def snipe(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sNIPE", "yOU dON'T hAVE pERMISSION!"))
        return
    data = snipes.get(ctx.channel.id)
    if not data:
        await ctx.send(embed=nova_embed("sNIPE", "nOTHING tO sNIPE!"))
        return
    embed = nova_embed("sNIPE", data['content'])
    embed.set_footer(text=f"{data['author']} ‚Ä¢ {data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)

@bot.tree.command(name="snipe", description="Show the last deleted message in this channel")
async def snipe_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("sNIPE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    data = snipes.get(interaction.channel.id)
    if not data:
        await interaction.response.send_message(embed=nova_embed("sNIPE", "nOTHING tO sNIPE!"), ephemeral=True)
        return
    embed = nova_embed("sNIPE", data['content'])
    embed.set_footer(text=f"{data['author']} ‚Ä¢ {data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed)

@bot.command()
async def edsnipe(ctx):
    data = edsnipes.get(ctx.channel.id)
    if not data:
        await ctx.send(embed=nova_embed("eDSNIPE", "nOTHING tO eDSNIPE!"))
        return
    embed = nova_embed("eDSNIPE", data['content'])
    embed.set_footer(text=f"{data['author']} ‚Ä¢ {data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)

@bot.tree.command(name="edsnipe", description="Show the last edited (before) message in this channel")
async def edsnipe_slash(interaction: discord.Interaction):
    data = edsnipes.get(interaction.channel.id)
    if not data:
        await interaction.response.send_message(embed=nova_embed("eDSNIPE", "nOTHING tO eDSNIPE!"), ephemeral=True)
        return
    embed = nova_embed("eDSNIPE", data['content'])
    embed.set_footer(text=f"{data['author']} ‚Ä¢ {data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed)

@bot.command()
async def slowmode(ctx, seconds: int = 0):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sLOWMODE", "yOU dON'T hAVE pERMISSION!"))
        return
    await ctx.channel.edit(slowmode_delay=seconds)
    await ctx.send(embed=nova_embed("sLOWMODE", f"sLOWMODE sET tO {seconds} sECONDS iN {ctx.channel.mention}!"))
    await ctx.send("Usage: ?slowmode [seconds] - Sets slowmode in the current channel. Only mods/admins can use this.")

@bot.tree.command(name="slowmode", description="Set slowmode in the current channel (admin only)")
@app_commands.describe(seconds="Number of seconds for slowmode")
async def slowmode_slash(interaction: discord.Interaction, seconds: int = 0):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("sLOWMODE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    await interaction.channel.edit(slowmode_delay=seconds)
    await interaction.response.send_message(embed=nova_embed("sLOWMODE", f"sLOWMODE sET tO {seconds} sECONDS iN {interaction.channel.mention}!"), ephemeral=True)
    await interaction.followup.send("Usage: /slowmode [seconds] - Sets slowmode in the current channel. Only mods/admins can use this.", ephemeral=True)

# Economy
@bot.command()
async def pay(ctx, user: discord.Member, amount: int):
    if amount <= 0:
        await ctx.send(embed=nova_embed("pAY", "aMOUNT mUST bE pOSITIVE!"))
        return
    if get_balance(ctx.author.id) < amount:
        await ctx.send(embed=nova_embed("pAY", "nOT eNOUGH dOLLARIANAS!"))
        return
    change_balance(ctx.author.id, -amount)
    change_balance(user.id, amount)
    await ctx.send(embed=nova_embed("pAY", f"{ctx.author.display_name} sENT {amount} {CURRENCY_NAME} tO {user.display_name}!"))

@bot.tree.command(name="pay", description="Send currency to another user")
@app_commands.describe(user="The user to pay", amount="Amount to send")
async def pay_slash(interaction: discord.Interaction, user: discord.Member, amount: int):
    if amount <= 0:
        await interaction.response.send_message(embed=nova_embed("pAY", "aMOUNT mUST bE pOSITIVE!"), ephemeral=True)
        return
    if get_balance(interaction.user.id) < amount:
        await interaction.response.send_message(embed=nova_embed("pAY", "nOT eNOUGH dOLLARIANAS!"), ephemeral=True)
        return
    change_balance(interaction.user.id, -amount)
    change_balance(user.id, amount)
    await interaction.response.send_message(embed=nova_embed("pAY", f"{interaction.user.display_name} sENT {amount} {CURRENCY_NAME} tO {user.display_name}!"))

@bot.command()
async def shop(ctx):
    lines = [f"‚Ä¢ {item} ‚Äî {price} {CURRENCY_NAME}" for item, price in SHOP_ITEMS.items()]
    await ctx.send(embed=nova_embed("üõçÔ∏è nOVA'S sHOP", "\n".join(lines)))

@bot.tree.command(name="shop", description="Show items available to buy")
async def shop_slash(interaction: discord.Interaction):
    lines = [f"‚Ä¢ {item} ‚Äî {price} {CURRENCY_NAME}" for item, price in SHOP_ITEMS.items()]
    await interaction.response.send_message(embed=nova_embed("üõçÔ∏è nOVA'S sHOP", "\n".join(lines)))

@bot.command()
async def buy(ctx, *, item: str):
    item = item.strip().lower()
    matched = next((k for k in SHOP_ITEMS if k.lower() == item), None)
    if not matched:
        await ctx.send(embed=nova_embed("bUY", "iTEM nOT fOUND iN tHE sHOP!"))
        return
    price = SHOP_ITEMS[matched]
    if get_balance(ctx.author.id) < price:
        await ctx.send(embed=nova_embed("bUY", "nOT eNOUGH dOLLARIANAS!"))
        return
    change_balance(ctx.author.id, -price)
    inventory = load_inventory()
    user_inv = inventory.get(str(ctx.author.id), [])
    user_inv.append(matched)
    inventory[str(ctx.author.id)] = user_inv
    save_inventory(inventory)
    await ctx.send(embed=nova_embed("bUY", f"yOU bOUGHT: {matched} fOR {price} {CURRENCY_NAME}!"))

@bot.tree.command(name="buy", description="Purchase an item from the shop")
@app_commands.describe(item="The item to buy")
async def buy_slash(interaction: discord.Interaction, item: str):
    item = item.strip().lower()
    matched = next((k for k in SHOP_ITEMS if k.lower() == item), None)
    if not matched:
        await interaction.response.send_message(embed=nova_embed("bUY", "iTEM nOT fOUND iN tHE sHOP!"), ephemeral=True)
        return
    price = SHOP_ITEMS[matched]
    if get_balance(interaction.user.id) < price:
        await interaction.response.send_message(embed=nova_embed("bUY", "nOT eNOUGH dOLLARIANAS!"), ephemeral=True)
        return
    change_balance(interaction.user.id, -price)
    inventory = load_inventory()
    user_inv = inventory.get(str(interaction.user.id), [])
    user_inv.append(matched)
    inventory[str(interaction.user.id)] = user_inv
    save_inventory(inventory)
    await interaction.response.send_message(embed=nova_embed("bUY", f"yOU bOUGHT: {matched} fOR {price} {CURRENCY_NAME}!"))

@bot.command()
async def inventory(ctx):
    inventory = load_inventory()
    user_inv = inventory.get(str(ctx.author.id), [])
    if not user_inv:
        await ctx.send(embed=nova_embed("iNVENTORY", "yOU dON'T oWN aNY iTEMS!"))
        return
    lines = [f"‚Ä¢ {item}" for item in user_inv]
    await ctx.send(embed=nova_embed("iNVENTORY", "\n".join(lines)))

@bot.tree.command(name="inventory", description="Show items you own")
async def inventory_slash(interaction: discord.Interaction):
    inventory = load_inventory()
    user_inv = inventory.get(str(interaction.user.id), [])
    if not user_inv:
        await interaction.response.send_message(embed=nova_embed("iNVENTORY", "yOU dON'T oWN aNY iTEMS!"), ephemeral=True)
        return
    lines = [f"‚Ä¢ {item}" for item in user_inv]
    await interaction.response.send_message(embed=nova_embed("iNVENTORY", "\n".join(lines)))

# Welcome/Rules
@bot.command()
async def welcome(ctx):
    embed = discord.Embed(
        title="üëã wELCOME tO tHE sERVER!",
        description="i'M nOVA, yOUR fABULOUS bOT. mAKE yOURSELF aT hOME!",
        color=0xff69b4
    )
    embed.set_footer(text="nOVA wELCOMES yOU üíñ")
    await ctx.send(embed=embed)

@bot.command()
async def rules(ctx):
    embed = discord.Embed(
        title="üìú sERVER rULES",
        description="1. bE rESPECTFUL\n2. nO sPAM\n3. sTAY oN tOPIC\n4. nO nSFW\n5. lISTEN tO mODS\n6. hAVE fUN!",
        color=0xff69b4
    )
    embed.set_footer(text="nOVA sAYS: fOLLOW tHE rULES oR eLSE üíÖ")
    await ctx.send(embed=embed)

# Fun
@bot.command()
async def votekick(ctx, user: discord.Member):
    embed = nova_embed("vOTEKICK", f"sHOULD wE kICK {user.mention}?\n‚úÖ = yES, ‚ùå = nO\n(vOTE eNDS iN 15 sECONDS)")
    msg = await ctx.send(embed=embed)
    await msg.add_reaction("‚úÖ")
    await msg.add_reaction("‚ùå")
    await asyncio.sleep(15)
    msg = await ctx.channel.fetch_message(msg.id)
    yes = 0
    no = 0
    for reaction in msg.reactions:
        if str(reaction.emoji) == "‚úÖ":
            yes = reaction.count - 1  # exclude bot
        elif str(reaction.emoji) == "‚ùå":
            no = reaction.count - 1
    if yes > no:
        result = f"{user.mention} wAS (nOT rEALLY) kICKED! "
    else:
        result = f"{user.mention} sTAYS... fOR nOW! "
    await ctx.send(embed=nova_embed("vOTEKICK rESULT", result))

@bot.tree.command(name="votekick", description="Start a fake vote to kick someone (fun only)")
@app_commands.describe(user="The user to (fake) kick")
async def votekick_slash(interaction: discord.Interaction, user: discord.Member):
    embed = nova_embed("vOTEKICK", f"sHOULD wE kICK {user.mention}?\n‚úÖ = yES, ‚ùå = nO\n(vOTE eNDS iN 15 sECONDS)")
    msg = await interaction.channel.send(embed=embed)
    await msg.add_reaction("‚úÖ")
    await msg.add_reaction("‚ùå")
    await interaction.response.send_message(embed=nova_embed("vOTEKICK", f"vOTE sTARTED fOR {user.mention}!"), ephemeral=True)
    await asyncio.sleep(15)
    msg = await interaction.channel.fetch_message(msg.id)
    yes = 0
    no = 0
    for reaction in msg.reactions:
        if str(reaction.emoji) == "‚úÖ":
            yes = reaction.count - 1
        elif str(reaction.emoji) == "‚ùå":
            no = reaction.count - 1
    if yes > no:
        result = f"{user.mention} wAS (nOT rEALLY) kICKED! "
    else:
        result = f"{user.mention} sTAYS... fOR nOW! "
    await interaction.channel.send(embed=nova_embed("vOTEKICK rESULT", result))

@bot.command()
async def explode(ctx):
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the owner can use this command.")
        return
    await ctx.send("üí• Nova is self-destructing... (feature coming soon!)")

# Utility/External
@bot.command()
async def google(ctx, *, query: str):
    await ctx.send("Google search feature coming soon!")

@bot.command()
async def image(ctx, *, query: str):
    await ctx.send("Image search feature coming soon!")

@bot.command()
async def calc(ctx, *, equation: str):
    await ctx.send("Calculator feature coming soon!")

# Timezone/Birthday
@bot.command()
async def timezone(ctx, *, location: str = None):
    await ctx.send("Timezone feature coming soon!")

@bot.command()
async def tz(ctx, *, location: str = None):
    await ctx.send("Timezone shortcut feature coming soon!")

@bot.command()
async def settz(ctx, *, timezone: str):
    await ctx.send("Set timezone feature coming soon!")

@bot.command()
async def settimezone(ctx, *, timezone: str):
    await ctx.send("Set timezone (alias) feature coming soon!")

@bot.command()
async def birthday(ctx, user: discord.Member = None):
    """Show a user's birthday. Usage: ?birthday [@user]"""
    user = user or ctx.author
    birthdays = load_birthdays()
    bday = birthdays.get(str(user.id))
    if bday:
        formatted_bday = format_birthday(bday)
        await ctx.send(embed=nova_embed("üéÇ bIRTHDAY", f"{user.display_name}'s birthday is {formatted_bday}!"))
    else:
        await ctx.send(embed=nova_embed("üéÇ bIRTHDAY", f"No birthday set for {user.display_name}."))

# Alias for birthday command
@bot.command(name="bday")
async def bday(ctx, user: discord.Member = None):
    """Show a user's birthday. Usage: ?bday [@user] (alias for ?birthday)"""
    await birthday(ctx, user)



@bot.command()
async def setbday(ctx, date: str = None):
    """Set your birthday. Usage: ?setbday DD-MM"""
    if date is None:
        await ctx.send(embed=nova_embed("üéÇ sET bIRTHDAY", "Usage: ?setbday DD-MM\n\nExample: ?setbday 15-04 for April 15th\n\nThis will display as: April 15th"))
        return
    
    # Basic validation
    try:
        day, month = map(int, date.split("-"))
        assert 1 <= month <= 12
        assert 1 <= day <= 31
    except Exception:
        await ctx.send(embed=nova_embed("üéÇ sET bIRTHDAY", "Please use the format DD-MM, e.g. 15-04 for April 15th."))
        return
    birthdays = load_birthdays()
    birthdays[str(ctx.author.id)] = date
    save_birthdays(birthdays)
    formatted_date = format_birthday(date)
    await ctx.send(embed=nova_embed("üéÇ sET bIRTHDAY", f"Birthday set to {formatted_date}!"))

# Alias for setbday command
@bot.command(name="setbirthday")
async def setbirthday(ctx, date: str = None):
    """Set your birthday. Usage: ?setbirthday DD-MM (alias for ?setbday)"""
    if date is None:
        await ctx.send(embed=nova_embed("üéÇ sET bIRTHDAY", "Usage: ?setbirthday DD-MM\n\nExample: ?setbirthday 15-04 for April 15th\n\nThis will display as: April 15th"))
        return
    await setbday(ctx, date)



@bot.command()
async def birthdays(ctx):
    """List all birthdays in the server."""
    birthdays = load_birthdays()
    if not birthdays:
        await ctx.send(embed=nova_embed("üéÇ bIRTHDAYS", "No birthdays set yet!"))
        return
    lines = []
    for user_id, date in birthdays.items():
        member = ctx.guild.get_member(int(user_id))
        if member:
            formatted_date = format_birthday(date)
            lines.append(f"{member.display_name}: {formatted_date}")
    if lines:
        await ctx.send(embed=nova_embed("üéÇ sERVER bIRTHDAYS", "\n".join(lines)))
    else:
        await ctx.send(embed=nova_embed("üéÇ bIRTHDAYS", "No birthdays set for current server members."))

# Slash command for birthday
@bot.tree.command(name="birthday", description="Show a user's birthday")
@app_commands.describe(user="The user to check (optional)")
async def birthday_slash(interaction: discord.Interaction, user: discord.Member = None):
    user = user or interaction.user
    birthdays = load_birthdays()
    bday = birthdays.get(str(user.id))
    if bday:
        formatted_bday = format_birthday(bday)
        await interaction.response.send_message(embed=nova_embed("üéÇ bIRTHDAY", f"{user.display_name}'s birthday is {formatted_bday}!"))
    else:
        await interaction.response.send_message(embed=nova_embed("üéÇ bIRTHDAY", f"No birthday set for {user.display_name}."))

# Slash command for setbirthday
@bot.tree.command(name="setbirthday", description="Set your birthday")
@app_commands.describe(date="Your birthday in DD-MM format (e.g. 15-04 for April 15th)")
async def setbirthday_slash(interaction: discord.Interaction, date: str):
    # Basic validation
    try:
        day, month = map(int, date.split("-"))
        assert 1 <= month <= 12
        assert 1 <= day <= 31
    except Exception:
        await interaction.response.send_message(embed=nova_embed("üéÇ sET bIRTHDAY", "Please use the format DD-MM, e.g. 15-04 for April 15th."), ephemeral=True)
        return
    birthdays = load_birthdays()
    birthdays[str(interaction.user.id)] = date
    save_birthdays(birthdays)
    await interaction.response.send_message(embed=nova_embed("üéÇ sET bIRTHDAY", f"Birthday set to {date}!"))

@bot.command()
async def today(ctx):
    """Shows today's international day, Nova style, in a vibrant embed."""
    now = datetime.now()
    key = now.strftime("%d-%m")
    day = INTERNATIONAL_DAYS.get(key)
    if day:
        embed = discord.Embed(
            title="üåç tODAY iS...",
            description=f"**{day}!**",
            color=0xff69b4  # Hot pink for Nova!
        )
        embed.set_footer(text="nOVA bRINGS yOU tHE dAY!")
    else:
        embed = discord.Embed(
            title="nO iNTERNATIONAL dAY tODAY!",
            description="tRY aGAIN tOMORROW bABY ",
            color=0x7289da  # Discord blurple
        )
        embed.set_footer(text="nOVA sAYS: mAYBE nEXT tIME!")
    await ctx.send(embed=embed)

# Confessions/8ball/Therapy
@bot.command()
async def confess(ctx, *, message: str):
    if CONFESS_CHANNEL_ID is None:
        await ctx.send(embed=nova_embed("cONFESSION", "cONFESSION cHANNEL nOT sET! aSK aN aDMIN."))
        return
    try:
        channel = bot.get_channel(CONFESS_CHANNEL_ID)
        if not channel:
            await ctx.send(embed=nova_embed("cONFESSION", "cOULD nOT fIND tHE cONFESSION cHANNEL!"))
            return
        embed = nova_embed("aNONYMOUS cONFESSION", message)
        await channel.send(embed=embed)
        await ctx.author.send(embed=nova_embed("cONFESSION sENT", "yOUR cONFESSION wAS sENT aNONYMOUSLY!"))
        await ctx.send(embed=nova_embed("cONFESSION", "yOUR cONFESSION wAS sENT aNONYMOUSLY! cHECK yOUR dMS."))
    except Exception:
        await ctx.send(embed=nova_embed("cONFESSION", "cOULD nOT sEND cONFESSION!"))

@bot.tree.command(name="confess", description="Send an anonymous confession to a private channel")
@app_commands.describe(message="Your confession")
async def confess_slash(interaction: discord.Interaction, message: str):
    if CONFESS_CHANNEL_ID is None:
        await interaction.response.send_message(embed=nova_embed("cONFESSION", "cONFESSION cHANNEL nOT sET! aSK aN aDMIN."), ephemeral=True)
        return
    try:
        channel = bot.get_channel(CONFESS_CHANNEL_ID)
        if not channel:
            await interaction.response.send_message(embed=nova_embed("cONFESSION", "cOULD nOT fIND tHE cONFESSION cHANNEL!"), ephemeral=True)
            return
        embed = nova_embed("aNONYMOUS cONFESSION", message)
        await channel.send(embed=embed)
        await interaction.user.send(embed=nova_embed("cONFESSION sENT", "yOUR cONFESSION wAS sENT aNONYMOUSLY!"))
        await interaction.response.send_message(embed=nova_embed("cONFESSION", "yOUR cONFESSION wAS sENT aNONYMOUSLY! cHECK yOUR dMS."), ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("cONFESSION", "cOULD nOT sEND cONFESSION!"), ephemeral=True)

@bot.command(name="8ball")
async def _8ball(ctx, *, question: str):
    responses = [
        "yES, dARLING!",
        "nO, sWEETIE!",
        "mAYBE... aSK aGAIN lATER!",
        "aBSOLUTELY!",
        "nOT iN a mILLION yEARS!",
        "oF cOURSE!",
        "i wOULDN'T cOUNT oN iT!",
        "tHE sTARS sAY yES!",
        "mY sOURCES sAY nO!",
        "aSK yOUR mOTHER!",
        "iT iS cERTAIN!",
        "oUTLOOK nOT sO gOOD!",
        "yOU aLREADY kNOW tHE aNSWER!",
        "dON'T bET oN iT!",
        "sLAY, bUT nO!"
    ]
    answer = random.choice(responses)
    embed = nova_embed("üé± 8bALL", f"qUESTION: {question}\n**aNSWER:** {answer}")
    await ctx.send(embed=embed)

@bot.tree.command(name="8ball", description="Ask Nova the magic 8ball!")
@app_commands.describe(question="Your question for the 8ball")
async def _8ball_slash(interaction: discord.Interaction, question: str):
    responses = [
        "yES, dARLING!",
        "nO, sWEETIE!",
        "mAYBE... aSK aGAIN lATER!",
        "aBSOLUTELY!",
        "nOT iN a mILLION yEARS!",
        "oF cOURSE!",
        "i wOULDN'T cOUNT oN iT!",
        "tHE sTARS sAY yES!",
        "mY sOURCES sAY nO!",
        "aSK yOUR mOTHER!",
        "iT iS cERTAIN!",
        "oUTLOOK nOT sO gOOD!",
        "yOU aLREADY kNOW tHE aNSWER!",
        "dON'T bET oN iT!",
        "sLAY, bUT nO!"
    ]
    answer = random.choice(responses)
    embed = nova_embed("üé± 8bALL", f"qUESTION: {question}\n**aNSWER:** {answer}")
    await interaction.response.send_message(embed=embed)

@bot.command()
async def mood(ctx):
    moods = [
        "fEELING fANTABULOUS ",
        "i'M iN a cUNT mOOD ",
        "dRAMATIC tODAY ",
        "cHAOTIC eNERGY ",
        "lOVING tHE vIBE ",
        "cHILE...",
        "bORED... ",
        "rEADY tO mOTHER üëë",
        "cAFFEINATED aND dANGEROUS ",
        "i'M yOUR bESTIE tODAY..."
    ]
    mood = random.choice(moods)
    await ctx.send(embed=nova_embed("nOVA'S mOOD", mood))

@bot.tree.command(name="mood", description="Show Nova's current mood!")
async def mood_slash(interaction: discord.Interaction):
    moods = [
        "fEELING fANTABULOUS ",
        "i'M iN a cUNT mOOD ",
        "dRAMATIC tODAY ",
        "cHAOTIC eNERGY ",
        "lOVING tHE vIBE ",
        "cHILE...",
        "bORED... ",
        "rEADY tO mOTHER üëë",
        "cAFFEINATED aND dANGEROUS ",
        "i'M yOUR bESTIE tODAY..."
    ]
    mood = random.choice(moods)
    await interaction.response.send_message(embed=nova_embed("nOVA'S mOOD", mood))

@bot.command()
async def remindme(ctx, time: str, *, message: str):
    seconds = parse_time(time)
    if seconds is None or seconds <= 0:
        await ctx.send(embed=nova_embed("rEMINDER", "iNVALID tIME! uSE s, m, h, oR d (e.g. 10m, 2h)"))
        return
    reminders = load_reminders()
    user_reminders = reminders.get(str(ctx.author.id), {})
    reminder_id = str(len(user_reminders) + 1)
    user_reminders[reminder_id] = {"message": message, "time": int(asyncio.get_event_loop().time()) + seconds}
    reminders[str(ctx.author.id)] = user_reminders
    save_reminders(reminders)
    await ctx.send(embed=nova_embed("rEMINDER sET", f"i'LL rEMIND yOU iN {time}: {message}"))
    bot.loop.create_task(reminder_task(ctx.author.id, reminder_id, seconds, message))

@bot.tree.command(name="remindme", description="Set a reminder to ping you later")
@app_commands.describe(time="Time (e.g. 10m, 2h, 1d)", message="Reminder message")
async def remindme_slash(interaction: discord.Interaction, time: str, message: str):
    seconds = parse_time(time)
    if seconds is None or seconds <= 0:
        await interaction.response.send_message(embed=nova_embed("rEMINDER", "iNVALID tIME! uSE s, m, h, oR d (e.g. 10m, 2h)"), ephemeral=True)
        return
    reminders = load_reminders()
    user_reminders = reminders.get(str(interaction.user.id), {})
    reminder_id = str(len(user_reminders) + 1)
    user_reminders[reminder_id] = {"message": message, "time": int(asyncio.get_event_loop().time()) + seconds}
    reminders[str(interaction.user.id)] = user_reminders
    save_reminders(reminders)
    await interaction.response.send_message(embed=nova_embed("rEMINDER sET", f"i'LL rEMIND yOU iN {time}: {message}"), ephemeral=True)
    bot.loop.create_task(reminder_task(interaction.user.id, reminder_id, seconds, message))

@bot.command()
async def reminderlist(ctx):
    reminders = load_reminders()
    user_reminders = reminders.get(str(ctx.author.id), {})
    if not user_reminders:
        await ctx.send(embed=nova_embed("rEMINDERS", "nO aCTIVE rEMINDERS!"))
        return
    lines = []
    now = int(asyncio.get_event_loop().time())
    for rid, data in user_reminders.items():
        left = max(0, data["time"] - now)
        mins, secs = divmod(left, 60)
        hours, mins = divmod(mins, 60)
        if hours:
            tstr = f"{int(hours)}h {int(mins)}m"
        elif mins:
            tstr = f"{int(mins)}m {int(secs)}s"
        else:
            tstr = f"{int(secs)}s"
        lines.append(f"‚Ä¢ {data['message']} (in {tstr})")
    await ctx.send(embed=nova_embed("yOUR rEMINDERS", "\n".join(lines)))

@bot.tree.command(name="reminderlist", description="List your active reminders")
async def reminderlist_slash(interaction: discord.Interaction):
    reminders = load_reminders()
    user_reminders = reminders.get(str(interaction.user.id), {})
    if not user_reminders:
        await interaction.response.send_message(embed=nova_embed("rEMINDERS", "nO aCTIVE rEMINDERS!"), ephemeral=True)
        return
    lines = []
    now = int(asyncio.get_event_loop().time())
    for rid, data in user_reminders.items():
        left = max(0, data["time"] - now)
        mins, secs = divmod(left, 60)
        hours, mins = divmod(mins, 60)
        if hours:
            tstr = f"{int(hours)}h {int(mins)}m"
        elif mins:
            tstr = f"{int(mins)}m {int(secs)}s"
        else:
            tstr = f"{int(secs)}s"
        lines.append(f"‚Ä¢ {data['message']} (in {tstr})")
    await interaction.response.send_message(embed=nova_embed("yOUR rEMINDERS", "\n".join(lines)), ephemeral=True)

# Translate/Weather/Avatar/Fact
@bot.command()
async def translate(ctx, language: str, *, text: str):
    await ctx.send("Translate feature coming soon!")

@bot.command()
async def weather(ctx, *, city: str):
    await ctx.send("Weather feature coming soon!")

@bot.command()
async def avatar(ctx, user: discord.Member = None):
    user = user or ctx.author
    embed = nova_embed(
        title=f"{user.display_name}'s aVATAR",
        description=f"hERE'S tHE aVATAR fOR {user.mention}",
        color=0xff69b4
    )
    embed.set_image(url=user.display_avatar.url)
    await ctx.send(embed=embed)

@bot.tree.command(name="avatar", description="Show the avatar of a user")
async def avatar_slash(interaction: discord.Interaction, user: discord.Member = None):
    user = user or interaction.user
    embed = nova_embed(
        title=f"{user.display_name}'s aVATAR",
        description=f"hERE'S tHE aVATAR fOR {user.mention}",
        color=0xff69b4
    )
    embed.set_image(url=user.display_avatar.url)
    await interaction.response.send_message(embed=embed)

@bot.command()
async def fact(ctx):
    await ctx.send("Fact feature coming soon!")

# Lyrics/Nick/Jail/Autoplay
@bot.command()
async def lyrics(ctx, *, query: str):
    await ctx.send("Lyrics feature coming soon!")

@bot.command()
async def nick(ctx, user: discord.Member, *, nickname: str):
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    await ctx.send("Nick feature coming soon!")

JAIL_CHANNEL_ID = None  # Set this to your jail channel ID (int)

@bot.command()
async def setjail(ctx, channel: discord.TextChannel):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET jAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    global JAIL_CHANNEL_ID
    JAIL_CHANNEL_ID = channel.id
    await ctx.send(embed=nova_embed("sET jAIL", f"jAIL cHANNEL sET tO {channel.mention}"))

@bot.tree.command(name="setjail", description="Set the jail channel (admin/mod only)")
@app_commands.describe(channel="The channel to use as jail")
async def setjail_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("sET jAIL", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    global JAIL_CHANNEL_ID
    JAIL_CHANNEL_ID = channel.id
    await interaction.response.send_message(embed=nova_embed("sET jAIL", f"jAIL cHANNEL sET tO {channel.mention}"), ephemeral=True)

@bot.command()
async def setrunway(ctx, channel: discord.TextChannel):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET rUNWAY", "yOU dON'T hAVE pERMISSION!"))
        return
    global RUNWAY_CHANNEL_ID
    RUNWAY_CHANNEL_ID = channel.id
    save_config()
    await ctx.send(embed=nova_embed("sET rUNWAY", f"rUNWAY cHANNEL sET tO {channel.mention}!"))

@bot.tree.command(name="setrunway", description="Set the runway channel (admin/mod only)")
@app_commands.describe(channel="The channel to use as runway")
async def setrunway_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("sET rUNWAY", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    global RUNWAY_CHANNEL_ID
    RUNWAY_CHANNEL_ID = channel.id
    save_config()
    await interaction.response.send_message(embed=nova_embed("sET rUNWAY", f"rUNWAY cHANNEL sET tO {channel.mention}!"), ephemeral=True)

@bot.command()
async def fixinmate(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("fIX iNMATE", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        inmate_role = discord.utils.get(ctx.guild.roles, name="iNMATE")
        if not inmate_role:
            await ctx.send(embed=nova_embed("fIX iNMATE", "iNMATE rOLE dOES nOT eXIST!"))
            return
        
        # Force update permissions for all channels
        updated_channels = 0
        for channel in ctx.guild.channels:
            if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                try:
                    await channel.set_permissions(inmate_role, 
                        send_messages=False, 
                        speak=False, 
                        add_reactions=False,
                        create_public_threads=False,
                        create_private_threads=False,
                        send_messages_in_threads=False,
                        view_channel=True,
                        read_message_history=True
                    )
                    updated_channels += 1
                except discord.Forbidden:
                    continue
        
        await ctx.send(embed=nova_embed("fIX iNMATE", f"uPDATED pERMISSIONS fOR {updated_channels} cHANNELS!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("fIX iNMATE", f"eRROR: {str(e)}"))

@bot.tree.command(name="fixinmate", description="Fix inmate role permissions for all channels (admin/mod only)")
async def fixinmate_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("fIX iNMATE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        inmate_role = discord.utils.get(interaction.guild.roles, name="iNMATE")
        if not inmate_role:
            await interaction.response.send_message(embed=nova_embed("fIX iNMATE", "iNMATE rOLE dOES nOT eXIST!"), ephemeral=True)
            return
        
        # Force update permissions for all channels
        updated_channels = 0
        for channel in interaction.guild.channels:
            if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                try:
                    await channel.set_permissions(inmate_role, 
                        send_messages=False, 
                        speak=False, 
                        add_reactions=False,
                        create_public_threads=False,
                        create_private_threads=False,
                        send_messages_in_threads=False,
                        view_channel=True,
                        read_message_history=True
                    )
                    updated_channels += 1
                except discord.Forbidden:
                    continue
        
        await interaction.response.send_message(embed=nova_embed("fIX iNMATE", f"uPDATED pERMISSIONS fOR {updated_channels} cHANNELS!"), ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("fIX iNMATE", f"eRROR: {str(e)}"), ephemeral=True)

@bot.command()
async def jail(ctx, user: discord.Member):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("jAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    if JAIL_CHANNEL_ID is None:
        await ctx.send(embed=nova_embed("jAIL", "jAIL cHANNEL nOT sET!"))
        return
    try:
        jail_channel = ctx.guild.get_channel(JAIL_CHANNEL_ID)
        if not jail_channel:
            await ctx.send(embed=nova_embed("jAIL", "cOULD nOT fIND tHE jAIL cHANNEL!"))
            return
        
        # Create or get inmate role
        inmate_role = discord.utils.get(ctx.guild.roles, name="iNMATE")
        if not inmate_role:
            try:
                inmate_role = await ctx.guild.create_role(
                    name="iNMATE",
                    color=discord.Color.dark_red(),
                    reason="Jail system role"
                )
                # Set permissions for all channels
                for channel in ctx.guild.channels:
                    if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                        try:
                            await channel.set_permissions(inmate_role, 
                                send_messages=False, 
                                speak=False, 
                                add_reactions=False,
                                create_public_threads=False,
                                create_private_threads=False,
                                send_messages_in_threads=False,
                                view_channel=True,
                                read_message_history=True
                            )
                        except discord.Forbidden:
                            continue  # Skip channels we can't modify
            except discord.Forbidden:
                await ctx.send(embed=nova_embed("jAIL", "cAN'T cREATE iNMATE rOLE - nO pERMISSION!"))
                return
        else:
            # If role exists, make sure permissions are set correctly
            for channel in ctx.guild.channels:
                if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                    try:
                        await channel.set_permissions(inmate_role, 
                            send_messages=False, 
                            speak=False, 
                            add_reactions=False,
                            create_public_threads=False,
                            create_private_threads=False,
                            send_messages_in_threads=False,
                            view_channel=True,
                            read_message_history=True
                        )
                    except discord.Forbidden:
                        continue  # Skip channels we can't modify
        
        # Add inmate role to user
        if inmate_role not in user.roles:
            await user.add_roles(inmate_role, reason="Jailed by Nova")
        
        # Try to move user to jail channel if they're in voice
        if user.voice:
            try:
                await user.move_to(jail_channel)
            except discord.Forbidden:
                pass  # Don't fail if we can't move them
            except Exception:
                pass  # Don't fail if we can't move them
        
        await ctx.send(embed=nova_embed("jAIL", f"{user.mention} hAS bEEN jAILED! tHEY cAN'T tALK aNYWHERE nOW!"))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("jAIL", "nO pERMISSION tO mANAGE rOLES oR cHANNELS!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("jAIL", f"eRROR: {str(e)}"))

@bot.tree.command(name="jail", description="Move a user to the jail channel and restrict permissions (admin/mod only)")
@app_commands.describe(user="The user to jail")
async def jail_slash(interaction: discord.Interaction, user: discord.Member):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("jAIL", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    if JAIL_CHANNEL_ID is None:
        await interaction.response.send_message(embed=nova_embed("jAIL", "jAIL cHANNEL nOT sET!"), ephemeral=True)
        return
    try:
        jail_channel = interaction.guild.get_channel(JAIL_CHANNEL_ID)
        if not jail_channel:
            await interaction.response.send_message(embed=nova_embed("jAIL", "cOULD nOT fIND tHE jAIL cHANNEL!"), ephemeral=True)
            return
        
        # Create or get inmate role
        inmate_role = discord.utils.get(interaction.guild.roles, name="iNMATE")
        if not inmate_role:
            try:
                inmate_role = await interaction.guild.create_role(
                    name="iNMATE",
                    color=discord.Color.dark_red(),
                    reason="Jail system role"
                )
                # Set permissions for all channels
                for channel in interaction.guild.channels:
                    if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                        try:
                            await channel.set_permissions(inmate_role, 
                                send_messages=False, 
                                speak=False, 
                                add_reactions=False,
                                create_public_threads=False,
                                create_private_threads=False,
                                send_messages_in_threads=False,
                                view_channel=True,
                                read_message_history=True
                            )
                        except discord.Forbidden:
                            continue  # Skip channels we can't modify
            except discord.Forbidden:
                await interaction.response.send_message(embed=nova_embed("jAIL", "cAN'T cREATE iNMATE rOLE - nO pERMISSION!"), ephemeral=True)
                return
        else:
            # If role exists, make sure permissions are set correctly
            for channel in interaction.guild.channels:
                if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                    try:
                        await channel.set_permissions(inmate_role, 
                            send_messages=False, 
                            speak=False, 
                            add_reactions=False,
                            create_public_threads=False,
                            create_private_threads=False,
                            send_messages_in_threads=False,
                            view_channel=True,
                            read_message_history=True
                        )
                    except discord.Forbidden:
                        continue  # Skip channels we can't modify
        
        # Add inmate role to user
        if inmate_role not in user.roles:
            await user.add_roles(inmate_role, reason="Jailed by Nova")
        
        # Try to move user to jail channel if they're in voice
        if user.voice:
            try:
                await user.move_to(jail_channel)
            except discord.Forbidden:
                pass  # Don't fail if we can't move them
            except Exception:
                pass  # Don't fail if we can't move them
        
        await interaction.response.send_message(embed=nova_embed("jAIL", f"{user.mention} hAS bEEN jAILED! tHEY cAN'T tALK aNYWHERE nOW!"))
    except discord.Forbidden:
        await interaction.response.send_message(embed=nova_embed("jAIL", "nO pERMISSION tO mANAGE rOLES oR cHANNELS!"), ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("jAIL", f"eRROR: {str(e)}"), ephemeral=True)

@bot.command()
async def runway(ctx, message_id: int = None):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("rUNWAY", "yOU dON'T hAVE pERMISSION!"))
        return
    if RUNWAY_CHANNEL_ID is None:
        await ctx.send(embed=nova_embed("rUNWAY", "rUNWAY cHANNEL nOT sET!"))
        return
    
    # Get the message to transfer
    if message_id:
        try:
            message = await ctx.channel.fetch_message(message_id)
        except discord.NotFound:
            await ctx.send(embed=nova_embed("rUNWAY", "mESSAGE nOT fOUND!"))
            return
        except discord.Forbidden:
            await ctx.send(embed=nova_embed("rUNWAY", "cAN'T aCCESS tHAT mESSAGE!"))
            return
    else:
        # Get the last message in the channel
        async for message in ctx.channel.history(limit=1):
            break
        else:
            await ctx.send(embed=nova_embed("rUNWAY", "nO mESSAGES tO tRANSFER!"))
            return
    
    try:
        runway_channel = ctx.guild.get_channel(RUNWAY_CHANNEL_ID)
        if not runway_channel:
            await ctx.send(embed=nova_embed("rUNWAY", "cOULD nOT fIND tHE rUNWAY cHANNEL!"))
            return
        
        # Create runway embed with crying emoji and message number
        embed = nova_embed("üò¢ #" + str(message.id), message.content)
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
        embed.add_field(name="oRIGINAL cHANNEL", value=ctx.channel.mention, inline=True)
        embed.set_footer(text=f"Message ID: {message.id}")
        
        # Send attachments separately if any
        files = []
        for attachment in message.attachments:
            try:
                file_data = await attachment.read()
                files.append(discord.File(io.BytesIO(file_data), filename=attachment.filename))
            except Exception:
                continue
        
        await runway_channel.send(embed=embed, files=files)
        await ctx.send(embed=nova_embed("rUNWAY", f"mESSAGE tRANSFERRED tO {runway_channel.mention}!"))
        
    except Exception as e:
        await ctx.send(embed=nova_embed("rUNWAY", f"eRROR: {str(e)}"))

@bot.tree.command(name="runway", description="Transfer a message to the runway channel (admin/mod only)")
@app_commands.describe(message_id="ID of the message to transfer (optional - uses last message)")
async def runway_slash(interaction: discord.Interaction, message_id: int = None):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("rUNWAY", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    if RUNWAY_CHANNEL_ID is None:
        await interaction.response.send_message(embed=nova_embed("rUNWAY", "rUNWAY cHANNEL nOT sET!"), ephemeral=True)
        return
    
    # Get the message to transfer
    if message_id:
        try:
            message = await interaction.channel.fetch_message(message_id)
        except discord.NotFound:
            await interaction.response.send_message(embed=nova_embed("rUNWAY", "mESSAGE nOT fOUND!"), ephemeral=True)
            return
        except discord.Forbidden:
            await interaction.response.send_message(embed=nova_embed("rUNWAY", "cAN'T aCCESS tHAT mESSAGE!"), ephemeral=True)
            return
    else:
        # Get the last message in the channel
        async for message in interaction.channel.history(limit=1):
            break
        else:
            await interaction.response.send_message(embed=nova_embed("rUNWAY", "nO mESSAGES tO tRANSFER!"), ephemeral=True)
            return
    
    try:
        runway_channel = interaction.guild.get_channel(RUNWAY_CHANNEL_ID)
        if not runway_channel:
            await interaction.response.send_message(embed=nova_embed("rUNWAY", "cOULD nOT fIND tHE rUNWAY cHANNEL!"), ephemeral=True)
            return
        
        # Create runway embed with crying emoji and message number
        embed = nova_embed("üò¢ #" + str(message.id), message.content)
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
        embed.add_field(name="oRIGINAL cHANNEL", value=interaction.channel.mention, inline=True)
        embed.set_footer(text=f"Message ID: {message.id}")
        
        # Send attachments separately if any
        files = []
        for attachment in message.attachments:
            try:
                file_data = await attachment.read()
                files.append(discord.File(io.BytesIO(file_data), filename=attachment.filename))
            except Exception:
                continue
        
        await runway_channel.send(embed=embed, files=files)
        await interaction.response.send_message(embed=nova_embed("rUNWAY", f"mESSAGE tRANSFERRED tO {runway_channel.mention}!"), ephemeral=True)
        
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("rUNWAY", f"eRROR: {str(e)}"), ephemeral=True)

@bot.command()
async def setautoplay(ctx, channel: discord.VoiceChannel):
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    await ctx.send("Set autoplay channel feature coming soon!")

@bot.command()
async def playlistshow(ctx):
    await ctx.send("Playlist show feature coming soon!")

@bot.command()
async def chatgpt(ctx, *, prompt: str):
    """Talk to ChatGPT!"""
    await ctx.send("ChatGPT feature coming soon!")

@bot.command()
async def generate(ctx, *, prompt: str):
    """Generate creative content with ChatGPT."""
    await ctx.send("Generate feature coming soon!")

# Helper functions for relationships

def load_relationships():
    try:
        with open(RELATIONSHIPS_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_relationships(relationships):
    with open(RELATIONSHIPS_FILE, "w") as f:
        json.dump(relationships, f)

def load_reminders():
    try:
        with open(REMINDERS_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_reminders(reminders):
    with open(REMINDERS_FILE, "w") as f:
        json.dump(reminders, f)

def parse_time(timestr):
    match = re.match(r"(\d+)([smhd])", timestr.lower())
    if not match:
        return None
    num, unit = int(match.group(1)), match.group(2)
    if unit == 's': return num
    if unit == 'm': return num * 60
    if unit == 'h': return num * 3600
    if unit == 'd': return num * 86400
    return None

async def reminder_task(user_id, reminder_id, seconds, message):
    await asyncio.sleep(seconds)
    user = await bot.fetch_user(int(user_id))
    embed = nova_embed("rEMINDER!", f"‚è∞ {message}")
    try:
        await user.send(embed=embed)
    except Exception:
        pass
    reminders = load_reminders()
    user_reminders = reminders.get(str(user_id), {})
    if reminder_id in user_reminders:
        del user_reminders[reminder_id]
        reminders[str(user_id)] = user_reminders
        save_reminders(reminders)

CONFESS_CHANNEL_ID = 1391874227774165132

@bot.command()
async def unjail(ctx, user: discord.Member):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("uNJAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        # Remove inmate role
        inmate_role = discord.utils.get(ctx.guild.roles, name="iNMATE")
        if inmate_role and inmate_role in user.roles:
            await user.remove_roles(inmate_role, reason="Unjailed by Nova")
            await ctx.send(embed=nova_embed("uNJAIL", f"{user.mention} hAS bEEN uNJAILed!"))
        else:
            await ctx.send(embed=nova_embed("uNJAIL", f"{user.mention} iS nOT jAILED!"))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("uNJAIL", "nO pERMISSION tO mANAGE rOLES!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("uNJAIL", f"eRROR: {str(e)}"))

@bot.tree.command(name="unjail", description="Remove a user from jail (admin/mod only)")
@app_commands.describe(user="The user to unjail")
async def unjail_slash(interaction: discord.Interaction, user: discord.Member):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("uNJAIL", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        # Remove inmate role
        inmate_role = discord.utils.get(interaction.guild.roles, name="iNMATE")
        if inmate_role and inmate_role in user.roles:
            await user.remove_roles(inmate_role, reason="Unjailed by Nova")
            await interaction.response.send_message(embed=nova_embed("uNJAIL", f"{user.mention} hAS bEEN uNJAILed!"))
        else:
            await interaction.response.send_message(embed=nova_embed("uNJAIL", f"{user.mention} iS nOT jAILED!"), ephemeral=True)
    except discord.Forbidden:
        await interaction.response.send_message(embed=nova_embed("uNJAIL", "nO pERMISSION tO mANAGE rOLES!"), ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("uNJAIL", f"eRROR: {str(e)}"), ephemeral=True)

SHOP_ITEMS = {
    "cUSTOM rOLE": 5000,
    "xP bOOST": 2000,
    "sHOUTOUT": 2000,
    "pROMOTE yOURSELF": 5000,
    "rING a uSER": 2000,
    "cUSTOMIZE nOVA'S bIO (24h)": 10000
}
INVENTORY_FILE = "inventory.json"

def load_inventory():
    try:
        with open(INVENTORY_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_inventory(inventory):
    with open(INVENTORY_FILE, "w") as f:
        json.dump(inventory, f)

def load_thrift():
    try:
        with open(THRIFT_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def save_thrift(thrift):
    with open(THRIFT_FILE, "w") as f:
        json.dump(thrift, f)

@bot.command()
async def sell(ctx, item: str, price: int):
    item = item.strip()
    if price <= 0:
        await ctx.send(embed=nova_embed("sELL", "pRICE mUST bE pOSITIVE!"))
        return
    inventory = load_inventory()
    user_inv = inventory.get(str(ctx.author.id), [])
    matched = next((i for i in user_inv if i.lower() == item.lower()), None)
    if not matched:
        await ctx.send(embed=nova_embed("sELL", "yOU dON'T oWN tHAT iTEM!"))
        return
    user_inv.remove(matched)
    inventory[str(ctx.author.id)] = user_inv
    save_inventory(inventory)
    thrift = load_thrift()
    thrift.append({"item": matched, "price": price, "seller": ctx.author.id})
    save_thrift(thrift)
    await ctx.send(embed=nova_embed("sELL", f"yOU lISTED {matched} fOR sALE aT {price} {CURRENCY_NAME} iN tHE tHRIFT sTORE!"))

@bot.tree.command(name="sell", description="Sell an item from your inventory at a custom price")
@app_commands.describe(item="The item to sell", price="Sale price")
async def sell_slash(interaction: discord.Interaction, item: str, price: int):
    item = item.strip()
    if price <= 0:
        await interaction.response.send_message(embed=nova_embed("sELL", "pRICE mUST bE pOSITIVE!"), ephemeral=True)
        return
    inventory = load_inventory()
    user_inv = inventory.get(str(interaction.user.id), [])
    matched = next((i for i in user_inv if i.lower() == item.lower()), None)
    if not matched:
        await interaction.response.send_message(embed=nova_embed("sELL", "yOU dON'T oWN tHAT iTEM!"), ephemeral=True)
        return
    user_inv.remove(matched)
    inventory[str(interaction.user.id)] = user_inv
    save_inventory(inventory)
    thrift = load_thrift()
    thrift.append({"item": matched, "price": price, "seller": interaction.user.id})
    save_thrift(thrift)
    await interaction.response.send_message(embed=nova_embed("sELL", f"yOU lISTED {matched} fOR sALE aT {price} {CURRENCY_NAME} iN tHE tHRIFT sTORE!"))

@bot.command()
async def thrift(ctx):
    thrift = load_thrift()
    if not thrift:
        await ctx.send(embed=nova_embed("tHRIFT sTORE", "nO iTEMS fOR sALE rIGHT nOW!"))
        return
    lines = []
    for idx, entry in enumerate(thrift, 1):
        seller = ctx.guild.get_member(entry["seller"])
        seller_name = seller.display_name if seller else f"<@{entry['seller']}>"
        lines.append(f"{idx}. {entry['item']} ‚Äî {entry['price']} {CURRENCY_NAME} (by {seller_name})")
    await ctx.send(embed=nova_embed("tHRIFT sTORE", "\n".join(lines)))

@bot.tree.command(name="thrift", description="Show the thrift store (member sales)")
async def thrift_slash(interaction: discord.Interaction):
    thrift = load_thrift()
    if not thrift:
        await interaction.response.send_message(embed=nova_embed("tHRIFT sTORE", "nO iTEMS fOR sALE rIGHT nOW!"), ephemeral=True)
        return
    lines = []
    for idx, entry in enumerate(thrift, 1):
        seller = interaction.guild.get_member(entry["seller"])
        seller_name = seller.display_name if seller else f"<@{entry['seller']}>"
        lines.append(f"{idx}. {entry['item']} ‚Äî {entry['price']} {CURRENCY_NAME} (by {seller_name})")
    await interaction.response.send_message(embed=nova_embed("tHRIFT sTORE", "\n".join(lines)))

@bot.command()
async def buythrift(ctx, idx: int):
    thrift = load_thrift()
    if idx < 1 or idx > len(thrift):
        await ctx.send(embed=nova_embed("bUY tHRIFT", "iNVALID iTEM nUMBER!"))
        return
    entry = thrift[idx-1]
    if get_balance(ctx.author.id) < entry["price"]:
        await ctx.send(embed=nova_embed("bUY tHRIFT", "nOT eNOUGH dOLLARIANAS!"))
        return
    if entry["seller"] == ctx.author.id:
        await ctx.send(embed=nova_embed("bUY tHRIFT", "yOU cAN'T bUY yOUR oWN iTEM!"))
        return
    change_balance(ctx.author.id, -entry["price"])
    change_balance(entry["seller"], entry["price"])
    inventory = load_inventory()
    user_inv = inventory.get(str(ctx.author.id), [])
    user_inv.append(entry["item"])
    inventory[str(ctx.author.id)] = user_inv
    save_inventory(inventory)
    del thrift[idx-1]
    save_thrift(thrift)
    await ctx.send(embed=nova_embed("bUY tHRIFT", f"yOU bOUGHT {entry['item']} fOR {entry['price']} {CURRENCY_NAME}!"))

@bot.tree.command(name="buythrift", description="Buy an item from the thrift store")
@app_commands.describe(idx="The item number from /thrift")
async def buythrift_slash(interaction: discord.Interaction, idx: int):
    thrift = load_thrift()
    if idx < 1 or idx > len(thrift):
        await interaction.response.send_message(embed=nova_embed("bUY tHRIFT", "iNVALID iTEM nUMBER!"), ephemeral=True)
        return
    entry = thrift[idx-1]
    if get_balance(interaction.user.id) < entry["price"]:
        await interaction.response.send_message(embed=nova_embed("bUY tHRIFT", "nOT eNOUGH dOLLARIANAS!"), ephemeral=True)
        return
    if entry["seller"] == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("bUY tHRIFT", "yOU cAN'T bUY yOUR oWN iTEM!"), ephemeral=True)
        return
    change_balance(interaction.user.id, -entry["price"])
    change_balance(entry["seller"], entry["price"])
    inventory = load_inventory()
    user_inv = inventory.get(str(interaction.user.id), [])
    user_inv.append(entry["item"])
    inventory[str(interaction.user.id)] = user_inv
    save_inventory(inventory)
    del thrift[idx-1]
    save_thrift(thrift)
    await interaction.response.send_message(embed=nova_embed("bUY tHRIFT", f"yOU bOUGHT {entry['item']} fOR {entry['price']} {CURRENCY_NAME}!"))

# Store last deleted and edited messages per channel
snipes = {}
edsnipes = {}
rsnipes = {}  # channel_id: {'emoji': str, 'user': str, 'message_id': int, 'jump_url': str, 'time': datetime}

@bot.event
async def on_message_delete(message):
    if message.author.bot:
        return
    
    # Store for snipe command
    snipes[message.channel.id] = {
        'content': message.content,
        'author': str(message.author),
        'time': message.created_at
    }
    
    # Chat logs for mods - Enhanced debugging
    print(f"DEBUG: Message deleted by {message.author} in {message.channel}")
    print(f"DEBUG: CHAT_LOGS_CHANNEL_ID = {CHAT_LOGS_CHANNEL_ID}")
    
    if CHAT_LOGS_CHANNEL_ID:
        guild = message.guild
        print(f"DEBUG: Guild = {guild}")
        if guild:
            log_channel = guild.get_channel(CHAT_LOGS_CHANNEL_ID)
            print(f"DEBUG: Log channel = {log_channel}")
            if log_channel:
                try:
                    content = message.content if message.content else "*[No text content]*"
                    embed = nova_embed("üóëÔ∏è mESSAGE dELETED", f"**Author:** {message.author}\n**Channel:** {message.channel.mention}\n**Message ID:** {message.id}\n**Content:** {content}")
                    embed.timestamp = datetime.now(dt_timezone.utc)
                    await log_channel.send(embed=embed)
                    print(f"DEBUG: Chat log sent successfully to {log_channel.name}")
                except Exception as e:
                    print(f"ERROR: Failed to send chat log: {e}")
                    import traceback
                    traceback.print_exc()
            else:
                print(f"ERROR: Chat logs channel not found with ID: {CHAT_LOGS_CHANNEL_ID}")
        else:
            print("ERROR: Guild not found for message deletion")
    else:
        print("DEBUG: CHAT_LOGS_CHANNEL_ID is None - chat logs disabled")

@bot.event
async def on_message_edit(before, after):
    if before.author.bot or before.content == after.content:
        return
    
    # Chat logs for message edits - Enhanced debugging
    print(f"DEBUG: Message edited by {before.author} in {before.channel}")
    print(f"DEBUG: CHAT_LOGS_CHANNEL_ID = {CHAT_LOGS_CHANNEL_ID}")
    
    if CHAT_LOGS_CHANNEL_ID:
        guild = before.guild
        print(f"DEBUG: Guild = {guild}")
        if guild:
            log_channel = guild.get_channel(CHAT_LOGS_CHANNEL_ID)
            print(f"DEBUG: Log channel = {log_channel}")
            if log_channel:
                try:
                    before_content = before.content if before.content else "*[No text content]*"
                    after_content = after.content if after.content else "*[No text content]*"
                    
                    embed = nova_embed(
                        "‚úèÔ∏è mESSAGE eDITED", 
                        f"**Author:** {before.author}\n**Channel:** {before.channel.mention}\n**Message ID:** {before.id}"
                    )
                    embed.add_field(name="Before", value=f"```{before_content[:1000]}```", inline=False)
                    embed.add_field(name="After", value=f"```{after_content[:1000]}```", inline=False)
                    embed.add_field(name="Jump to Message", value=f"[Click here]({after.jump_url})", inline=False)
                    embed.timestamp = datetime.now(dt_timezone.utc)
                    embed.color = 0xffcc00  # Yellow for edits
                    
                    await log_channel.send(embed=embed)
                    print(f"DEBUG: Edit log sent successfully to {log_channel.name}")
                except Exception as e:
                    print(f"ERROR: Failed to send edit log: {e}")
                    import traceback
                    traceback.print_exc()
            else:
                print(f"ERROR: Chat logs channel not found with ID: {CHAT_LOGS_CHANNEL_ID}")
        else:
            print("ERROR: Guild not found for message edit")
    else:
        print("DEBUG: CHAT_LOGS_CHANNEL_ID is None - chat logs disabled")
    
    # Store for edsnipe command
    edsnipes[before.channel.id] = {
        'content': before.content,
        'author': str(before.author),
        'time': before.edited_at or before.created_at
    }

@bot.event
async def on_raw_reaction_remove(payload):
    # Store the last removed reaction for rsnipe
    if payload.guild_id is None:
        return
    channel = bot.get_channel(payload.channel_id)
    if channel is None:
        return
    user = None
    guild = bot.get_guild(payload.guild_id)
    if guild:
        user = guild.get_member(payload.user_id)
    if user is None or user.bot:
        return
    try:
        message = await channel.fetch_message(payload.message_id)
    except Exception:
        message = None
    jump_url = message.jump_url if message else None
    rsnipes[payload.channel_id] = {
        'emoji': str(payload.emoji),
        'user': str(user),
        'message_id': payload.message_id,
        'jump_url': jump_url,
        'time': datetime.now(datetime.timezone.utc)
    }

@bot.command()
async def rsnipe(ctx):
    print(f"DEBUG: RSnipe command called by {ctx.author} in {ctx.channel}")
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("rSNIPE", "yOU dON'T hAVE pERMISSION!"))
        return
    
    print(f"DEBUG: Checking rsnipes for channel {ctx.channel.id}")
    print(f"DEBUG: Available rsnipes: {list(rsnipes.keys())}")
    data = rsnipes.get(ctx.channel.id)
    print(f"DEBUG: RSnipe data found: {data}")
    
    if not data:
        await ctx.send(embed=nova_embed("rSNIPE", "nOTHING tO rSNIPE!"))
        return
    
    desc = f"{data['user']} rEMOVED rEACTION {data['emoji']}"
    if data['jump_url']:
        desc += f"\n[Jump to message]({data['jump_url']})"
    embed = nova_embed("rSNIPE", desc)
    embed.set_footer(text=f"{data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)
    print(f"DEBUG: RSnipe embed sent successfully")

@bot.tree.command(name="rsnipe", description="Show the last removed reaction in this channel")
async def rsnipe_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("rSNIPE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    data = rsnipes.get(interaction.channel.id)
    if not data:
        await interaction.response.send_message(embed=nova_embed("rSNIPE", "nOTHING tO rSNIPE!"), ephemeral=True)
        return
    desc = f"{data['user']} rEMOVED rEACTION {data['emoji']}"
    if data['jump_url']:
        desc += f"\n[Jump to message]({data['jump_url']})"
    embed = nova_embed("rSNIPE", desc)
    embed.set_footer(text=f"{data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed, ephemeral=True)

# Store moderation cases per guild
mod_cases = {}

def log_case(guild_id, action, user, channel, time):
    if guild_id not in mod_cases:
        mod_cases[guild_id] = []
    mod_cases[guild_id].insert(0, {
        'action': action,
        'user': str(user),
        'channel': str(channel),
        'time': time
    })
    if len(mod_cases[guild_id]) > 20:
        mod_cases[guild_id] = mod_cases[guild_id][:20]

@bot.command()
async def dmtest(ctx):
    if ctx.guild is None:
        # In a DM
        await ctx.send(embed=nova_embed("dM tEST", "yOU'RE iN mY dMS, bABY! üíå"))
    else:
        # In a server
        await ctx.send(embed=nova_embed("dM tEST", "yOU'RE iN a sERVER, hONEY! üíÖ"))

@bot.command()
async def endimposter(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("eND iMPOSTER", "yOU dON'T hAVE pERMISSION!"))
        return
    game = IMPOSTER_GAMES.get(ctx.channel.id)
    if not game or not game.active:
        await ctx.send(embed=nova_embed("eND iMPOSTER", "nO aCTIVE iMPOSTER gAME tO eND!"))
        return
    game.end()
    del IMPOSTER_GAMES[ctx.channel.id]
    await ctx.send(embed=nova_embed("eND iMPOSTER", "tHE iMPOSTER gAME hAS bEEN eNDED bY a mOD!"))

@bot.command()
async def setchatlogs(ctx, channel: discord.TextChannel = None):
    """Set the chat logs channel for mod-only logs."""
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    global CHAT_LOGS_CHANNEL_ID
    if channel is None:
        CHAT_LOGS_CHANNEL_ID = None
        save_config()
        await ctx.send("Chat logs channel unset.")
        return
    CHAT_LOGS_CHANNEL_ID = channel.id
    save_config()
    await ctx.send(f"Chat logs channel set to {channel.mention}.")

@bot.tree.command(name="setchatlogs", description="Set the chat logs channel for mod-only logs.")
@app_commands.describe(channel="The channel to log deleted/edited messages")
async def setchatlogs_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    global CHAT_LOGS_CHANNEL_ID
    CHAT_LOGS_CHANNEL_ID = channel.id
    save_config()
    await interaction.response.send_message(f"Chat logs channel set to {channel.mention}.", ephemeral=True)

# Welcome/Farewell system
WELCOME_CHANNEL_ID = None  # Set by ?setwelcome
FAREWELL_CHANNEL_ID = None  # Set by ?setfarewell

@bot.command()
async def setwelcome(ctx, channel: discord.TextChannel = None):
    """Set the welcome channel."""
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    global WELCOME_CHANNEL_ID
    if channel is None:
        WELCOME_CHANNEL_ID = None
        save_config()
        await ctx.send("Welcome channel unset.")
        return
    WELCOME_CHANNEL_ID = channel.id
    save_config()
    await ctx.send(f"Welcome channel set to {channel.mention}.")

@bot.tree.command(name="setwelcome", description="Set the welcome channel.")
@app_commands.describe(channel="The channel to send welcome messages")
async def setwelcome_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    global WELCOME_CHANNEL_ID
    WELCOME_CHANNEL_ID = channel.id
    save_config()
    await interaction.response.send_message(f"Welcome channel set to {channel.mention}.", ephemeral=True)

@bot.command()
async def setfarewell(ctx, channel: discord.TextChannel = None):
    """Set the farewell channel."""
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    global FAREWELL_CHANNEL_ID
    if channel is None:
        FAREWELL_CHANNEL_ID = None
        save_config()
        await ctx.send("Farewell channel unset.")
        return
    FAREWELL_CHANNEL_ID = channel.id
    save_config()
    await ctx.send(f"Farewell channel set to {channel.mention}.")

@bot.tree.command(name="setfarewell", description="Set the farewell channel.")
@app_commands.describe(channel="The channel to send farewell messages")
async def setfarewell_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    global FAREWELL_CHANNEL_ID
    FAREWELL_CHANNEL_ID = channel.id
    save_config()
    await interaction.response.send_message(f"Farewell channel set to {channel.mention}.", ephemeral=True)

@bot.event
async def on_member_join(member):
    if WELCOME_CHANNEL_ID:
        channel = member.guild.get_channel(WELCOME_CHANNEL_ID)
        if channel:
            # Get member count and calculate member number
            member_count = member.guild.member_count
            member_number = member_count  # The new member is the latest count
            
            # Create welcome message with specific rules channel
            description = f"wELCOME tO tHE sERVER, {member.mention}! üíñ\n\n"
            description += f"üìã pLEASE rEAD <#1390109532851535962> tO gET sTARTED!\n"
            description += f"üéâ yOU aRE oUR {member_number}th mEMBER!\n\n"
            description += "mAKE yOURSELF aT hOME!"
            
            embed = nova_embed("üëã wELCOME!", description)
            await channel.send(embed=embed)

@bot.event
async def on_member_remove(member):
    if FAREWELL_CHANNEL_ID:
        channel = member.guild.get_channel(FAREWELL_CHANNEL_ID)
        if channel:
            embed = nova_embed("üëã fAREWELL!", f"{member.display_name} hAS lEFT tHE sERVER. wE'LL mISS yOU! üò¢")
            await channel.send(embed=embed)
@bot.command()
async def imposter(ctx):
    if ctx.guild is None:
        await ctx.send(embed=nova_embed("iMPOSTER", "tHIS cOMMAND mUST bE uSED iN a sERVER cHANNEL!"))
        return
    word_list = [
        "banana", "apple", "grape", "peach", "lemon", "carrot", "onion", "potato", "pizza", "burger",
        "sushi", "taco", "pasta", "croissant", "ramen", "falafel", "burrito", "cheesecake", "donut", "waffle",
        "mountain", "beach", "desert", "forest", "island", "volcano", "river", "ocean", "cave", "valley",
        "laptop", "phone", "keyboard", "camera", "guitar", "piano", "bicycle", "skateboard", "umbrella", "backpack",
        "dragon", "unicorn", "zombie", "robot", "pirate", "wizard", "ghost", "alien", "vampire", "mermaid",
        "diamond", "gold", "ruby", "sapphire", "bob", "pearl", "opal", "jade", "topaz", "poyson", "chile", 
    ]
    join_msg = await ctx.send(embed=nova_embed("iMPOSTER gAME", f"rEACT wITH üïµÔ∏è tO jOIN!\n\nyOU hAVE 30 sECONDS..."))
    await join_msg.add_reaction("üïµÔ∏è")
    reacted_users = set()
    def check(reaction, user):
        return (
            reaction.message.id == join_msg.id and
            str(reaction.emoji) == "üïµÔ∏è" and
            not user.bot and
            user not in reacted_users
        )
    
    try:
        while True:
            reaction, user = await bot.wait_for("reaction_add", timeout=30.0, check=check)
            reacted_users.add(user)
    except asyncio.TimeoutError:
        pass
    players = list(reacted_users)
    if len(players) < 3:
        await ctx.send(embed=nova_embed("iMPOSTER", "nOT eNOUGH pLAYERS rEACTED! gAME cANCELLED, bABY!"))
        return
    imposter = random.choice(players)
    secret_word = random.choice(word_list)
    imposter_word = random.choice([w for w in word_list if w != secret_word])
    failed = []
    for m in players:
        try:
            if m == imposter:
                await m.send(embed=nova_embed("iMPOSTER wORD", f"yOU aRE tHE iMPOSTER! yOUR wORD iS: **{imposter_word}**"))
            else:
                await m.send(embed=nova_embed("iMPOSTER wORD", f"yOUR wORD iS: **{secret_word}**"))
        except Exception:
            failed.append(m.display_name)
    joined_names = ", ".join([f"**{u.display_name}**" for u in players])
    await ctx.send(embed=nova_embed("iMPOSTER", f"aLL sECRET wORDS hAVE bEEN sENT!\n\n**pLAYERS:** {joined_names}"))
    if failed:
        await ctx.send(embed=nova_embed("iMPOSTER", f"cOULD nOT dM: {', '.join(failed)}"))
    # --- Rounds ---
    round_num = 1
    max_rounds = 10
    game_over = False
    while round_num <= max_rounds and not game_over:
        await ctx.send(embed=nova_embed(f"rOUND {round_num}", "eVERYONE, sAY yOUR wORD! nOVA wILL tAG yOU oNE bY oNE."))
        for p in players:
            await ctx.send(f"{p.mention}, iT'S yOUR tURN tO sAY yOUR wORD!")
            def msg_check(m):
                return m.author == p and m.channel == ctx.channel
            try:
                await bot.wait_for("message", timeout=60.0, check=msg_check)
            except asyncio.TimeoutError:
                await ctx.send(f"{p.mention} dID nOT rESPOND iN tIME!")
        # Voting to continue or end
        vote_msg = await ctx.send(embed=nova_embed("cONTINUE oR eND?", "rEACT wITH ‚úÖ tO cONTINUE, ‚ùå tO eND tHE gAME!"))
        await vote_msg.add_reaction("‚úÖ")
        await vote_msg.add_reaction("‚ùå")
        await asyncio.sleep(20)  # 20 seconds to vote
        vote_msg = await ctx.channel.fetch_message(vote_msg.id)
        cont_votes = 0
        end_votes = 0
        for reaction in vote_msg.reactions:
            if str(reaction.emoji) == "‚úÖ":
                cont_votes = reaction.count - 1
            elif str(reaction.emoji) == "‚ùå":
                end_votes = reaction.count - 1
        if end_votes > cont_votes:
            game_over = True
            await ctx.send(embed=nova_embed("gAME eNDING", "mAJORITY vOTED tO eND tHE gAME!"))
        else:
         round_num += 1
    # --- Final Voting ---
    await ctx.send(embed=nova_embed("vOTE tHE iMPOSTER!", "rEACT wITH tHE eMOJI fOR wHO yOU tHINK iS tHE iMPOSTER!"))
    emojis = [chr(0x1F1E6 + i) for i in range(len(players))]  # üá¶, üáß, üá®, ...
    vote_embed = discord.Embed(title="vOTE tHE iMPOSTER!", description="\n".join([f"{emojis[i]} {players[i].mention}" for i in range(len(players))]), color=0xff69b4)
    vote_embed.set_footer(text="nOVA")
    vote_msg = await ctx.send(embed=vote_embed)
    for e in emojis:
        await vote_msg.add_reaction(e)
    await asyncio.sleep(20)  # 20 seconds to vote
    vote_msg = await ctx.channel.fetch_message(vote_msg.id)
    votes = [0] * len(players)
    for reaction in vote_msg.reactions:
        if reaction.emoji in emojis:
            idx = emojis.index(reaction.emoji)
            votes[idx] = reaction.count - 1
    max_votes = max(votes)
    if votes.count(max_votes) > 1:
        await ctx.send(embed=nova_embed("nO wINNER", "iT'S a tIE! nO oNE wINS!"))
        return
    voted_idx = votes.index(max_votes)
    voted_player = players[voted_idx]
    if voted_player == imposter:
        # Crew wins
        for p in players:
            if p != imposter:
                change_balance(p.id, 200)
        await ctx.send(embed=nova_embed("cREW wINS!", f"tHE cREW fOUND tHE iMPOSTER!\n\n{imposter.mention} wAS tHE iMPOSTER!\n\n{', '.join([pl.mention for pl in players if pl != imposter])} gET 200 {CURRENCY_NAME} eACH!"))
    else:
        # Imposter wins
        change_balance(imposter.id, 500)
        await ctx.send(embed=nova_embed("iMPOSTER wINS!", f"{imposter.mention} sURVIVED! tHEY gET 500 {CURRENCY_NAME}!"))

@bot.tree.command(name="imposter", description="Start an imposter game and DM secret words!")
async def imposter_slash(interaction: discord.Interaction):
    if interaction.guild is None or interaction.channel is None:
        await interaction.response.send_message(embed=nova_embed("iMPOSTER", "tHIS cOMMAND mUST bE uSED iN a sERVER cHANNEL!"), ephemeral=True)
        return
    await interaction.response.defer(ephemeral=True, thinking=True)
    # Get all non-bot members who can see the channel
    channel = interaction.channel
    if not hasattr(channel, 'members'):
        await interaction.followup.send(embed=nova_embed("iMPOSTER", "cOULD nOT gET cHANNEL mEMBERS!"), ephemeral=True)
        return
    members = [m for m in channel.members if not m.bot]
    if len(members) < 3:
        await interaction.followup.send(embed=nova_embed("iMPOSTER", "nEED aT lEAST 3 pEOPLE tO pLAY!"), ephemeral=True)
        return
    imposter = random.choice(members)
    word_list = ["banana", "apple", "grape", "peach", "lemon", "carrot", "onion", "potato", "pizza", "burger"]
    secret_word = random.choice(word_list)
    imposter_word = random.choice([w for w in word_list if w != secret_word])
    # Send game start message
    msg = await channel.send(embed=nova_embed("iMPOSTER gAME", f"rEACT wITH üïµÔ∏è tO tHIS mESSAGE tO jOIN!\n\nyOU hAVE 45 sECONDS..."))
    await msg.add_reaction("üïµÔ∏è")
    failed = []
    for m in members:
        try:
            if m == imposter:
                await m.send(embed=nova_embed("iMPOSTER wORD", f"yOU aRE tHE iMPOSTER! yOUR wORD iS: **{imposter_word}**"))
            else:
                await m.send(embed=nova_embed("iMPOSTER wORD", f"yOUR wORD iS: **{secret_word}**"))
        except Exception:
            failed.append(m.display_name)
    if failed:
        await channel.send(embed=nova_embed("iMPOSTER", f"cOULD nOT dM: {', '.join(failed)}"))
    await channel.send(embed=nova_embed("iMPOSTER", "aLL sECRET wORDS hAVE bEEN sENT!"))
    await interaction.followup.send(embed=nova_embed("iMPOSTER", "gAME sTARTED! cHECK yOUR dMS!"), ephemeral=True)
    

@bot.command()
async def warn(ctx, member: discord.Member = None, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("wARN", "yOU dON'T hAVE pERMISSION!"))
        return
    if member is None:
        await ctx.send("Usage: ?warn @user [reason] - Warns a member. Only mods/admins can use this.")
        return
    try:
        # Log the warning
        log_case(ctx.guild.id, "Warn", ctx.author, ctx.channel, datetime.now(datetime.timezone.utc))
        # DM the user
        try:
            await member.send(embed=nova_embed("wARNED bY nOVA", f"yOU wERE wARNED iN {ctx.guild.name} bY {ctx.author.mention} fOR: {reason}"))
        except Exception:
            pass  # Ignore if DMs are closed
        await ctx.send(embed=nova_embed("wARN", f"{member.mention} wAS wARNED fOR: {reason}"))
    except Exception as e:
        await ctx.send(embed=nova_embed("wARN", f"cOULD nOT wARN: {e}"))

# Slash command version of warn
@bot.tree.command(name="warn", description="Warn a member (mods only)")
@app_commands.describe(member="The member to warn", reason="Reason for warning")
async def warn_slash(interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("wARN", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        log_case(interaction.guild.id, "Warn", interaction.user, interaction.channel, datetime.now(datetime.timezone.utc))
        try:
            await member.send(embed=nova_embed("wARNED bY nOVA", f"yOU wERE wARNED iN {interaction.guild.name} bY {interaction.user.mention} fOR: {reason}"))
        except Exception:
            pass
        await interaction.response.send_message(embed=nova_embed("wARN", f"{member.mention} wAS wARNED fOR: {reason}"))
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("wARN", f"cOULD nOT wARN: {e}"), ephemeral=True)

# =========================
# Support Ticket System
# =========================

# Global variables for ticket system
TICKET_CATEGORY_ID = None
SUPPORT_ROLE_ID = None
TICKET_LOGS_CHANNEL_ID = None
ticket_counter = 1

class TicketModal(discord.ui.Modal, title='Create Support Ticket'):
    def __init__(self):
        super().__init__()
        
    subject = discord.ui.TextInput(
        label='Subject',
        placeholder='Brief description of your issue...',
        max_length=100,
        required=True
    )
    
    description = discord.ui.TextInput(
        label='Description',
        placeholder='Detailed description of your issue...',
        style=discord.TextStyle.paragraph,
        max_length=1000,
        required=True
    )
    
    priority = discord.ui.TextInput(
        label='Priority (Low/Normal/High/Urgent)',
        placeholder='Normal',
        default='Normal',
        max_length=10,
        required=False
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        global ticket_counter
        
        # Create ticket channel
        guild = interaction.guild
        category = None
        if TICKET_CATEGORY_ID:
            category = guild.get_channel(TICKET_CATEGORY_ID)
        
        # Create channel with unique name
        channel_name = f"ticket-{ticket_counter:04d}-{interaction.user.name}"
        ticket_counter += 1
        
        # Set permissions
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            interaction.user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        
        # Add support role if set
        if SUPPORT_ROLE_ID:
            support_role = guild.get_role(SUPPORT_ROLE_ID)
            if support_role:
                overwrites[support_role] = discord.PermissionOverwrite(read_messages=True, send_messages=True)
        
        try:
            ticket_channel = await guild.create_text_channel(
                name=channel_name,
                category=category,
                overwrites=overwrites
            )
            
            # Validate and format priority
            priority_input = self.priority.value.strip().lower() if self.priority.value else 'normal'
            priority_emojis = {
                'low': 'üü¢ Low',
                'normal': 'üîµ Normal', 
                'high': 'üü† High',
                'urgent': 'üî¥ Urgent'
            }
            
            # Default to normal if invalid priority
            if priority_input not in priority_emojis:
                priority_input = 'normal'
            
            priority_display = priority_emojis[priority_input]
            
            # Create ticket embed
            embed = nova_embed(
                "üé´ sUPPORT tICKET",
                f"**Subject:** {self.subject.value}\n**Description:** {self.description.value}\n\n**Created by:** {interaction.user.mention}"
            )
            embed.add_field(name="Status", value="üü¢ Open", inline=True)
            embed.add_field(name="Priority", value=priority_display, inline=True)
            
            # Create close butto
            view = TicketCloseView()
            
            await ticket_channel.send(embed=embed, view=view)
            
            # Mention support role if exists
            if SUPPORT_ROLE_ID:
                support_role = guild.get_role(SUPPORT_ROLE_ID)
                if support_role:
                    await ticket_channel.send(f"{support_role.mention} New ticket created!")
            
            await interaction.response.send_message(
                embed=nova_embed("‚úÖ tICKET cREATED", f"Your ticket has been created: {ticket_channel.mention}"),
                ephemeral=True
            )
            
            # Log ticket creation to ticket logs channel
            if TICKET_LOGS_CHANNEL_ID:
                logs_channel = guild.get_channel(TICKET_LOGS_CHANNEL_ID)
                if logs_channel:
                    log_embed = nova_embed(
                        "üé´ tICKET cREATED",
                        f"**Channel:** {ticket_channel.mention}\n**Creator:** {interaction.user.mention}\n**Subject:** {self.subject.value}\n**Priority:** {priority_display}\n**Description:** {self.description.value}"
                    )
                    log_embed.timestamp = datetime.now(dt_timezone.utc)
                    await logs_channel.send(embed=log_embed)
            
        except Exception as e:
            await interaction.response.send_message(
                embed=nova_embed("‚ùå eRROR", f"Failed to create ticket: {e}"),
                ephemeral=True
            )

class TicketCreateView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
    
    @discord.ui.button(label='Create Ticket', style=discord.ButtonStyle.primary, emoji='üé´')
    async def create_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(TicketModal())

class TicketCloseView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
    
    @discord.ui.button(label='Close Ticket', style=discord.ButtonStyle.danger, emoji='üîí')
    async def close_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Check if user has permission to close ticket
        channel = interaction.channel
        if not (interaction.user.guild_permissions.manage_channels or 
                channel.name.endswith(interaction.user.name) or
                (SUPPORT_ROLE_ID and SUPPORT_ROLE_ID in [role.id for role in interaction.user.roles])):
            await interaction.response.send_message(
                embed=nova_embed("‚ùå nO pERMISSION", "You don't have permission to close this ticket!"),
                ephemeral=True
            )
            return
        
        # Create transcript
        messages = []
        async for message in channel.history(limit=None, oldest_first=True):
            if not message.author.bot or message.embeds:
                timestamp = message.created_at.strftime("%Y-%m-%d %H:%M:%S")
                content = message.content if message.content else "[Embed/Attachment]"
                messages.append(f"[{timestamp}] {message.author}: {content}")
        
        transcript = "\n".join(messages)
        
        # Send transcript to user via DM and logs channel
        try:
            transcript_file = discord.File(
                io.StringIO(transcript), 
                filename=f"ticket-transcript-{channel.name}.txt"
            )
            
            # Find the ticket creator
            creator_name = channel.name.split('-')[-1]
            creator = discord.utils.get(interaction.guild.members, name=creator_name)
            
            if creator:
                await creator.send(
                    embed=nova_embed("üìÑ tICKET tRANSCRIPT", f"Your ticket **{channel.name}** has been closed."),
                    file=transcript_file
                )
            
            # Log ticket closure to ticket logs channel
            if TICKET_LOGS_CHANNEL_ID:
                logs_channel = interaction.guild.get_channel(TICKET_LOGS_CHANNEL_ID)
                if logs_channel:
                    # Create a new file object for the logs channel
                    logs_transcript_file = discord.File(
                        io.StringIO(transcript), 
                        filename=f"ticket-transcript-{channel.name}.txt"
                    )
                    
                    log_embed = nova_embed(
                        "üîí tICKET cLOSED",
                        f"**Channel:** {channel.name}\n**Closed by:** {interaction.user.mention}\n**Creator:** {creator.mention if creator else 'Unknown'}"
                    )
                    log_embed.timestamp = datetime.now(dt_timezone.utc)
                    await logs_channel.send(embed=log_embed, file=logs_transcript_file)
                    
        except Exception as e:
            print(f"Failed to send transcript: {e}")
        
        # Close the ticket
        await interaction.response.send_message(
            embed=nova_embed("üîí tICKET cLOSED", "This ticket will be deleted in 5 seconds...")
        )
        
        await asyncio.sleep(5)
        await channel.delete(reason="Ticket closed")

@bot.command()
async def ticket(ctx):
    """Create a support ticket panel"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("tICKET", "Only mods/admins can create ticket panels!"))
        return
    
    embed = nova_embed(
        "üé´ sUPPORT tICKETS",
        "Need help? Click the button below to create a support ticket!\n\n"
        "üìã Please provide a clear subject and description\n"
        "‚è±Ô∏è Our team will respond as soon as possible\n"
        "üîí Only you and staff can see your ticket"
    )
    
    view = TicketCreateView()
    await ctx.send(embed=embed, view=view)
    await ctx.message.delete()

@bot.tree.command(name="ticket", description="Create a support ticket panel (mods only)")
async def ticket_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(
            embed=nova_embed("tICKET", "Only mods/admins can create ticket panels!"),
            ephemeral=True
        )
        return
    
    embed = nova_embed(
        "üé´ sUPPORT tICKETS",
        "Need help? Click the button below to create a support ticket!\n\n"
        "üìã Please provide a clear subject and description\n"
        "‚è±Ô∏è Our team will respond as soon as possible\n"
        "üîí Only you and staff can see your ticket"
    )
    
    view = TicketCreateView()
    await interaction.response.send_message(embed=embed, view=view)

@bot.command()
async def setticketcategory(ctx, category: discord.CategoryChannel = None):
    """Set the category for support tickets"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET tICKET cATEGORY", "Only mods/admins can set ticket category!"))
        return
    
    global TICKET_CATEGORY_ID
    if category is None:
        TICKET_CATEGORY_ID = None
        await ctx.send(embed=nova_embed("sET tICKET cATEGORY", "Ticket category cleared! Tickets will be created in the main channel list."))
    else:
        TICKET_CATEGORY_ID = category.id
        await ctx.send(embed=nova_embed("sET tICKET cATEGORY", f"Ticket category set to: {category.name}"))
    save_config()

@bot.command()
async def setsupportrole(ctx, role: discord.Role = None):
    """Set the support role for tickets"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET sUPPORT rOLE", "Only mods/admins can set support role!"))
        return
    
    global SUPPORT_ROLE_ID
    if role is None:
        SUPPORT_ROLE_ID = None
        await ctx.send(embed=nova_embed("sET sUPPORT rOLE", "Support role cleared!"))
    else:
        SUPPORT_ROLE_ID = role.id
        await ctx.send(embed=nova_embed("sET sUPPORT rOLE", f"Support role set to: {role.name}"))
    save_config()

@bot.command()
async def setticketlogs(ctx, channel: discord.TextChannel = None):
    """Set the ticket logs channel"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET tICKET lOGS", "Only mods/admins can set ticket logs channel!"))
        return
    
    global TICKET_LOGS_CHANNEL_ID
    if channel is None:
        TICKET_LOGS_CHANNEL_ID = None
        await ctx.send(embed=nova_embed("sET tICKET lOGS", "Ticket logs channel cleared!"))
    else:
        TICKET_LOGS_CHANNEL_ID = channel.id
        await ctx.send(embed=nova_embed("sET tICKET lOGS", f"Ticket logs channel set to: {channel.mention}"))
    save_config()

@bot.tree.command(name="setticketlogs", description="Set the ticket logs channel (mods only)")
@app_commands.describe(channel="The channel to log ticket activity")
async def setticketlogs_slash(interaction: discord.Interaction, channel: discord.TextChannel = None):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(
            embed=nova_embed("sET tICKET lOGS", "Only mods/admins can set ticket logs channel!"),
            ephemeral=True
        )
        return
    
    global TICKET_LOGS_CHANNEL_ID
    if channel is None:
        TICKET_LOGS_CHANNEL_ID = None
        await interaction.response.send_message(
            embed=nova_embed("sET tICKET lOGS", "Ticket logs channel cleared!"),
            ephemeral=True
        )
    else:
        TICKET_LOGS_CHANNEL_ID = channel.id
        await interaction.response.send_message(
            embed=nova_embed("sET tICKET lOGS", f"Ticket logs channel set to: {channel.mention}"),
            ephemeral=True
        )
    save_config()

# Temporary debug command to get emoji IDs
@bot.command()
async def getemojis(ctx):
    """Debug command to get all custom emoji IDs"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("gET eMOJIS", "Only mods/admins can use this command!"))
        return
    
    guild = ctx.guild
    if not guild:
        await ctx.send("This command must be used in a server.")
        return
    
    emoji_list = []
    for emoji in guild.emojis:
        emoji_list.append(f"{emoji.name}: `<:{emoji.name}:{emoji.id}>`")
    
    if not emoji_list:
        await ctx.send(embed=nova_embed("gET eMOJIS", "No custom emojis found in this server."))
        return
    
    # Split into chunks if too many emojis
    chunk_size = 10
    for i in range(0, len(emoji_list), chunk_size):
        chunk = emoji_list[i:i+chunk_size]
        embed = nova_embed(
            f"cUSTOM eMOJIS ({i+1}-{min(i+chunk_size, len(emoji_list))} of {len(emoji_list)})",
            "\n".join(chunk)
        )
        await ctx.send(embed=embed)

# =========================
# New Feature Commands
# =========================

# Global variables for new features
BLACKLIST_WORDS = set()
PET_DATA = {}  # user_id: {"name": str, "type": str, "level": int, "xp": int, "hunger": int, "cleanliness": int, "happiness": int}
FOCUS_SESSIONS = {}  # user_id: {"start_time": datetime, "duration": int, "breaks": int}
LOTTERY_PARTICIPANTS = set()  # user_ids
INFRACTIONS = {}  # user_id: [{"type": str, "reason": str, "date": datetime, "moderator": str}]

# Load data files for new features
def load_blacklist():
    global BLACKLIST_WORDS
    try:
        with open("blacklist.json", "r") as f:
            BLACKLIST_WORDS = set(json.load(f))
    except FileNotFoundError:
        BLACKLIST_WORDS = set()

def save_blacklist():
    with open("blacklist.json", "w") as f:
        json.dump(list(BLACKLIST_WORDS), f)

def load_pets():
    global PET_DATA
    try:
        with open("pets.json", "r") as f:
            PET_DATA = json.load(f)
    except FileNotFoundError:
        PET_DATA = {}

def save_pets():
    with open("pets.json", "w") as f:
        json.dump(PET_DATA, f)

def load_infractions():
    global INFRACTIONS
    try:
        with open("infractions.json", "r") as f:
            data = json.load(f)
            # Convert date strings back to datetime objects
            for user_id, infractions in data.items():
                for infraction in infractions:
                    infraction["date"] = datetime.fromisoformat(infraction["date"])
            INFRACTIONS = data
    except FileNotFoundError:
        INFRACTIONS = {}

def save_infractions():
    with open("infractions.json", "w") as f:
        # Convert datetime objects to strings for JSON serialization
        data = {}
        for user_id, infractions in INFRACTIONS.items():
            data[user_id] = []
            for infraction in infractions:
                infraction_copy = infraction.copy()
                infraction_copy["date"] = infraction["date"].isoformat()
                data[user_id].append(infraction_copy)
        json.dump(data, f)

def add_infraction(user_id, infraction_type, reason, moderator):
    user_id = str(user_id)
    if user_id not in INFRACTIONS:
        INFRACTIONS[user_id] = []
    INFRACTIONS[user_id].append({
        "type": infraction_type,
        "reason": reason,
        "date": datetime.now(),
        "moderator": moderator
    })
    save_infractions()

# Load all new feature data on startup
load_blacklist()
load_pets()
load_infractions()

# Drama command
@bot.command()
async def drama(ctx):
    """Nova spills random fake tea between server members"""
    members = [m for m in ctx.guild.members if not m.bot and m != ctx.author]
    if len(members) < 2:
        await ctx.send(embed=nova_embed("dRAMA", "nOT eNOUGH mEMBERS fOR dRAMA!"))
        return
    
    member1, member2 = random.sample(members, 2)
    
    drama_scenarios = [
        f"i hEARD {member1.mention} sAID {member2.mention}'S fAVORITE pIZZA tOPPING iS pINEAPPLE...",
        f"{member1.mention} aPPARENTLY tHINKS {member2.mention} pUTS mILK bEFORE cEREAL... sCANDALOUS!",
        f"rUMOR hAS iT {member2.mention} tOLD eVERYONE tHAT {member1.mention} sTILL sLEEPS wITH a tEDDY bEAR!",
        f"i cAN'T bELIEVE {member1.mention} sAID {member2.mention} uNIRONICALLY lIKES nICKELBACK!",
        f"{member2.mention} aPPARENTLY cAUGHT {member1.mention} tALKING tO tHEIR pLANTS... aGAIN!",
        f"wORD oN tHE sTREET iS {member1.mention} tHINKS {member2.mention} aCTUALLY eNJOYS mONDAYS...",
        f"{member1.mention} rEPORTEDLY sAW {member2.mention} eATING pIZZA wITH a fORK aND kNIFE...",
        f"i hEARD {member2.mention} tOLD eVERYONE tHAT {member1.mention} likes cougars..."
    ]
    
    drama_text = random.choice(drama_scenarios)
    embed = nova_embed("‚òï tEA tIME ‚òï", drama_text)
    await ctx.send(embed=embed)

# Server info command
@bot.command()
async def serverinfo(ctx):
    """Shows server information"""
    guild = ctx.guild
    
    # Count different member types
    total_members = guild.member_count
    humans = len([m for m in guild.members if not m.bot])
    bots = len([m for m in guild.members if m.bot])
    online = len([m for m in guild.members if m.status != discord.Status.offline])
    
    # Get creation date
    created = guild.created_at.strftime("%B %d, %Y")
    
    # Get owner
    owner = guild.owner
    
    embed = nova_embed(
        f"üìä {guild.name} iNFO",
        f"**mEMBERS:** {total_members} ({humans} hUMANS, {bots} bOTS)\n"
        f"**oNLINE:** {online}\n"
        f"**cREATED:** {created}\n"
        f"**oWNER:** {owner.mention if owner else 'uNKNOWN'}\n"
        f"**cHANNELS:** {len(guild.channels)}\n"
        f"**rOLES:** {len(guild.roles)}\n"
        f"**bOOST lEVEL:** {guild.premium_tier}\n"
        f"**bOOSTS:** {guild.premium_subscription_count}"
    )
    
    if guild.icon:
        embed.set_thumbnail(url=guild.icon.url)
    
    await ctx.send(embed=embed)

# Blacklist command
@bot.command()
async def blacklist(ctx, *, word=None):
    """Add or remove words from the blacklist (mods only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("bLACKLIST", "Only mods/admins can manage the blacklist!"))
        return
    
    if word is None:
        if not BLACKLIST_WORDS:
            await ctx.send(embed=nova_embed("bLACKLIST", "nO wORDS aRE cURRENTLY bLACKLISTED."))
        else:
            word_list = "\n".join([f"‚Ä¢ {w}" for w in sorted(BLACKLIST_WORDS)])
            embed = nova_embed("bLACKLIST", f"cURRENT bLACKLISTED wORDS:\n{word_list}")
            await ctx.send(embed=embed)
        return
    
    word = word.lower()
    
    if word in BLACKLIST_WORDS:
        BLACKLIST_WORDS.remove(word)
        save_blacklist()
        await ctx.send(embed=nova_embed("bLACKLIST", f"rEMOVED '{word}' fROM bLACKLIST."))
    else:
        BLACKLIST_WORDS.add(word)
        save_blacklist()
        await ctx.send(embed=nova_embed("bLACKLIST", f"aDDED '{word}' tO bLACKLIST."))

# Focus timer command
@bot.command()
async def focus(ctx, duration: int = 25):
    """Start a Pomodoro-style focus timer"""
    if duration < 1 or duration > 120:
        await ctx.send(embed=nova_embed("fOCUS", "dURATION mUST bE bETWEEN 1-120 mINUTES!"))
        return
    
    user_id = ctx.author.id
    
    if user_id in FOCUS_SESSIONS:
        await ctx.send(embed=nova_embed("fOCUS", "yOU aLREADY hAVE aN aCTIVE fOCUS sESSION!"))
        return
    
    FOCUS_SESSIONS[user_id] = {
        "start_time": datetime.now(),
        "duration": duration,
        "breaks": 0
    }
    
    embed = nova_embed(
        "üéØ fOCUS sESSION sTARTED",
        f"fOCUSING fOR {duration} mINUTES!\n"
        f"i'LL pING yOU wHEN iT'S tIME fOR a bREAK!"
    )
    await ctx.send(embed=embed)
    
    # Wait for the duration and then notify
    await asyncio.sleep(duration * 60)
    
    if user_id in FOCUS_SESSIONS:
        FOCUS_SESSIONS[user_id]["breaks"] += 1
        breaks = FOCUS_SESSIONS[user_id]["breaks"]
        
        break_duration = 15 if breaks % 4 != 0 else 30  # Long break every 4 sessions
        
        embed = nova_embed(
            "‚è∞ fOCUS sESSION cOMPLETE!",
            f"gREAT jOB! tAKE a {break_duration}-mINUTE bREAK! üéâ\n"
            f"sESSIONS cOMPLETED: {breaks}"
        )
        await ctx.send(f"{ctx.author.mention}", embed=embed)
        
        # Remove session after break
        await asyncio.sleep(break_duration * 60)
        if user_id in FOCUS_SESSIONS:
            del FOCUS_SESSIONS[user_id]

# Lottery command (owner only)
@bot.command()
async def lottery(ctx, action=None, price: int = None):
    """Manage the weekly server lottery (owner only)"""
    if ctx.author.id != OWNER_ID:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "Only the owner can manage the lottery!"))
        return
    
    if action is None:
        # Show current lottery status
        embed = nova_embed(
            "üé∞ lOTTERY sTATUS",
            f"pARTICIPANTS: {len(LOTTERY_PARTICIPANTS)}\n"
            f"cURRENT eNTRY cOST: {config.get('lottery_price', 100)} {CURRENCY_NAME}\n\n"
            f"cOMMANDS:\n"
            f"`?lottery start [price]` - Start new lottery with optional price\n"
            f"`?lottery draw` - Draw winner and end current lottery\n"
            f"`?lottery reset` - Reset current lottery\n"
            f"`?lottery price [amount]` - Set entry price"
        )
        await ctx.send(embed=embed)
        return
    
    if action.lower() == "start":
        if price is not None:
            config['lottery_price'] = price
            save_config()
        
        LOTTERY_PARTICIPANTS.clear()
        entry_cost = config.get('lottery_price', 100)
        
        embed = nova_embed(
            "üé∞ nEW lOTTERY sTARTED!",
            f"eNTRY cOST: {entry_cost} {CURRENCY_NAME}\n"
            f"uSE `?joinlottery` tO pARTICIPATE!"
        )
        await ctx.send(embed=embed)
    
    elif action.lower() == "draw":
        if not LOTTERY_PARTICIPANTS:
            await ctx.send(embed=nova_embed("üé∞ lOTTERY", "nO pARTICIPANTS iN cURRENT lOTTERY!"))
            return
        
        winner_id = random.choice(list(LOTTERY_PARTICIPANTS))
        winner = ctx.guild.get_member(winner_id)
        entry_cost = config.get('lottery_price', 100)
        prize = len(LOTTERY_PARTICIPANTS) * entry_cost
        
        change_balance(winner_id, prize)
        
        embed = nova_embed(
            "üéâ lOTTERY wINNER!",
            f"cONGRATULATIONS {winner.mention}!\n"
            f"yOU wON {prize} {CURRENCY_NAME}!\n\n"
            f"pARTICIPANTS: {len(LOTTERY_PARTICIPANTS)}"
        )
        await ctx.send(embed=embed)
        
        LOTTERY_PARTICIPANTS.clear()
    
    elif action.lower() == "reset":
        LOTTERY_PARTICIPANTS.clear()
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "lOTTERY rESET!"))
    
    elif action.lower() == "price":
        if price is None:
            await ctx.send(embed=nova_embed("üé∞ lOTTERY", "pLEASE sPECIFY a pRICE!"))
            return
        
        config['lottery_price'] = price
        save_config()
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", f"eNTRY pRICE sET tO {price} {CURRENCY_NAME}!"))
    
    else:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "iNVALID aCTION! uSE: start, draw, reset, or price"))

# Join lottery command (for regular users)
@bot.command()
async def joinlottery(ctx):
    """Join the current lottery"""
    user_id = ctx.author.id
    
    if user_id in LOTTERY_PARTICIPANTS:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "yOU'RE aLREADY iN tHIS lOTTERY!"))
        return
    
    entry_cost = config.get('lottery_price', 100)
    
    # Check if user has enough balance
    if get_balance(user_id) < entry_cost:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", f"yOU nEED {entry_cost} {CURRENCY_NAME} tO jOIN tHE lOTTERY!"))
        return
    
    change_balance(user_id, -entry_cost)
    LOTTERY_PARTICIPANTS.add(user_id)
    
    embed = nova_embed(
        "üé∞ lOTTERY eNTRY",
        f"yOU'VE jOINED tHIS wEEK'S lOTTERY!\n"
        f"pARTICIPANTS: {len(LOTTERY_PARTICIPANTS)}\n"
        f"pRIZE pOOL: {len(LOTTERY_PARTICIPANTS) * entry_cost} {CURRENCY_NAME}"
    )
    await ctx.send(embed=embed)

# Pet adoption system
class PetView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id
    
    @discord.ui.button(label='fEED', style=discord.ButtonStyle.primary, emoji='üçñ')
    async def feed_pet(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("tHIS iSN'T yOUR pET!", ephemeral=True)
            return
        
        user_id = str(self.user_id)
        if user_id not in PET_DATA:
            await interaction.response.send_message("yOU dON'T hAVE a pET!", ephemeral=True)
            return
        
        pet = PET_DATA[user_id]
        if pet["hunger"] >= 100:
            await interaction.response.send_message(f"{pet['name']} iS aLREADY fULL!", ephemeral=True)
            return
        
        pet["hunger"] = min(100, pet["hunger"] + 25)
        pet["happiness"] = min(100, pet["happiness"] + 10)
        pet["xp"] += 5
        
        # Check for level up
        new_level = pet["xp"] // 100 + 1
        level_up = new_level > pet["level"]
        pet["level"] = new_level
        
        save_pets()
        
        message = f"yOU fED {pet['name']}! üçñ\nhUNGER: {pet['hunger']}/100"
        if level_up:
            message += f"\nüéâ {pet['name']} lEVELED uP tO lEVEL {pet['level']}!"
        
        await interaction.response.send_message(message, ephemeral=True)
    
    @discord.ui.button(label='cLEAN', style=discord.ButtonStyle.secondary, emoji='üßΩ')
    async def clean_pet(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("tHIS iSN'T yOUR pET!", ephemeral=True)
            return
        
        user_id = str(self.user_id)
        if user_id not in PET_DATA:
            await interaction.response.send_message("yOU dON'T hAVE a pET!", ephemeral=True)
            return
        
        pet = PET_DATA[user_id]
        if pet["cleanliness"] >= 100:
            await interaction.response.send_message(f"{pet['name']} iS aLREADY cLEAN!", ephemeral=True)
            return
        
        pet["cleanliness"] = min(100, pet["cleanliness"] + 30)
        pet["happiness"] = min(100, pet["happiness"] + 15)
        pet["xp"] += 8
        
        # Check for level up
        new_level = pet["xp"] // 100 + 1
        level_up = new_level > pet["level"]
        pet["level"] = new_level
        
        save_pets()
        
        message = f"yOU cLEANED {pet['name']}! üßΩ\ncLEANLINESS: {pet['cleanliness']}/100"
        if level_up:
            message += f"\nüéâ {pet['name']} lEVELED uP tO lEVEL {pet['level']}!"
        
        await interaction.response.send_message(message, ephemeral=True)
    
    @discord.ui.button(label='pET', style=discord.ButtonStyle.success, emoji='‚ù§Ô∏è')
    async def pet_pet(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("tHIS iSN'T yOUR pET!", ephemeral=True)
            return
        
        user_id = str(self.user_id)
        if user_id not in PET_DATA:
            await interaction.response.send_message("yOU dON'T hAVE a pET!", ephemeral=True)
            return
        
        pet = PET_DATA[user_id]
        pet["happiness"] = min(100, pet["happiness"] + 20)
        pet["xp"] += 3
        
        # Check for level up
        new_level = pet["xp"] // 100 + 1
        level_up = new_level > pet["level"]
        pet["level"] = new_level
        
        save_pets()
        
        responses = [
            f"{pet['name']} pURRS hAPPILY!",
            f"{pet['name']} wAGS tHEIR tAIL!",
            f"{pet['name']} nUZZLES yOU!",
            f"{pet['name']} lOOKS vERY hAPPY!"
        ]
        
        message = random.choice(responses) + f"\nhAPPINESS: {pet['happiness']}/100"
        if level_up:
            message += f"\nüéâ {pet['name']} lEVELED uP tO lEVEL {pet['level']}!"
        
        await interaction.response.send_message(message, ephemeral=True)

@bot.command()
async def adoptpet(ctx):
    """Adopt a virtual pet"""
    user_id = str(ctx.author.id)
    
    if user_id in PET_DATA:
        await ctx.send(embed=nova_embed("aDOPT pET", f"yOU aLREADY hAVE a pET nAMED {PET_DATA[user_id]['name']}!"))
        return
    
    animals = ["Cat", "Dog", "Red Panda", "Raven", "Octopus", "Goldfish", "Tortoise", "Owl", "Lizard", "Bat", "Dove"]
    animal_emojis = {"Cat": "üê±", "Dog": "üê∂", "Red Panda": "üêº", "Raven": "üê¶‚Äç‚¨õ", "Octopus": "üêô", 
                    "Goldfish": "üê†", "Tortoise": "üê¢", "Owl": "ü¶â", "Lizard": "ü¶é", "Bat": "ü¶á", "Dove": "üïäÔ∏è"}
    
    animal_list = "\n".join([f"{animal_emojis[animal]} {animal}" for animal in animals])
    
    embed = nova_embed(
        "üè† aDOPT a pET",
        f"cHOOSE yOUR pET:\n{animal_list}\n\ntYPE tHE aNIMAL nAME tO aDOPT!"
    )
    await ctx.send(embed=embed)
    
    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel and m.content.title() in animals
    
    try:
        msg = await bot.wait_for('message', check=check, timeout=30.0)
        chosen_animal = msg.content.title()
        
        await ctx.send(embed=nova_embed("nAME yOUR pET", f"wHAT wOULD yOU lIKE tO nAME yOUR {chosen_animal}?"))
        
        def name_check(m):
            return m.author == ctx.author and m.channel == ctx.channel and len(m.content) <= 20
        
        name_msg = await bot.wait_for('message', check=name_check, timeout=30.0)
        pet_name = name_msg.content
        
        # Create pet data
        PET_DATA[user_id] = {
            "name": pet_name,
            "type": chosen_animal,
            "level": 1,
            "xp": 0,
            "hunger": 100,
            "cleanliness": 100,
            "happiness": 100
        }
        save_pets()
        
        embed = nova_embed(
            "üéâ aDOPTION sUCCESSFUL!",
            f"cONGRATULATIONS! yOU aDOPTED {pet_name} tHE {chosen_animal}!\n"
            f"uSE `?pet` tO iNTERACT wITH yOUR nEW fRIEND!"
        )
        embed.set_thumbnail(url=ctx.author.avatar.url if ctx.author.avatar else None)
        await ctx.send(embed=embed)
        
    except asyncio.TimeoutError:
        await ctx.send(embed=nova_embed("aDOPT pET", "aDOPTION tIMED oUT! tRY aGAIN lATER."))

@bot.command()
async def pet(ctx):
    """Interact with your pet"""
    user_id = str(ctx.author.id)
    
    if user_id not in PET_DATA:
        await ctx.send(embed=nova_embed("pET", "yOU dON'T hAVE a pET! uSE `?adoptpet` tO aDOPT oNE!"))
        return
    
    pet = PET_DATA[user_id]
    
    # Decrease stats over time (basic simulation)
    import time
    current_time = time.time()
    if "last_update" not in pet:
        pet["last_update"] = current_time
    
    time_diff = (current_time - pet["last_update"]) / 3600  # Hours
    if time_diff > 1:  # Only update if more than 1 hour passed
        pet["hunger"] = max(0, pet["hunger"] - int(time_diff * 5))
        pet["cleanliness"] = max(0, pet["cleanliness"] - int(time_diff * 3))
        pet["happiness"] = max(0, pet["happiness"] - int(time_diff * 2))
        pet["last_update"] = current_time
        save_pets()
    
    # Create status bars
    def create_bar(value, max_val=100):
        filled = int((value / max_val) * 10)
        return "‚ñà" * filled + "‚ñë" * (10 - filled)
    
    embed = nova_embed(
        f"{pet['name']} tHE {pet['type']}",
        f"**lEVEL:** {pet['level']} (XP: {pet['xp']}/100)\n"
        f"**hUNGER:** {create_bar(pet['hunger'])} {pet['hunger']}/100\n"
        f"**cLEANLINESS:** {create_bar(pet['cleanliness'])} {pet['cleanliness']}/100\n"
        f"**hAPPINESS:** {create_bar(pet['happiness'])} {pet['happiness']}/100"
    )
    
    view = PetView(ctx.author.id)
    await ctx.send(embed=embed, view=view)



bot.run(TOKEN)
