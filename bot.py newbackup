# =========================
# Imports and Setup
# =========================
import discord
from discord.ext import commands
import json
import random
from datetime import datetime, timedelta, timezone
import os
from dotenv import load_dotenv
from discord import app_commands
import time
import requests
import re
import asyncio
import io
from discord.ui import View, Button
import functools

# =========================
# Intents and Bot Instance
# =========================
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.presences = True

bot = commands.Bot(command_prefix="?", intents=intents, help_command=None)

# =========================
# Constants and Globals
# =========================
CURRENCY_NAME = "dOLLARIANAS"
DATA_FILE = "balances.json"
XP_FILE = "xp.json"
CONFIG_FILE = "config.json"
BIRTHDAY_FILE = "birthdays.json"
RELATIONSHIPS_FILE = "relationships.json"
REMINDERS_FILE = "reminders.json"
THRIFT_FILE = "thrift.json"

balances = {}
user_xp = {}
config = {}

beg_cooldowns = {}
work_cooldowns = {}
daily_cooldowns = {}

OWNER_ID = 755846396208218174

# Server restriction - Set to your server ID
ALLOWED_SERVER_ID = 1390109232677785674  # Your server ID

ROLE_MESSAGE_ID = None
EMOJI_TO_ROLE = {
    "üíô": "mALE",
    "üíó": "fEMALE",
    "ü§ç": "oTHER (AKS)"
}

SERPAPI_KEY = os.getenv("SERPAPI_KEY")

# AFK system
AFK_STATUS = {}  # user_id: {"reason": str, "since": datetime, "mentions": set(user_id)}

# Runway system
RUNWAY_CHANNEL_ID = None  # Set this to your runway channel ID

# Chat logs system
CHAT_LOGS_CHANNEL_ID = None  # Set by ?setchatlogs

# International days dictionary (all 365 days, placeholder names)
INTERNATIONAL_DAYS = {
    "04-01": "wORLD bRAILLE dAY",
    "24-01": "iNTERNATIONAL dAY oF eDUCATION",
    "26-01": "iNTERNATIONAL dAY oF cLEAN eNERGY",
    "27-01": "iNTERNATIONAL dAY oF cOMMEMORATION iN mEMORY oF tHE vICTIMS oF tHE hOLOCAUST",
    "28-01": "iNTERNATIONAL dAY oF pEACEFUL cOEXISTENCE",
    "01-02": "wORLD iNTERFAITH hARMONY wEEK (1-7 fEBRUARY)",
    "02-02": "wORLD wETLANDS dAY",
    "04-02": "iNTERNATIONAL dAY oF hUMAN fRATERNITY",
    "06-02": "iNTERNATIONAL dAY oF zERO tOLERANCE tO fEMALE gENITAL mUTILATION",
    "10-02": "wORLD pULSES dAY",
    "11-02": "iNTERNATIONAL dAY oF wOMEN aND gIRLS iN sCIENCE",
    "12-02": "iNTERNATIONAL dAY fOR tHE pREVENTION oF vIOLENT eXTREMISM aS aND wHEN cONDUCIVE tO tERRORISM",
    "13-02": "wORLD rADIO dAY",
    "17-02": "gLOBAL tOURISM rESILIENCE dAY",
    "20-02": "wORLD dAY oF sOCIAL jUSTICE",
    "21-02": "iNTERNATIONAL mOTHER lANGUAGE dAY",
    "01-03": "zERO dISCRIMINATION dAY",
    "03-03": "wORLD wILDLIFE dAY",
    "05-03": "iNTERNATIONAL dAY fOR dISARMAMENT aND nON-pROLIFERATION aWARENESS",
    "08-03": "iNTERNATIONAL wOMEN'S dAY",
    "10-03": "iNTERNATIONAL dAY oF wOMEN jUDGES",
    "15-03": "iNTERNATIONAL dAY tO cOMBAT iSLAMOPHOBIA",
    "20-03": "iNTERNATIONAL dAY oF hAPPINESS",
    "21-03": "wORLD dAY fOR gLACIERS",
    "22-03": "wORLD wATER dAY",
    "23-03": "wORLD mETEOROLOGICAL dAY",
    "24-03": "wORLD tUBERCULOSIS dAY",
    "25-03": "iNTERNATIONAL dAY oF rEMEMBRANCE oF tHE vICTIMS oF sLAVERY aND tHE tRANSATLANTIC sLAVE tRADE",
    "30-03": "iNTERNATIONAL dAY oF zERO wASTE",
    "02-04": "wORLD aUTISM aWARENESS dAY",
    "04-04": "iNTERNATIONAL dAY fOR mINE aWARENESS aND aSSISTANCE iN mINE aCTION",
    "05-04": "iNTERNATIONAL dAY oF cONSCIENCE",
    "06-04": "iNTERNATIONAL dAY oF sPORT fOR dEVELOPMENT aND pEACE",
    "07-04": "wORLD hEALTH dAY",
    "12-04": "iNTERNATIONAL dAY oF hUMAN sPACE fLIGHT",
    "14-04": "wORLD cHAGAS dISEASE dAY",
    "20-04": "cHINESE lANGUAGE dAY",
    "21-04": "wORLD cREATIVITY aND iNNOVATION dAY",
    "22-04": "iNTERNATIONAL mOTHER eARTH dAY",
    "23-04": "wORLD bOOK aND cOPYRIGHT dAY",
    "24-04": "iNTERNATIONAL gIRLS iN iCT dAY",
    "25-04": "wORLD mALARIA dAY",
    "26-04": "iNTERNATIONAL cHERNOBYL dISASTER rEMEMBRANCE dAY",
    "28-04": "wORLD dAY fOR sAFETY aND hEALTH aT wORK",
    "29-04": "iNTERNATIONAL dAY iN mEMORY oF tHE vICTIMS oF eARTHQUAKES",
    "30-04": "iNTERNATIONAL jAZZ dAY",
    "02-05": "wORLD tUNA dAY",
    "03-05": "wORLD pRESS fREEDOM dAY",
    "05-05": "wORLD pORTUGUESE lANGUAGE dAY",
    "08-05": "tIME oF rEMEMBRANCE aND rECONCILIATION fOR tHOSE wHO lOST tHEIR lIVES dURING tHE sECOND wORLD wAR",
    "10-05": "iNTERNATIONAL dAY oF aRGANIA",
    "12-05": "uN gLOBAL rOAD sAFETY wEEK",
    "15-05": "iNTERNATIONAL dAY oF lIVING tOGETHER iN pEACE",
    "16-05": "iNTERNATIONAL dAY oF lIGHT",
    "17-05": "wORLD fAIR pLAY dAY",
    "19-05": "wORLD bEE dAY",
    "20-05": "iNTERNATIONAL tEA dAY",
    "21-05": "wORLD dAY fOR cULTURAL dIVERSITY fOR dIALOGUE aND dEVELOPMENT",
    "22-05": "iNTERNATIONAL dAY fOR bIOLOGICAL dIVERSITY",
    "23-05": "iNTERNATIONAL dAY tO eND oBSTETRIC fISTULA",
    "24-05": "iNTERNATIONAL dAY oF tHE mARKHOR",
    "25-05": "wORLD fOOTBALL dAY",
    "29-05": "iNTERNATIONAL dAY oF uN pEACEKEEPERS",
    "30-05": "iNTERNATIONAL dAY oF pOTATO",
    "31-05": "wORLD nO-tOBACCO dAY",
    "01-06": "gLOBAL dAY oF pARENTS",
    "03-06": "wORLD bICYCLE dAY",
    "04-06": "iNTERNATIONAL dAY oF iNNOCENT cHILDREN vICTIMS oF aGGRESSION",
    "05-06": "wORLD eNVIRONMENT dAY",
    "06-06": "rUSSIAN lANGUAGE dAY",
    "07-06": "wORLD fOOD sAFETY dAY",
    "08-06": "wORLD oCEANS dAY",
    "10-06": "iNTERNATIONAL dAY fOR dIALOGUE aMONG cIVILIZATIONS",
    "11-06": "iNTERNATIONAL dAY oF pLAY",
    "12-06": "wORLD dAY aGAINST cHILD lABOUR",
    "13-06": "iNTERNATIONAL aLBINISM aWARENESS dAY",
    "14-06": "wORLD bLOOD dONOR dAY",
    "15-06": "wORLD eLDER aBUSE aWARENESS dAY",
    "16-06": "iNTERNATIONAL dAY oF fAMILY rEMITTANCES",
    "17-06": "wORLD dAY tO cOMBAT dESERTIFICATION aND dROUGHT",
    "18-06": "sUSTAINABLE gASTRONOMY dAY",
    "19-06": "iNTERNATIONAL dAY fOR tHE eLIMINATION oF sEXUAL vIOLENCE iN cONFLICT",
    "20-06": "wORLD rEFUGEE dAY",
    "21-06": "iNTERNATIONAL dAY oF yOGA",
    "23-06": "uN pUBLIC sERVICE dAY",
    "24-06": "iNTERNATIONAL dAY oF wOMEN iN dIPLOMACY",
    "25-06": "dAY oF tHE sEAFARER",
    "26-06": "iNTERNATIONAL dAY aGAINST dRUG aBUSE aND iLLICIT tRAFFICKING",
    "27-06": "iNTERNATIONAL dAY oF dEAFBLINDNESS",
    "29-06": "iNTERNATIONAL dAY oF tHE tROPICS",
    "30-06": "iNTERNATIONAL aSTEROID dAY",
    "05-07": "iNTERNATIONAL dAY oF cOOPERATIVES",
    "06-07": "wORLD rURAL dEVELOPMENT dAY",
    "07-07": "wORLD kISWAHILI lANGUAGE dAY",
    "11-07": "wORLD hORSE dAY",
    "12-07": "iNTERNATIONAL dAY oF cOMbATING sAND aND dUST sTORMS",
    "15-07": "nELSON mANDELA iNTERNATIONAL dAY",
    "18-07": "wORLD cHESS dAY",
    "20-07": "iNTERNATIONAL mOON dAY",
    "25-07": "wORLD dROWNING pREVENTION dAY",
    "28-07": "wORLD hEPATITIS dAY",
    "30-07": "iNTERNATIONAL dAY oF fRIENDSHIP",
    "01-08": "wORLD bREASTFEEDING wEEK",
    "09-08": "iNTERNATIONAL dAY oF tHE wORLD'S iNDIGENOUS pEOPLES",
    "11-08": "wORLD sTEELPAN dAY",
    "12-08": "iNTERNATIONAL yOUTH dAY",
    "19-08": "wORLD hUMANITARIAN dAY",
    "21-08": "iNTERNATIONAL dAY oF rEMEMBRANCE aND tRIBUTE tO tHE vICTIMS oF tERRORISM",
    "22-08": "iNTERNATIONAL dAY cOMMEMORATING tHE vICTIMS oF aCTS oF vIOLENCE bASED oN rELIGION oR bELIEF",
    "23-08": "wORLD lAKE dAY",
    "27-08": "iNTERNATIONAL dAY aGAINST nUCLEAR tESTS",
    "29-08": "iNTERNATIONAL dAY oF tHE vICTIMS oF eNFORCED dISAPPEARANCES",
    "30-08": "iNTERNATIONAL dAY fOR pEOPLE oF aFRICAN dESCENT",
    "31-08": "iNTERNATIONAL dAY 243",
    "02-11": "iNTERNATIONAL dAY tO eND iMPUNITY fOR cRIMES aGAINST jOURNALISTS",
    "05-11": "wORLD tSUNAMI aWARENESS dAY",
    "06-11": "iNTERNATIONAL dAY fOR pREVENTING tHE eXPLOITATION oF tHE eNVIRONMENT iN wAR aND aRMED cONFLICT",
    "09-11": "wORLD sCIENCE dAY fOR pEACE aND dEVELOPMENT",
    "10-11": "wORLD dIABETES dAY",
    "14-11": "iNTERNATIONAL dAY fOR tHE pREVENTION oF aND fIGHT aGAINST aLL fORMS oF tRANSNATIONAL oRGANIZED cRIME",
    "15-11": "iNTERNATIONAL dAY fOR tOLERANCE",
    "16-11": "wORLD dAY oF rEMEMBRANCE fOR rOAD tRAFFIC vICTIMS",
    "18-11": "wORLD tOILET dAY",
    "19-11": "wORLD pHILOSOPHY dAY",
    "20-11": "wORLD cHILDREN'S dAY",
    "21-11": "wORLD cONJOINED tWINS dAY",
    "24-11": "iNTERNATIONAL dAY fOR tHE eLIMINATION oF vIOLENCE aGAINST wOMEN",
    "25-11": "wORLD sUSTAINABLE tRANSPORT dAY",
    "26-11": "iNTERNATIONAL dAY oF sOLIDARITY wITH tHE pALESTINIAN pEOPLE",
    "29-11": "dAY oF rEMEMBRANCE fOR aLL vICTIMS oF cHEMICAL wARFARE",
    "30-11": "iNTERNATIONAL dAY 334",
    "01-12": "wORLD aIDS dAY",
    "02-12": "iNTERNATIONAL dAY fOR tHE aBOLITION oF sLAVERY",
    "03-12": "iNTERNATIONAL dAY oF pERSONS wITH dISABILITIES",
    "04-12": "iNTERNATIONAL dAY oF bANKS",
    "05-12": "iNTERNATIONAL dAY aGAINST uNILATERAL cOERCIVE mEASURES",
    "07-12": "wORLD sOIL dAY",
    "09-12": "iNTERNATIONAL dAY oF cOMMEMORATION aND dIGNITY oF tHE vICTIMS oF tHE cRIME oF gENOCIDE aND oF tHE pREVENTION oF tHIS cRIME",
    "10-12": "hUMAN rIGHTS dAY",
    "11-12": "iNTERNATIONAL mOUNTAIN dAY",
    "12-12": "iNTERNATIONAL dAY oF nEUTRALITY",
    "18-12": "iNTERNATIONAL mIGRANTS dAY",
    "20-12": "iNTERNATIONAL hUMAN sOLIDARITY dAY",
    "21-12": "wORLD mEDITATION dAY",
    "27-12": "iNTERNATIONAL dAY oF ePIDEMIC pREPAREDNESS",
    "25-12": "cHRISTMAS dAY"
}

# =========================
# Helper Functions
# =========================

def load_config():
    """Load configuration from CONFIG_FILE into the global config dict."""
    global config, CHAT_LOGS_CHANNEL_ID, WELCOME_CHANNEL_ID, FAREWELL_CHANNEL_ID
    try:
        with open(CONFIG_FILE, "r") as f:
            config = json.load(f)
            CHAT_LOGS_CHANNEL_ID = config.get("chat_logs_channel_id")
            WELCOME_CHANNEL_ID = config.get("welcome_channel_id")
            FAREWELL_CHANNEL_ID = config.get("farewell_channel_id")
    except FileNotFoundError:
        config = {"mod_role_id": None, "admin_role_id": None, "chat_logs_channel_id": None, "welcome_channel_id": None, "farewell_channel_id": None}
        CHAT_LOGS_CHANNEL_ID = None
        WELCOME_CHANNEL_ID = None
        FAREWELL_CHANNEL_ID = None

def save_config():
    """Save the current config dict to CONFIG_FILE."""
    global CHAT_LOGS_CHANNEL_ID, WELCOME_CHANNEL_ID, FAREWELL_CHANNEL_ID
    config["chat_logs_channel_id"] = CHAT_LOGS_CHANNEL_ID
    config["welcome_channel_id"] = WELCOME_CHANNEL_ID
    config["farewell_channel_id"] = FAREWELL_CHANNEL_ID
    with open(CONFIG_FILE, "w") as f:
        json.dump(config, f)

def load_balances():
    """Load user balances from DATA_FILE into the global balances dict."""
    global balances
    try:
        with open(DATA_FILE, "r") as f:
            balances = json.load(f)
    except FileNotFoundError:
        balances = {}

def save_balances():
    """Save the current balances dict to DATA_FILE."""
    with open(DATA_FILE, "w") as f:
        json.dump(balances, f)

def get_balance(user_id):
    """Get the balance for a user by their ID."""
    return balances.get(str(user_id), 0)

def change_balance(user_id, amount):
    """Change a user's balance by a given amount. Prevents negative balances."""
    user_id = str(user_id)
    balances[user_id] = balances.get(user_id, 0) + amount
    if balances[user_id] < 0:
        balances[user_id] = 0
    save_balances()

def load_xp():
    """Load user XP data from XP_FILE into the global user_xp dict."""
    global user_xp
    try:
        with open(XP_FILE, "r") as f:
            user_xp = json.load(f)
    except FileNotFoundError:
        user_xp = {}

def save_xp():
    """Save the current user_xp dict to XP_FILE."""
    with open(XP_FILE, "w") as f:
        json.dump(user_xp, f)

def add_xp(user_id, amount):
    """Add XP to a user and handle level-ups."""
    user_id = str(user_id)
    xp_data = user_xp.get(user_id, {"xp": 0, "level": 1})
    xp_data["xp"] += amount
    # Level up every 100 XP
    if xp_data["xp"] >= xp_data["level"] * 100:
        xp_data["xp"] = 0
        xp_data["level"] += 1
    user_xp[user_id] = xp_data
    save_xp()

def get_level(user_id):
    """Get the level and XP for a user by their ID."""
    return user_xp.get(str(user_id), {"xp": 0, "level": 1})

def has_mod_or_admin(ctx):
    """Check if the user has mod or admin privileges, is the bot owner, or is the server owner."""
    print(f"\n=== PERMISSION DEBUG ===")
    print(f"User: {ctx.author} (ID: {ctx.author.id})")
    print(f"Guild: {ctx.guild.name if ctx.guild else 'None'} (ID: {ctx.guild.id if ctx.guild else 'None'})")
    print(f"Guild Owner ID: {ctx.guild.owner_id if ctx.guild else 'None'}")
    print(f"Bot Owner ID: {OWNER_ID}")
    print(f"User has admin perms: {ctx.author.guild_permissions.administrator if ctx.guild else 'No guild'}")
    
    # Check if user is the bot owner
    if ctx.author.id == OWNER_ID:
        print(f"‚úÖ User is bot owner")
        return True
    
    # Check if user is the server owner
    if ctx.guild and ctx.author.id == ctx.guild.owner_id:
        print(f"‚úÖ User is server owner")
        return True
    
    # Check if user has administrator permissions
    if ctx.author.guild_permissions.administrator:
        print(f"‚úÖ User has administrator permissions")
        return True
    
    # Check for specific mod/admin roles (server-specific)
    guild_id = ctx.guild.id if ctx.guild else None
    if guild_id:
        mod_role_id = get_server_config(guild_id, "mod_role_id")
        admin_role_id = get_server_config(guild_id, "admin_role_id")
    else:
        # Fallback to global config if no guild context
        mod_role_id = config.get("mod_role_id")
        admin_role_id = config.get("admin_role_id")
    
    user_role_ids = [role.id for role in ctx.author.roles]
    
    print(f"Guild ID: {guild_id}")
    print(f"Server-specific mod_role_id: {mod_role_id}")
    print(f"Server-specific admin_role_id: {admin_role_id}")
    print(f"User role IDs: {user_role_ids}")
    
    has_role = (mod_role_id and mod_role_id in user_role_ids) or (admin_role_id and admin_role_id in user_role_ids)
    print(f"Has mod/admin role: {has_role}")
    
    if has_role:
        print(f"‚úÖ User has mod/admin role")
        return True
    
    print(f"‚ùå Permission denied")
    print(f"========================\n")
    
    return False

def load_birthdays():
    try:
        with open(BIRTHDAY_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_birthdays(birthdays):
    with open(BIRTHDAY_FILE, "w") as f:
        json.dump(birthdays, f)

# Nova embed helper

def nova_embed(title, description=None, color=0xff69b4, footer="nOVA"):
    embed = discord.Embed(title=title, description=description, color=color)
    embed.set_footer(text=footer)
    return embed

# Example usage in commands:
# await ctx.send(embed=nova_embed("TITLE", "description"))
# await interaction.response.send_message(embed=nova_embed("TITLE", "description"))

# =========================
# Event Handlers
# =========================

@bot.event
async def on_ready():
    """Event: Called when the bot is ready."""
    load_config()
    load_balances()
    load_xp()
    await bot.tree.sync()
    print(f"{bot.user} is online and commands synced!")

def is_server_allowed(guild_id):
    """Check if the server is allowed to use Nova."""
    if ALLOWED_SERVER_ID is None:
        return True  # No restriction set
    return guild_id == ALLOWED_SERVER_ID

def check_server_restriction():
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(interaction: discord.Interaction):
            guild_id = interaction.guild.id if interaction.guild else None
            if not is_server_allowed(guild_id):
                await interaction.response.send_message(
                    embed=nova_embed("üîí sERVER lOCKED", "nOVA iS lOCKED tO a dIFFERENT sERVER!"),
                    ephemeral=True
                )
                return
            return await func(interaction)
        return wrapper
    return decorator

@bot.event
async def on_message(message):
    """Event: Called on every message. Adds XP and processes commands."""
    if message.author.bot:
        return
    
    # Check if server is allowed
    if not is_server_allowed(message.guild.id):
        return  # Ignore messages from unauthorized servers
    # AFK return logic
    if message.author.id in AFK_STATUS:
        afk = AFK_STATUS.pop(message.author.id)
        since = afk["since"]
        delta = datetime.now(timezone.utc) - since
        mins = int(delta.total_seconds() // 60)
        hours = mins // 60
        mins = mins % 60
        time_str = f"{hours}h {mins}m" if hours else f"{mins}m"
        view = MentionsView(message.author.id)
        await message.channel.send(embed=nova_embed("aFK", f"wELCOME bACK, {message.author.display_name}! yOU wERE gONE fOR {time_str}."), view=view)
    # Notify if mentioning AFK users
    mentioned_ids = [user.id for user in message.mentions]
    for uid in mentioned_ids:
        if uid in AFK_STATUS:
            AFK_STATUS[uid]["mentions"].add(message.author.id)
            afk = AFK_STATUS[uid]
            member = message.guild.get_member(uid)
            if member:
                since = afk["since"]
                delta = datetime.now(timezone.utc) - since
                mins = int(delta.total_seconds() // 60)
                hours = mins // 60
                mins = mins % 60
                time_str = f"{hours}h {mins}m" if hours else f"{mins}m"
                await message.channel.send(embed=nova_embed("aFK", f"{member.display_name} iS aFK: {afk['reason']} ({time_str})"))
    add_xp(message.author.id, random.randint(5, 15))
    # Check if message starts with "nova:" to make Nova say the text
    if message.content.lower().startswith("nova:"):
        # Only allow the owner to use this feature
        if message.author.id == OWNER_ID:
            content = message.content[5:].strip()  # Remove "nova:" and get the rest
            if content:
                # Delete the original message
                await message.delete()
                # Make Nova say the text
                await message.channel.send(content)
        else:
            # If someone else tries to use it, delete their message and warn them
            await message.delete()
            await message.channel.send(f"{message.author.mention}, only the owner can make Nova speak!", delete_after=3)
    await bot.process_commands(message)

@bot.event
async def on_raw_reaction_add(payload):
    """Event: Called when a reaction is added. Handles role assignment and runway emoji forwarding."""
    # --- Runway emoji forwarding ---
    # Only act on server messages
    if payload.guild_id and str(payload.emoji) == "üò≠":
        guild = bot.get_guild(payload.guild_id)
        if guild and RUNWAY_CHANNEL_ID:
            channel = guild.get_channel(payload.channel_id)
            if channel:
                try:
                    message = await channel.fetch_message(payload.message_id)
                    # Count loudly crying emoji reactions
                    for reaction in message.reactions:
                        if (str(reaction.emoji) == "üò≠") and (reaction.count >= 4):
                            # Only forward if not already forwarded (avoid spam)
                            # Optionally, you could keep a set of forwarded message IDs
                            runway_channel = guild.get_channel(RUNWAY_CHANNEL_ID)
                            if runway_channel:
                                embed = nova_embed(
                                    title=f"üò≠ #{message.id}",
                                    description=message.content
                                )
                                embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
                                embed.add_field(name="oRIGINAL cHANNEL", value=channel.mention, inline=True)
                                embed.add_field(name="jUMP tO mESSAGE", value=f"[Click here]({message.jump_url})", inline=True)
                                embed.set_footer(text=f"Message ID: {message.id}")
                                files = []
                                for attachment in message.attachments:
                                    try:
                                        file_data = await attachment.read()
                                        files.append(discord.File(io.BytesIO(file_data), filename=attachment.filename))
                                    except Exception:
                                        continue
                                await runway_channel.send(embed=embed, files=files)
                            break  # Only forward once per event
                except Exception:
                    pass  # Silently ignore errors for this feature
    # --- Role assignment (existing logic) ---
    if payload.message_id != ROLE_MESSAGE_ID:
        return
    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return
    role_name = EMOJI_TO_ROLE.get(str(payload.emoji))
    if not role_name:
        return
    role = discord.utils.get(guild.roles, name=role_name)
    member = guild.get_member(payload.user_id)
    if role and member and not member.bot:
        try:
            await member.add_roles(role)
        except discord.Forbidden:
            print(f"Missing permission to add role {role_name} to {member}")

@bot.event
async def on_raw_reaction_remove(payload):
    """Event: Called when a reaction is removed. Handles role removal."""
    if payload.message_id != ROLE_MESSAGE_ID:
        return
    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return
    role_name = EMOJI_TO_ROLE.get(str(payload.emoji))
    if not role_name:
        return
    role = discord.utils.get(guild.roles, name=role_name)
    member = guild.get_member(payload.user_id)
    if role and member:
        try:
            await member.remove_roles(role)
        except discord.Forbidden:
            print(f"Missing permission to remove role {role_name} from {member}")

# =========================
# Text Commands
# =========================

@bot.command()
async def setmodrole(ctx, role_input):
    """Set the moderator role by ID or mention. Owner only."""
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    # Try to parse role from mention or ID
    role = None
    if role_input.startswith('<@&') and role_input.endswith('>'):
        role_id = int(role_input[3:-1])
        role = ctx.guild.get_role(role_id)
    else:
        try:
            role_id = int(role_input)
            role = ctx.guild.get_role(role_id)
        except ValueError:
            await ctx.send("Invalid role ID or mention format.")
            return
    if not role:
        await ctx.send("Role not found.")
        return
    # Store server-specific mod role
    config[f"mod_role_id_{ctx.guild.id}"] = role.id
    save_config()
    await ctx.send(f"Moderator role set to {role.name} (ID: {role.id}) for this server")

@bot.command()
async def setadminrole(ctx, role_input):
    """Set the admin role by ID or mention. Owner only."""
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    # Try to parse role from mention or ID
    role = None
    if role_input.startswith('<@&') and role_input.endswith('>'):
        role_id = int(role_input[3:-1])
        role = ctx.guild.get_role(role_id)
    else:
        try:
            role_id = int(role_input)
            role = ctx.guild.get_role(role_id)
        except ValueError:
            await ctx.send("Invalid role ID or mention format.")
            return
    if not role:
        await ctx.send("Role not found.")
        return
    # Store server-specific admin role
    config[f"admin_role_id_{ctx.guild.id}"] = role.id
    save_config()
    await ctx.send(f"Admin role set to {role.name} (ID: {role.id}) for this server")

@bot.command()
async def setserver(ctx):
    """Set the allowed server ID. Owner only."""
    global ALLOWED_SERVER_ID
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    ALLOWED_SERVER_ID = ctx.guild.id
    await ctx.send(embed=nova_embed("üîí sERVER lOCKED", f"‚úÖ nOVA iS nOW lOCKED tO tHIS sERVER: {ctx.guild.name} (ID: {ctx.guild.id})"))

@bot.command()
async def removeserverlock(ctx):
    """Remove server restriction. Owner only."""
    global ALLOWED_SERVER_ID
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    ALLOWED_SERVER_ID = None
    await ctx.send("‚úÖ Server restriction removed. Nova can now work in any server.")

@bot.command()
async def serverstatus(ctx):
    """Check current server restriction status. Owner only."""
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the bot owner can use this command.")
        return
    if ALLOWED_SERVER_ID is None:
        await ctx.send("üîì **Server Status:** No restriction set - Nova works in all servers")
    else:
        guild = bot.get_guild(ALLOWED_SERVER_ID)
        guild_name = guild.name if guild else "Unknown Server"
        await ctx.send(f"üîí **Server Status:** Nova is locked to {guild_name} (ID: {ALLOWED_SERVER_ID})")

@bot.command()
async def help(ctx):
    help_text = """
Prefix & Slash Commands:
/balance, /beg, /daily, /work, /pay, /shop, /buy, /inventory
/setbday, /birthday, /birthdays, /today, /welcome, /rules, /ping, /about, /uptime
/marry, /divorce, /adopt, /emancipate, /getemancipated, /familytree, /kiss, /slap, /whoasked, /voguebattle, /afk
/mute, /unmute, /case, /snipe, /edsnipe, /slowmode, /lock, /unlock
/reactionroles, /nicki, /level, /leaderboard, /spotify
"""
    await ctx.send(embed=nova_embed("nOVA'S cOMMANDS", help_text))

@bot.tree.command(name="help", description="Show all Nova commands")
@check_server_restriction()
async def help_slash(interaction: discord.Interaction):
    help_text = """
Prefix & Slash Commands:
/balance, /beg, /daily, /work, /pay, /shop, /buy, /inventory
/setbday, /birthday, /birthdays, /today, /welcome, /rules, /ping, /about, /uptime
/marry, /divorce, /adopt, /emancipate, /getemancipated, /familytree, /kiss, /slap, /whoasked, /voguebattle, /afk
/mute, /unmute, /case, /snipe, /edsnipe, /slowmode, /lock, /unlock
/reactionroles, /nicki, /level, /leaderboard, /spotify
"""
    await interaction.response.send_message(embed=nova_embed("nOVA'S cOMMANDS", help_text))

@bot.command()
async def balance(ctx):
    """Check your dOLLARIANAS balance."""
    bal = get_balance(ctx.author.id)
    await ctx.send(f"{ctx.author.mention}, you have {bal} {CURRENCY_NAME}.")

# Slash command version of balance
@bot.tree.command(name="balance", description="Check your dOLLARIANAS balance (slash command)")
async def balance_slash(interaction: discord.Interaction):
    bal = get_balance(interaction.user.id)
    await interaction.response.send_message(f"{interaction.user.mention}, you have {bal} {CURRENCY_NAME}.")

@bot.command()
async def beg(ctx):
    now = datetime.now(timezone.utc)
    user_id = ctx.author.id
    last = beg_cooldowns.get(user_id)
    if last and now - last < timedelta(minutes=10):
        rem = timedelta(minutes=10) - (now - last)
        await ctx.send(f"{ctx.author.mention}, you can beg again in {str(rem).split('.')[0]}.")
        return
    beg_cooldowns[user_id] = now
    if random.random() < 0.5:
        await ctx.send(f"{ctx.author.mention}, no one gave you anything this time.")
    else:
        amount = random.randint(1, 20)
        change_balance(user_id, amount)
        await ctx.send(f"{ctx.author.mention}, you begged and got {amount} {CURRENCY_NAME}!")

@bot.command()
async def daily(ctx):
    user_id = str(ctx.author.id)
    now = datetime.utcnow()
    last = daily_cooldowns.get(user_id)
    if last and (now - last).total_seconds() < 86400:
        remaining = 86400 - (now - last).total_seconds()
        hours = int(remaining // 3600)
        mins = int((remaining % 3600) // 60)
        await ctx.send(embed=nova_embed("dAILY", f"yOU aLREADY cLAIMED yOUR dAILY! tRY aGAIN iN {hours}h {mins}m."))
        return
    daily_cooldowns[user_id] = now
    change_balance(ctx.author.id, 100)
    await ctx.send(embed=nova_embed("dAILY", f"yOU cLAIMED yOUR dAILY 100 {CURRENCY_NAME}!"))

@bot.tree.command(name="daily", description="Claim daily reward (24h cooldown)")
async def daily_slash(interaction: discord.Interaction):
    user_id = str(interaction.user.id)
    now = datetime.utcnow()
    last = daily_cooldowns.get(user_id)
    if last and (now - last).total_seconds() < 86400:
        remaining = 86400 - (now - last).total_seconds()
        hours = int(remaining // 3600)
        mins = int((remaining % 3600) // 60)
        await interaction.response.send_message(embed=nova_embed("dAILY", f"yOU aLREADY cLAIMED yOUR dAILY! tRY aGAIN iN {hours}h {mins}m."), ephemeral=True)
        return
    daily_cooldowns[user_id] = now
    change_balance(interaction.user.id, 100)
    await interaction.response.send_message(embed=nova_embed("dAILY", f"yOU cLAIMED yOUR dAILY 100 {CURRENCY_NAME}!"))

@bot.command()
async def work(ctx):
    now = datetime.now(timezone.utc)
    user_id = ctx.author.id
    last = work_cooldowns.get(user_id)
    if last and now - last < timedelta(minutes=20):
        remaining = timedelta(minutes=20) - (now - last)
        mins = int(remaining.total_seconds() // 60)
        secs = int(remaining.total_seconds() % 60)
        await ctx.send(embed=nova_embed("wORK", f"yOU'RE tOO tIRED! wAIT {mins}m {secs}s"))
        return
    
    jobs = [
        "cleaning toilets", "flipping burgers", "walking dogs", "delivering pizza",
        "washing cars", "mowing lawns", "babysitting", "tutoring", "painting fences",
        "shoveling snow", "raking leaves", "grocery bagging", "dishwashing"
    ]
    
    job = random.choice(jobs)
    earnings = random.randint(10, 50)
    change_balance(user_id, earnings)
    work_cooldowns[user_id] = now
    
    await ctx.send(embed=nova_embed("wORK", f"yOU wORKED {job} aND eARNED {earnings} dOLLARIANAS!"))

@bot.tree.command(name="work", description="Work a job to earn money (20 min cooldown)")
async def work_slash(interaction: discord.Interaction):
    now = datetime.now(timezone.utc)
    user_id = interaction.user.id
    last = work_cooldowns.get(user_id)
    if last and now - last < timedelta(minutes=20):
        remaining = timedelta(minutes=20) - (now - last)
        mins = int(remaining.total_seconds() // 60)
        secs = int(remaining.total_seconds() % 60)
        await interaction.response.send_message(embed=nova_embed("wORK", f"yOU'RE tOO tIRED! wAIT {mins}m {secs}s"), ephemeral=True)
        return
    
    jobs = [
        "cleaning toilets", "flipping burgers", "walking dogs", "delivering pizza",
        "washing cars", "mowing lawns", "babysitting", "tutoring", "painting fences",
        "shoveling snow", "raking leaves", "grocery bagging", "dishwashing"
    ]
    
    job = random.choice(jobs)
    earnings = random.randint(10, 50)
    change_balance(user_id, earnings)
    work_cooldowns[user_id] = now
    
    await interaction.response.send_message(embed=nova_embed("wORK", f"yOU wORKED {job} aND eARNED {earnings} dOLLARIANAS!"))



@bot.command()
async def impregnate(ctx, partner: discord.Member):
    if partner.bot:
        await ctx.send("You cannot impregnate a bot!")
        return
    if partner.id == ctx.author.id:
        await ctx.send("You cannot impregnate yourself!")
        return
    payer_is_author = random.choice([True, False])
    child_support = 50
    payer = ctx.author if payer_is_author else partner
    receiver = partner if payer_is_author else ctx.author
    if get_balance(payer.id) < child_support:
        await ctx.send(f"{payer.mention} does not have enough {CURRENCY_NAME} to pay child support!")
        return
    change_balance(payer.id, -child_support)
    change_balance(receiver.id, child_support)
    await ctx.send(f"{ctx.author.mention} impregnated {partner.mention}!\n{payer.mention} pays {child_support} {CURRENCY_NAME} as child support to {receiver.mention}.")

@bot.command()
async def nuke(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("nUKE", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        deleted = await ctx.channel.purge(limit=1000)
        await ctx.send(embed=nova_embed("nUKE", f"nUKED {len(deleted)} mESSAGES! üí•"))
        log_case(ctx.guild.id, 'Nuke', ctx.author, ctx.channel, datetime.now(timezone.utc))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("nUKE", "i cAN'T dELETE mESSAGES hERE!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("nUKE", f"eRROR: {str(e)}"))

@bot.command()
async def kick(ctx, member: discord.Member = None, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("kICK", "yOU dON'T hAVE pERMISSION!"))
        return
    if member is None:
        await ctx.send(embed=nova_embed("kICK", "uSAGE: ?kick @user [reason]"))
        return
    try:
        await member.kick(reason=reason)
        await ctx.send(embed=nova_embed("kICK", f"{member.mention} hAS bEEN kICKED! rEASON: {reason}"))
        log_case(ctx.guild.id, 'Kick', member, ctx.channel, datetime.now(timezone.utc))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("kICK", "i cAN'T kICK tHAT uSER!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("kICK", f"eRROR: {str(e)}"))

@bot.command()
async def ban(ctx, member: discord.Member = None, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("bAN", "yOU dON'T hAVE pERMISSION!"))
        return
    if member is None:
        await ctx.send(embed=nova_embed("bAN", "uSAGE: ?ban @user [reason]"))
        return
    try:
        await member.ban(reason=reason)
        await ctx.send(embed=nova_embed("bAN", f"{member.mention} hAS bEEN bANNED! rEASON: {reason}"))
        log_case(ctx.guild.id, 'Ban', member, ctx.channel, datetime.now(timezone.utc))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("bAN", "i cAN'T bAN tHAT uSER!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("bAN", f"eRROR: {str(e)}"))

@bot.command()
async def clear(ctx, amount: int = 5):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("cLEAR", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        deleted = await ctx.channel.purge(limit=amount)
        await ctx.send(embed=nova_embed("cLEAR", f"cLEARED {len(deleted)} mESSAGES!"), delete_after=3)
        log_case(ctx.guild.id, 'Clear', ctx.author, ctx.channel, datetime.now(timezone.utc))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("cLEAR", "i cAN'T dELETE mESSAGES hERE!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("cLEAR", f"eRROR: {str(e)}"))

@bot.command()
async def reactionroles(ctx):
    embed = discord.Embed(title="Choose your gender role by reacting", color=0x00ff00)
    embed.description = (
        "React with the emoji to get the role:\n"
        "üíô for mALE\n"
        "üíó for fEMALE\n"
        "ü§ç for oTHER (AKS)\n"
        "Remove your reaction to remove the role."
    )
    msg = await ctx.send(embed=embed)
    global ROLE_MESSAGE_ID
    ROLE_MESSAGE_ID = msg.id
    for emoji in EMOJI_TO_ROLE:
        await msg.add_reaction(emoji)

@bot.command()
async def nicki(ctx):
    lyrics = [
        "lIKE mJ dOCTOR, tHEY kILLIN mE. pROPOFOl, i kNOW tHEY hOPE i fALL.bUT tELL eM wINNIN iS mY mUTHUFUCKIN pROTOCOL..",
        "mE, nICKI m, i gOT tOO mANY m'S!!!",
        "aYO tONIGHT iS tHE nIGHT tHAT iMMMA gET tWISTED, mYX mOSCATO n vODKA iMA mIX iT.",
        "yOUR fLOW iS sUCH a bORE...",
        "aND i wILL rETIRE wITH tHE cROWN... yES!",
        "bE wHO yOU iS nEVER bE wHO yOU aRENT nEVA."
    ]
    lyric = random.choice(lyrics)
    embed = discord.Embed(
        title="nICKI mINAJ lYRIC",
        description=lyric,
        color=0xff69b4
    )
    embed.set_footer(text="nOVA sAYS: sLAY! üíÖ")
    await ctx.send(embed=embed)

@bot.command()
async def level(ctx):
    data = get_level(ctx.author.id)
    await ctx.send(f"{ctx.author.mention}, you are level {data['level']} with {data['xp']} XP.")

@bot.command()
async def leaderboard(ctx):
    sorted_users = sorted(user_xp.items(), key=lambda x: x[1]['level'] * 100 + x[1]['xp'], reverse=True)
    top = "Top 5 users:\n"
    for i, (user_id, data) in enumerate(sorted_users[:5]):
        member = ctx.guild.get_member(int(user_id))
        if member:
            top += f"{i+1}. {member.display_name} - Level {data['level']}\n"
    await ctx.send(top)

@bot.command()
async def spotify(ctx, member: discord.Member = None):
    member = member or ctx.author
    for activity in member.activities:
        if isinstance(activity, discord.Spotify):
            embed = discord.Embed(
                title=f"{member.display_name} is listening to Spotify!",
                description=f"**{activity.title}** by {activity.artist}\nAlbum: {activity.album}",
                color=0x1DB954
            )
            embed.set_thumbnail(url=activity.album_cover_url)
            embed.add_field(name="Track URL", value=f"[Open in Spotify](https://open.spotify.com/track/{activity.track_id})")
            msg = await ctx.send(embed=embed)
            await msg.add_reaction("üëç")
            await msg.add_reaction("üëé")
            return
    await ctx.send(f"{member.display_name} is not listening to Spotify right now.")

# Load environment variables
load_dotenv()

# Get token from environment variable
TOKEN = os.getenv("TOKEN")
if not TOKEN:
    print("Error: TOKEN not found in .env file")
    exit(1)

# Slash command version of beg
@bot.tree.command(name="beg", description="Beg for money (10 min cooldown)")
async def beg_slash(interaction: discord.Interaction):
    now = datetime.now(timezone.utc)
    user_id = interaction.user.id
    last = beg_cooldowns.get(user_id)
    if last and now - last < timedelta(minutes=10):
        rem = timedelta(minutes=10) - (now - last)
        await interaction.response.send_message(f"{interaction.user.mention}, you can beg again in {str(rem).split('.')[0]}", ephemeral=True)
        return
    beg_cooldowns[user_id] = now
    if random.random() < 0.5:
        await interaction.response.send_message(f"{interaction.user.mention}, no one gave you anything this time.")
    else:
        amount = random.randint(1, 20)
        change_balance(user_id, amount)
        await interaction.response.send_message(f"{interaction.user.mention}, you begged and got {amount} {CURRENCY_NAME}!")



# Slash command version of impregnate
@bot.tree.command(name="impregnate", description="Impregnate someone, child support paid randomly")
@app_commands.describe(partner="The user to impregnate")
async def impregnate_slash(interaction: discord.Interaction, partner: discord.Member):
    if partner.bot:
        await interaction.response.send_message("You cannot impregnate a bot!", ephemeral=True)
        return
    if partner.id == interaction.user.id:
        await interaction.response.send_message("You cannot impregnate yourself!", ephemeral=True)
        return
    payer_is_author = random.choice([True, False])
    child_support = 50
    payer = interaction.user if payer_is_author else partner
    receiver = partner if payer_is_author else interaction.user
    if get_balance(payer.id) < child_support:
        await interaction.response.send_message(f"{payer.mention} does not have enough {CURRENCY_NAME} to pay child support!", ephemeral=True)
        return
    change_balance(payer.id, -child_support)
    change_balance(receiver.id, child_support)
    await interaction.response.send_message(f"{interaction.user.mention} impregnated {partner.mention}!\n{payer.mention} pays {child_support} {CURRENCY_NAME} as child support to {receiver.mention}.")

# Slash command version of nuke
@bot.tree.command(name="nuke", description="Delete all messages in channel (mods only)")
async def nuke_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    await interaction.channel.purge(limit=1000)
    await interaction.response.send_message("boom")
    await interaction.followup.send("Usage: /nuke - Deletes all messages in the channel. Only mods/admins can use this.", ephemeral=True)

# Slash command version of kick
@bot.tree.command(name="kick", description="Kick a member (mods only)")
@app_commands.describe(member="The member to kick", reason="Reason for kick")
async def kick_slash(interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    try:
        await member.kick(reason=reason)
        await interaction.response.send_message(f"Kicked {member} for: {reason}")
        await interaction.followup.send("Usage: /kick @user [reason] - Kicks a member from the server. Only mods/admins can use this.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"Failed to kick: {e}", ephemeral=True)

# Slash command version of ban
@bot.tree.command(name="ban", description="Ban a member (mods only)")
@app_commands.describe(member="The member to ban", reason="Reason for ban")
async def ban_slash(interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    try:
        await member.ban(reason=reason)
        await interaction.response.send_message(f"Banned {member} for: {reason}")
        await interaction.followup.send("Usage: /ban @user [reason] - Bans a member from the server. Only mods/admins can use this.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"Failed to ban: {e}", ephemeral=True)

# Slash command version of reactionroles
@bot.tree.command(name="reactionroles", description="Post gender role selection message")
async def reactionroles_slash(interaction: discord.Interaction):
    embed = discord.Embed(title="Choose your gender role by reacting", color=0x00ff00)
    embed.description = (
        "React with the emoji to get the role:\n"
        "üíô for mALE\n"
        "üíó for fEMALE\n"
        "ü§ç for oTHER (AKS)\n"
        "Remove your reaction to remove the role."
    )
    msg = await interaction.channel.send(embed=embed)
    global ROLE_MESSAGE_ID
    ROLE_MESSAGE_ID = msg.id
    for emoji in EMOJI_TO_ROLE:
        await msg.add_reaction(emoji)
    await interaction.response.send_message("Reaction roles message posted!", ephemeral=True)

# Slash command version of nicki
@bot.tree.command(name="nicki", description="Get a random Nicki Minaj lyric")
async def nicki_slash(interaction: discord.Interaction):
    lyrics = [
        "lIKE mJ dOCTOR, tHEY kILLIN mE. pROPOFOl, i kNOW tHEY hOPE i fALL.bUT tELL eM wINNIN iS mY mUTHUFUCKIN pROTOCOL..",
        "mE, nICKI m, i gOT tOO mANY wINS!!!",
        "aYO tONIGHT iS tHE nIGHT tHAT iMMMA gET tWISTED, mYX mOSCATO n vODKA iMA mIX iT.",
        "yOUR fLOW iS sUCH a bORE...",
        "aND i wILL rETIRE wITH tHE cROWN... yES!",
        "bE wHO yOU iS nEVER bE wHO yOU aRENT nEVA."
    ]
    await interaction.response.send_message(random.choice(lyrics))

# Slash command version of level
@bot.tree.command(name="level", description="Show your level and XP")
async def level_slash(interaction: discord.Interaction):
    data = get_level(interaction.user.id)
    await interaction.response.send_message(f"{interaction.user.mention}, you are level {data['level']} with {data['xp']} XP.")

# Slash command version of leaderboard
@bot.tree.command(name="leaderboard", description="Show top 5 users by level")
async def leaderboard_slash(interaction: discord.Interaction):
    sorted_users = sorted(user_xp.items(), key=lambda x: x[1]['level'] * 100 + x[1]['xp'], reverse=True)
    top = "Top 5 users:\n"
    for i, (user_id, data) in enumerate(sorted_users[:5]):
        guild = interaction.guild
        member = guild.get_member(int(user_id)) if guild else None
        if member:
            top += f"{i+1}. {member.display_name} - Level {data['level']}\n"
    await interaction.response.send_message(top)

# Slash command version of spotify
@bot.tree.command(name="spotify", description="Show Spotify status for a user (or yourself)")
@app_commands.describe(member="The member to check (optional)")
async def spotify_slash(interaction: discord.Interaction, member: discord.Member = None):
    member = member or interaction.user
    # Get the full member object from the guild
    if interaction.guild:
        member = interaction.guild.get_member(member.id)
    if not member:
        await interaction.response.send_message("Could not find that member.", ephemeral=True)
        return
    for activity in member.activities:
        if isinstance(activity, discord.Spotify):
            embed = discord.Embed(
                title=f"{member.display_name} is listening to Spotify!",
                description=f"**{activity.title}** by {activity.artist}\nAlbum: {activity.album}",
                color=0x1DB954
            )
            embed.set_thumbnail(url=activity.album_cover_url)
            embed.add_field(name="Track URL", value=f"[Open in Spotify](https://open.spotify.com/track/{activity.track_id})")
            msg = await interaction.channel.send(embed=embed)
            await msg.add_reaction("üëç")
            await msg.add_reaction("üëé")
            return
    await interaction.response.send_message(f"{member.display_name} is not listening to Spotify right now.")

# =========================
# Command Stubs for All Requested Features
# =========================

start_time = time.time()

# Utility
@bot.command()
async def ping(ctx):
    """Checks if Nova is online and returns latency."""
    await ctx.send(f'Pong! üèì Latency: {round(bot.latency * 1000)}ms')

@bot.command()
async def about(ctx):
    """Info about Nova."""
    embed = discord.Embed(
        title="aBOUT nOVA",
        description="i'M nOVA, yOUR aLL-iN-oNE dISCORD bOT. sASS, hELP, aND cHAOS iN oNE pACKAGE!",
        color=0xff69b4
    )
    embed.set_footer(text="cREATED bY mOTHER üíÖ")
    await ctx.send(embed=embed)

@bot.command()
async def uptime(ctx):
    """Shows how long Nova has been running."""
    up = int(time.time() - start_time)
    hours, remainder = divmod(up, 3600)
    minutes, seconds = divmod(remainder, 60)
    await ctx.send(f"Uptime: {hours}h {minutes}m {seconds}s")

@bot.command()
async def setprefix(ctx, *, new_prefix=None):
    """Set a custom prefix for this server (server owner only)."""
    if ctx.author.id != ctx.guild.owner_id and ctx.author.id != OWNER_ID:
        await ctx.send(embed=nova_embed("sET pREFIX", "oNLY tHE sERVER oWNER cAN cHANGE tHE pREFIX!"))
        return
    
    if new_prefix is None:
        current_prefix = get_server_config(ctx.guild.id, "prefix") or "?"
        await ctx.send(embed=nova_embed("cURRENT pREFIX", f"tHE cURRENT pREFIX fOR tHIS sERVER iS: `{current_prefix}`"))
        return
    
    if len(new_prefix) > 5:
        await ctx.send(embed=nova_embed("sET pREFIX", "pREFIX cAN'T bE lONGER tHAN 5 cHARACTERS!"))
        return
    
    set_server_config(ctx.guild.id, "prefix", new_prefix)
    save_config()
    await ctx.send(embed=nova_embed("sET pREFIX", f"pREFIX cHANGED tO: `{new_prefix}`"))

@bot.command()
async def ban(ctx, member: discord.Member = None, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("bAN", "yOU dON'T hAVE pERMISSION!"))
        return
    if member is None:
        await ctx.send(embed=nova_embed("bAN", "uSAGE: ?ban @user [reason]"))
        return
    try:
        await member.ban(reason=reason)
        await ctx.send(embed=nova_embed("bAN", f"{member.mention} hAS bEEN bANNED! rEASON: {reason}"))
        log_case(ctx.guild.id, 'Ban', member, ctx.channel, datetime.now(timezone.utc))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("bAN", "i cAN'T bAN tHAT uSER!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("bAN", f"eRROR: {str(e)}"))

@bot.command()
async def kick(ctx, member: discord.Member = None, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("kICK", "yOU dON'T hAVE pERMISSION!"))
        return
    if member is None:
        await ctx.send(embed=nova_embed("kICK", "uSAGE: ?kick @user [reason]"))
        return
    try:
        await member.kick(reason=reason)
        await ctx.send(embed=nova_embed("kICK", f"{member.mention} hAS bEEN kICKED! rEASON: {reason}"))
        log_case(ctx.guild.id, 'Kick', member, ctx.channel, datetime.now(timezone.utc))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("kICK", "i cAN'T kICK tHAT uSER!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("kICK", f"eRROR: {str(e)}"))

@bot.command()
async def clear(ctx, amount: int = 5):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("cLEAR", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        deleted = await ctx.channel.purge(limit=amount)
        await ctx.send(embed=nova_embed("cLEAR", f"cLEARED {len(deleted)} mESSAGES!"), delete_after=3)
        log_case(ctx.guild.id, 'Clear', ctx.author, ctx.channel, datetime.now(timezone.utc))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("cLEAR", "i cAN'T dELETE mESSAGES hERE!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("cLEAR", f"eRROR: {str(e)}"))

@bot.command()
async def afk(ctx, *, reason: str = "aFK"):
    AFK_STATUS[ctx.author.id] = {"reason": reason, "since": datetime.now(timezone.utc), "mentions": set()}
    await ctx.send(embed=nova_embed("aFK", f"{ctx.author.display_name} iS nOW aFK: {reason}"))

@bot.command()
async def warn(ctx, member: discord.Member = None, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("wARN", "yOU dON'T hAVE pERMISSION!"))
        return
    if member is None:
        await ctx.send(embed=nova_embed("wARN", "uSAGE: ?warn @user [reason]"))
        return
    
    # Add warning to infractions
    if ctx.guild.id not in INFRACTIONS:
        INFRACTIONS[ctx.guild.id] = {}
    if member.id not in INFRACTIONS[ctx.guild.id]:
        INFRACTIONS[ctx.guild.id][member.id] = []
    
    warning = {
        "type": "warning",
        "reason": reason,
        "moderator": ctx.author.id,
        "date": datetime.now(timezone.utc).isoformat()
    }
    
    INFRACTIONS[ctx.guild.id][member.id].append(warning)
    save_infractions()
    
    await ctx.send(embed=nova_embed("wARN", f"{member.mention} hAS bEEN wARNED! rEASON: {reason}"))
    log_case(ctx.guild.id, 'Warn', member, ctx.channel, datetime.now(timezone.utc))

@bot.command()
async def nuke(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("nUKE", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        deleted = await ctx.channel.purge(limit=1000)
        await ctx.send(embed=nova_embed("nUKE", f"nUKED {len(deleted)} mESSAGES! üí•"))
        log_case(ctx.guild.id, 'Nuke', ctx.author, ctx.channel, datetime.now(timezone.utc))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("nUKE", "i cAN'T dELETE mESSAGES hERE!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("nUKE", f"eRROR: {str(e)}"))

@bot.command()
async def spotify(ctx, member: discord.Member = None):
    """Show Spotify status for a user"""
    if member is None:
        member = ctx.author
    
    for activity in member.activities:
        if isinstance(activity, discord.Spotify):
            embed = discord.Embed(title=f"üéµ {member.display_name}'s Spotify", color=0x1db954)
            embed.add_field(name="Song", value=activity.title, inline=False)
            embed.add_field(name="Artist", value=activity.artist, inline=True)
            embed.add_field(name="Album", value=activity.album, inline=True)
            embed.set_thumbnail(url=activity.album_cover_url)
            embed.add_field(name="Track URL", value=f"[Open in Spotify](https://open.spotify.com/track/{activity.track_id})")
            msg = await ctx.send(embed=embed)
            await msg.add_reaction("üëç")
            await msg.add_reaction("üëé")
            return
    await ctx.send(f"{member.display_name} is not listening to Spotify right now.")

@bot.command(name="fm")
async def fm(ctx, member: discord.Member = None):
    """Show Spotify status for a user (alias for ?spotify)"""
    await spotify(ctx, member)

# Relationship/Roleplay
@bot.command()
async def divorce(ctx, user: discord.Member):
    relationships = load_relationships()
    key = f"married:{ctx.author.id}"
    if key not in relationships or relationships[key] != user.id:
        await ctx.send(embed=nova_embed("dIVORCE", "yOU'RE nOT mARRIED tO tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await ctx.send(embed=nova_embed("dIVORCE", f"üíî {ctx.author.display_name} dIVORCED {user.display_name}!"))

@bot.tree.command(name="divorce", description="End your marriage with a user")
async def divorce_slash(interaction: discord.Interaction, user: discord.Member):
    relationships = load_relationships()
    key = f"married:{interaction.user.id}"
    if key not in relationships or relationships[key] != user.id:
        await interaction.response.send_message(embed=nova_embed("dIVORCE", "yOU'RE nOT mARRIED tO tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await interaction.response.send_message(embed=nova_embed("dIVORCE", f"üíî {interaction.user.display_name} dIVORCED {user.display_name}!"))

@bot.command()
async def marry(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("mARRY", "yOU cAN'T mARRY yOURSELF, bABY!"))
        return
    relationships = load_relationships()
    key = f"married:{ctx.author.id}"
    if key in relationships:
        await ctx.send(embed=nova_embed("mARRY", "yOU'RE aLREADY mARRIED!"))
        return
    if user.id in pending_marriages:
        await ctx.send(embed=nova_embed("mARRY", "tHAT uSER aLREADY hAS a pENDING pROPOSAL!"))
        return
    pending_marriages[user.id] = ctx.author.id
    await ctx.send(embed=nova_embed("mARRY", f"üíç {ctx.author.display_name} pROPOSED tO {user.display_name}! {user.mention}, tYPE `?acceptmarry` tO aCCEPT. yOU hAVE 30 sECONDS!"))
    async def expire():
        await asyncio.sleep(30)
        if user.id in pending_marriages and pending_marriages[user.id] == ctx.author.id:
            del pending_marriages[user.id]
            await ctx.send(embed=nova_embed("mARRY", f"{user.display_name} dIDN'T rESPOND iN tIME! tRY aGAIN lATER."))
    ctx.bot.loop.create_task(expire())

@bot.tree.command(name="marry", description="Send a marriage proposal to a user")
@app_commands.describe(user="The user to marry")
async def marry_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("mARRY", "yOU cAN'T mARRY yOURSELF, bABY!"))
        return
    relationships = load_relationships()
    key = f"married:{interaction.user.id}"
    if key in relationships:
        await interaction.response.send_message(embed=nova_embed("mARRY", "yOU'RE aLREADY mARRIED!"))
        return
    if user.id in pending_marriages:
        await interaction.response.send_message(embed=nova_embed("mARRY", "tHAT uSER aLREADY hAS a pENDING pROPOSAL!"))
        return
    pending_marriages[user.id] = interaction.user.id
    await interaction.response.send_message(embed=nova_embed("mARRY", f"üíç {interaction.user.display_name} pROPOSED tO {user.display_name}! {user.mention}, uSE `/acceptmarry` tO aCCEPT. yOU hAVE 30 sECONDS!"))
    async def expire():
        await asyncio.sleep(30)
        if user.id in pending_marriages and pending_marriages[user.id] == interaction.user.id:
            del pending_marriages[user.id]
            await interaction.followup.send(embed=nova_embed("mARRY", f"{user.display_name} dIDN'T rESPOND iN tIME! tRY aGAIN lATER."))
    interaction.client.loop.create_task(expire())

@bot.command()
async def adopt(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("aDOPT", "yOU cAN'T aDOPT yOURSELF!"))
        return
    relationships = load_relationships()
    
    # Check if user is already adopted by someone
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == user.id:
            adopter_id = int(key.split(":")[1])
            adopter = ctx.guild.get_member(adopter_id)
            if adopter:
                await ctx.send(embed=nova_embed("aDOPT", f"{user.display_name} iS aLREADY aDOPTED bY {adopter.display_name}!"))
                return
    
    if user.id in pending_adoptions:
        await ctx.send(embed=nova_embed("aDOPT", "tHAT uSER aLREADY hAS a pENDING aDOPTION!"))
        return
    pending_adoptions[user.id] = ctx.author.id
    view = AdoptionView(ctx.author.id, user.id)
    await ctx.send(embed=nova_embed("aDOPT", f"üçº {ctx.author.display_name} wANTS tO aDOPT {user.display_name}! {user.mention}, cLICK tHE bUTTONS bELOW!"), view=view)

@bot.tree.command(name="adopt", description="Adopt a user (fun roleplay)")
@app_commands.describe(user="The user to adopt")
async def adopt_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("aDOPT", "yOU cAN'T aDOPT yOURSELF!"))
        return
    relationships = load_relationships()
    
    # Check if user is already adopted by someone
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == user.id:
            adopter_id = int(key.split(":")[1])
            adopter = interaction.guild.get_member(adopter_id)
            if adopter:
                await interaction.response.send_message(embed=nova_embed("aDOPT", f"{user.display_name} iS aLREADY aDOPTED bY {adopter.display_name}!"))
                return
    
    if user.id in pending_adoptions:
        await interaction.response.send_message(embed=nova_embed("aDOPT", "tHAT uSER aLREADY hAS a pENDING aDOPTION!"))
        return
    pending_adoptions[user.id] = interaction.user.id
    view = AdoptionView(interaction.user.id, user.id)
    await interaction.response.send_message(embed=nova_embed("aDOPT", f"üçº {interaction.user.display_name} wANTS tO aDOPT {user.display_name}! {user.mention}, cLICK tHE bUTTONS bELOW!"), view=view)

class AdoptionView(View):
    def __init__(self, adopter_id, adoptee_id):
        super().__init__(timeout=30)
        self.adopter_id = adopter_id
        self.adoptee_id = adoptee_id

    @discord.ui.button(label="aCCEPT", style=discord.ButtonStyle.green, emoji="‚úÖ")
    async def accept_adoption(self, interaction: discord.Interaction, button: Button):
        if interaction.user.id != self.adoptee_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION iS nOT fOR yOU!"), ephemeral=True)
            return
        
        if self.adoptee_id not in pending_adoptions or pending_adoptions[self.adoptee_id] != self.adopter_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION hAS eXPIRED!"), ephemeral=True)
            return
        
        adopter = interaction.guild.get_member(self.adopter_id)
        if not adopter:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "aDOPTER nOT fOUND!"), ephemeral=True)
            return
        
        relationships = load_relationships()
        key = f"adopted:{self.adopter_id}"
        relationships[key] = self.adoptee_id
        save_relationships(relationships)
        
        del pending_adoptions[self.adoptee_id]
        
        # Disable all buttons
        for child in self.children:
            child.disabled = True
        
        await interaction.response.edit_message(
            embed=nova_embed("aDOPTION aCCEPTED", f"üçº {interaction.user.display_name} hAS bEEN aDOPTED bY {adopter.display_name}!"),
            view=self
        )

    @discord.ui.button(label="dECLINE", style=discord.ButtonStyle.red, emoji="‚ùå")
    async def decline_adoption(self, interaction: discord.Interaction, button: Button):
        if interaction.user.id != self.adoptee_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION iS nOT fOR yOU!"), ephemeral=True)
            return
        
        if self.adoptee_id not in pending_adoptions or pending_adoptions[self.adoptee_id] != self.adopter_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION hAS eXPIRED!"), ephemeral=True)
            return
        
        adopter = interaction.guild.get_member(self.adopter_id)
        adopter_name = adopter.display_name if adopter else "Unknown"
        
        del pending_adoptions[self.adoptee_id]
        
        # Disable all buttons
        for child in self.children:
            child.disabled = True
        
        await interaction.response.edit_message(
            embed=nova_embed("aDOPTION dECLINED", f"üòî {interaction.user.display_name} dECLINED tHE aDOPTION fROM {adopter_name}!"),
            view=self
        )

@bot.command()
async def emancipate(ctx, user: discord.Member):
    relationships = load_relationships()
    key = f"adopted:{ctx.author.id}"
    if key not in relationships or relationships[key] != user.id:
        await ctx.send(embed=nova_embed("eMANCIPATE", "yOU hAVEN'T aDOPTED tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await ctx.send(embed=nova_embed("eMANCIPATE", f"{user.display_name} hAS bEEN eMANCIPATED bY {ctx.author.display_name}!"))

@bot.tree.command(name="emancipate", description="Free a previously adopted user")
async def emancipate_slash(interaction: discord.Interaction, user: discord.Member):
    relationships = load_relationships()
    key = f"adopted:{interaction.user.id}"
    if key not in relationships or relationships[key] != user.id:
        await interaction.response.send_message(embed=nova_embed("eMANCIPATE", "yOU hAVEN'T aDOPTED tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await interaction.response.send_message(embed=nova_embed("eMANCIPATE", f"{user.display_name} hAS bEEN eMANCIPATED bY {interaction.user.display_name}!"))

@bot.command()
async def getemancipated(ctx):
    relationships = load_relationships()
    
    # Find if user is adopted by someone
    adopted_by = None
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == ctx.author.id:
            adopter_id = int(key.split(":")[1])
            adopted_by = ctx.guild.get_member(adopter_id)
            break
    
    if not adopted_by:
        await ctx.send(embed=nova_embed("gET eMANCIPATED", "yOU aREN'T aDOPTED bY aNYONE!"))
        return
    
    # Remove the adoption
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == ctx.author.id:
            del relationships[key]
            break
    
    save_relationships(relationships)
    await ctx.send(embed=nova_embed("gET eMANCIPATED", f"üèõÔ∏è {ctx.author.display_name} hAS bEEN eMANCIPATED fROM {adopted_by.display_name}! yOU aRE nOW fREE!"))

@bot.tree.command(name="getemancipated", description="Emancipate yourself from your adoptive parent")
async def getemancipated_slash(interaction: discord.Interaction):
    relationships = load_relationships()
    
    # Find if user is adopted by someone
    adopted_by = None
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == interaction.user.id:
            adopter_id = int(key.split(":")[1])
            adopted_by = interaction.guild.get_member(adopter_id)
            break
    
    if not adopted_by:
        await interaction.response.send_message(embed=nova_embed("gET eMANCIPATED", "yOU aREN'T aDOPTED bY aNYONE!"), ephemeral=True)
        return
    
    # Remove the adoption
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == interaction.user.id:
            del relationships[key]
            break
    
    save_relationships(relationships)
    await interaction.response.send_message(embed=nova_embed("gET eMANCIPATED", f"üèõÔ∏è {interaction.user.display_name} hAS bEEN eMANCIPATED fROM {adopted_by.display_name}! yOU aRE nOW fREE!"))

@bot.command()
async def familytree(ctx, user: discord.Member = None):
    user = user or ctx.author
    relationships = load_relationships()
    
    # Find spouse
    spouse = None
    for key, value in relationships.items():
        if key.startswith("married:"):
            user_id = int(key.split(":")[1])
            if user_id == user.id:
                spouse = ctx.guild.get_member(value)
                break
            elif value == user.id:
                spouse = ctx.guild.get_member(user_id)
                break
    
    # Find children (people this user has adopted)
    children = []
    for key, value in relationships.items():
        if key.startswith("adopted:"):
            adopter_id = int(key.split(":")[1])
            if adopter_id == user.id:
                child = ctx.guild.get_member(value)
                if child:
                    children.append(child)
    
    # Find parents (people who adopted this user)
    parents = []
    for key, value in relationships.items():
        if key.startswith("adopted:"):
            if value == user.id:
                adopter_id = int(key.split(":")[1])
                parent = ctx.guild.get_member(adopter_id)
                if parent:
                    parents.append(parent)
    
    # Build family tree
    tree = f"**fAMILY tREE fOR {user.display_name}**\n\n"
    
    if spouse:
        tree += f"üíç **sPOUSE:** {spouse.display_name}\n"
    else:
        tree += "üíç **sPOUSE:** nONE\n"
    
    if children:
        tree += f"üë∂ **cHILDREN:** {', '.join([child.display_name for child in children])}\n"
    else:
        tree += "üë∂ **cHILDREN:** nONE\n"
    
    if parents:
        tree += f"üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **pARENTS:** {', '.join([parent.display_name for parent in parents])}\n"
    else:
        tree += "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **pARENTS:** nONE\n"
    
    await ctx.send(embed=nova_embed("fAMILY tREE", tree))

@bot.tree.command(name="familytree", description="Show family tree for a user")
@app_commands.describe(user="The user to check (optional - shows your own)")
async def familytree_slash(interaction: discord.Interaction, user: discord.Member = None):
    user = user or interaction.user
    relationships = load_relationships()
    
    # Find spouse
    spouse = None
    for key, value in relationships.items():
        if key.startswith("married:"):
            user_id = int(key.split(":")[1])
            if user_id == user.id:
                spouse = interaction.guild.get_member(value)
                break
            elif value == user.id:
                spouse = interaction.guild.get_member(user_id)
                break
    
    # Find children (people this user has adopted)
    children = []
    for key, value in relationships.items():
        if key.startswith("adopted:"):
            adopter_id = int(key.split(":")[1])
            if adopter_id == user.id:
                child = interaction.guild.get_member(value)
                if child:
                    children.append(child)
    
    # Find parents (people who adopted this user)
    parents = []
    for key, value in relationships.items():
        if key.startswith("adopted:"):
            if value == user.id:
                adopter_id = int(key.split(":")[1])
                parent = interaction.guild.get_member(adopter_id)
                if parent:
                    parents.append(parent)
    
    # Build family tree
    tree = f"**fAMILY tREE fOR {user.display_name}**\n\n"
    
    if spouse:
        tree += f"üíç **sPOUSE:** {spouse.display_name}\n"
    else:
        tree += "üíç **sPOUSE:** nONE\n"
    
    if children:
        tree += f"üë∂ **cHILDREN:** {', '.join([child.display_name for child in children])}\n"
    else:
        tree += "üë∂ **cHILDREN:** nONE\n"
    
    if parents:
        tree += f"üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **pARENTS:** {', '.join([parent.display_name for parent in parents])}\n"
    else:
        tree += "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **pARENTS:** nONE\n"
    
    await interaction.response.send_message(embed=nova_embed("fAMILY tREE", tree))

@bot.command()
async def kiss(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("kISS", "yOU cAN'T kISS yOURSELF!"))
        return
    responses = [
        f"üíã {ctx.author.mention} kISSES {user.mention} gENTLY!",
        f"üòò {ctx.author.mention} gIVES {user.mention} a sWEET kISS!",
        f"üíï {ctx.author.mention} pLANTS a kISS oN {user.display_name}'s cHEEK!",
        f"ü•∞ {ctx.author.mention} kISSES {user.display_name} pASSIONATELY!"
    ]
    await ctx.send(embed=nova_embed("kISS", random.choice(responses)))

@bot.tree.command(name="kiss", description="Kiss a user (fun roleplay)")
@app_commands.describe(user="The user to kiss")
async def kiss_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("kISS", "yOU cAN'T kISS yOURSELF!"))
        return
    responses = [
        f"ÔøΩÔøΩ {interaction.user.mention} kISSES {user.mention} gENTLY!",
        f"üòò {interaction.user.mention} gIVES {user.mention} a sWEET kISS!",
        f"üíï {interaction.user.mention} pLANTS a kISS oN {user.display_name}'s cHEEK!",
        f"ü•∞ {interaction.user.mention} kISSES {user.display_name} pASSIONATELY!"
    ]
    await interaction.response.send_message(embed=nova_embed("kISS", random.choice(responses)))

@bot.command()
async def slap(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("sLAP", "yOU cAN'T sLAP yOURSELF!"))
        return
    responses = [
        f"üëã {ctx.author.mention} sLAPS {user.mention} aCROSS tHE fACE!",
        f"üí• {ctx.author.mention} gIVES {user.mention} a hARD sLAP!",
        f"ü§ö {ctx.author.mention} sLAPS {user.mention} wITH a tOWEL!",
        f"üí¢ {ctx.author.mention} sLAPS {user.display_name} fOR bEING nAUGHTY!"
    ]
    await ctx.send(embed=nova_embed("sLAP", random.choice(responses)))

@bot.tree.command(name="slap", description="Slap a user (fun roleplay)")
@app_commands.describe(user="The user to slap")
async def slap_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("sLAP", "yOU cAN'T sLAP yOURSELF!"))
        return
    responses = [
        f"ÔøΩÔøΩ {interaction.user.mention} sLAPS {user.mention} aCROSS tHE fACE!",
        f"üí• {interaction.user.mention} gIVES {user.mention} a hARD sLAP!",
        f"ü§ö {interaction.user.mention} sLAPS {user.mention} wITH a tOWEL!",
        f"üí¢ {interaction.user.mention} sLAPS {user.display_name} fOR bEING nAUGHTY!"
    ]
    await interaction.response.send_message(embed=nova_embed("sLAP", random.choice(responses)))

@bot.command()
async def whoasked(ctx, user: discord.Member = None):
    if not user:
        await ctx.send(embed=nova_embed("wHO aSKED", "nOBODY aSKED fOR yOUR oPINION!"))
        return
    responses = [
        f"ü§î wHO aSKED {user.display_name}?",
        f"‚ùì dID aNYONE aSK {user.display_name}?",
        f"ü§∑‚Äç‚ôÄÔ∏è nOBODY aSKED {user.display_name}!",
        f"üôÑ wHO eVEN aSKED {user.display_name}?"
    ]
    await ctx.send(embed=nova_embed("wHO aSKED", random.choice(responses)))

@bot.tree.command(name="whoasked", description="Ask who asked for someone's opinion")
@app_commands.describe(user="The user to question (optional)")
async def whoasked_slash(interaction: discord.Interaction, user: discord.Member = None):
    if not user:
        await interaction.response.send_message(embed=nova_embed("wHO aSKED", "nOBODY aSKED fOR yOUR oPINION!"))
        return
    responses = [
        f"ü§î wHO aSKED {user.display_name}?",
        f"‚ùì dID aNYONE aSK {user.display_name}?",
        f"ü§∑‚Äç‚ôÄÔ∏è nOBODY aSKED {user.display_name}!",
        f"üôÑ wHO eVEN aSKED {user.display_name}?"
    ]
    await interaction.response.send_message(embed=nova_embed("wHO aSKED", random.choice(responses)))

@bot.command()
async def voguebattle(ctx, user: discord.Member):
    if user.id == ctx.author.id:
        await ctx.send(embed=nova_embed("vOGUE bATTLE", "yOU cAN'T bATTLE yOURSELF!"))
        return
    
    # Vogue battle moves
    moves = [
        "DUCK WALK",
        "DEATH DROP", 
        "HAND PERFORMANCE",
        "CATWALK",
        "FACE",
        "LIPSYNC",
        "SHABLAM",
        "FIERCE POSE",
        "DIAMOND POSE",
        "STAR POSE"
    ]
    
    # Battle results
    results = [
        f"üèÜ **{ctx.author.display_name}** WINS THE VOGUE BATTLE! {user.display_name} COULDN'T HANDLE THE FIERCENESS!",
        f"üíÄ **{user.display_name}** DESTROYS {ctx.author.display_name} IN THE BATTLE! TOTAL ANNIHILATION!",
        f"ü§ù IT'S A TIE! BOTH **{ctx.author.display_name}** AND **{user.display_name}** ARE EQUALLY FIERCE!",
        f"üî• **{ctx.author.display_name}** SERVES FACE AND WINS! {user.display_name} IS SHOOK!",
        f"üíÖ **{user.display_name}** TURNS IT OUT AND WINS! {ctx.author.display_name} IS GAGGED!"
    ]
    
    # Random moves for both users
    author_move = random.choice(moves)
    opponent_move = random.choice(moves)
    
    # Determine winner (random with slight bias to author)
    winner = random.choice(results)
    
    battle_text = f"**VOGUE BATTLE: {ctx.author.display_name} vs {user.display_name}**\n\n"
    battle_text += f"üíÉ **{ctx.author.display_name}**: {author_move}\n"
    battle_text += f"üï∫ **{user.display_name}**: {opponent_move}\n\n"
    battle_text += f"**RESULT:** {winner}"
    
    await ctx.send(embed=nova_embed("vOGUE bATTLE", battle_text))

@bot.tree.command(name="voguebattle", description="Start a vogue battle with another user")
@app_commands.describe(user="The user to battle")
async def voguebattle_slash(interaction: discord.Interaction, user: discord.Member):
    if user.id == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("vOGUE bATTLE", "yOU cAN'T bATTLE yOURSELF!"))
        return
    
    # Vogue battle moves
    moves = [
        "DUCK WALK",
        "DEATH DROP", 
        "HAND PERFORMANCE",
        "CATWALK",
        "FACE",
        "LIPSYNC",
        "SHABLAM",
        "FIERCE POSE",
        "DIAMOND POSE",
        "STAR POSE"
    ]
    
    # Battle results
    results = [
        f"üèÜ **{interaction.user.display_name}** WINS THE VOGUE BATTLE! {user.display_name} COULDN'T HANDLE THE FIERCENESS!",
        f"üíÄ **{user.display_name}** DESTROYS {interaction.user.display_name} IN THE BATTLE! TOTAL ANNIHILATION!",
        f"ü§ù IT'S A TIE! BOTH **{interaction.user.display_name}** AND **{user.display_name}** ARE EQUALLY FIERCE!",
        f"üî• **{interaction.user.display_name}** SERVES FACE AND WINS! {user.display_name} IS SHOOK!",
        f"üíÖ **{user.display_name}** TURNS IT OUT AND WINS! {interaction.user.display_name} IS GAGGED!"
    ]
    
    # Random moves for both users
    author_move = random.choice(moves)
    opponent_move = random.choice(moves)
    
    # Determine winner (random with slight bias to author)
    winner = random.choice(results)
    
    battle_text = f"**VOGUE BATTLE: {interaction.user.display_name} vs {user.display_name}**\n\n"
    battle_text += f"üíÉ **{interaction.user.display_name}**: {author_move}\n"
    battle_text += f"üï∫ **{user.display_name}**: {opponent_move}\n\n"
    battle_text += f"**RESULT:** {winner}"
    
    await interaction.response.send_message(embed=nova_embed("vOGUE BATTLE", battle_text))
@bot.command()
async def lock(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("lOCK", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        await ctx.channel.set_permissions(ctx.guild.default_role, send_messages=False)
        await ctx.send(embed=nova_embed("lOCK", f"üîí {ctx.channel.mention} hAS bEEN lOCKED!"))
        await ctx.send("Usage: ?lock - Locks the current channel. Only mods/admins can use this.")
    except Exception:
        await ctx.send(embed=nova_embed("lOCK", "cOULD nOT lOCK tHE cHANNEL!"))

@bot.tree.command(name="lock", description="Lock the current channel (mods only)")
async def lock_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("lOCK", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        await interaction.channel.set_permissions(interaction.guild.default_role, send_messages=False)
        await interaction.response.send_message(embed=nova_embed("lOCK", f"üîí {interaction.channel.mention} hAS bEEN lOCKED!"))
        await interaction.followup.send("Usage: /lock - Locks the current channel. Only mods/admins can use this.", ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("lOCK", "cOULD nOT lOCK tHE cHANNEL!"), ephemeral=True)

@bot.command()
async def unlock(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("uNLOCK", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        await ctx.channel.set_permissions(ctx.guild.default_role, send_messages=None)
        await ctx.send(embed=nova_embed("uNLOCK", f"üîì {ctx.channel.mention} hAS bEEN uNLOCKED!"))
        await ctx.send("Usage: ?unlock - Unlocks the current channel. Only mods/admins can use this.")
    except Exception:
        await ctx.send(embed=nova_embed("uNLOCK", "cOULD nOT uNLOCK tHE cHANNEL!"))

@bot.tree.command(name="unlock", description="Unlock the current channel (mods only)")
async def unlock_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("uNLOCK", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        await interaction.channel.set_permissions(interaction.guild.default_role, send_messages=None)
        await interaction.response.send_message(embed=nova_embed("uNLOCK", f"üîì {interaction.channel.mention} hAS bEEN uNLOCKED!"))
        await interaction.followup.send("Usage: /unlock - Unlocks the current channel. Only mods/admins can use this.", ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("uNLOCK", "cOULD nOT uNLOCK tHE cHANNEL!"), ephemeral=True)

# Pending adoptions
pending_adoptions = {}  # user_id: adopter_id

@bot.command()
async def afk(ctx, *, reason: str = "aFK"):
    AFK_STATUS[ctx.author.id] = {"reason": reason, "since": datetime.now(timezone.utc), "mentions": set()}
    await ctx.send(embed=nova_embed("aFK", f"{ctx.author.display_name} iS nOW aFK: {reason}"))
    await ctx.send("Usage: ?afk [reason] - Sets your AFK status. Mentioning you will notify the sender. Use any message to remove AFK.")

@bot.tree.command(name="afk", description="Set your AFK status with an optional message")
@app_commands.describe(reason="Why are you AFK?")
async def afk_slash(interaction: discord.Interaction, reason: str = "aFK"):
    AFK_STATUS[interaction.user.id] = {"reason": reason, "since": datetime.now(timezone.utc), "mentions": set()}
    await interaction.response.send_message(embed=nova_embed("aFK", f"{interaction.user.display_name} iS nOW aFK: {reason}"), ephemeral=True)
    await interaction.followup.send("Usage: /afk [reason] - Sets your AFK status. Mentioning you will notify the sender. Use any message to remove AFK.", ephemeral=True)

class MentionsView(View):
    def __init__(self, user_id):
        super().__init__(timeout=60)
        self.user_id = user_id

    @discord.ui.button(label="cHECK mENTIONS", style=discord.ButtonStyle.primary)
    async def check_mentions(self, interaction: discord.Interaction, button: Button):
        afk = AFK_STATUS.get(self.user_id)
        if not afk or not afk["mentions"]:
            await interaction.response.send_message(embed=nova_embed("aFK", "nO oNE mENTIONED yOU wHILE yOU wERE aWAY!"), ephemeral=True)
            return
        guild = interaction.guild
        names = []
        for uid in afk["mentions"]:
            member = guild.get_member(uid)
            if member:
                names.append(member.display_name)
        if names:
            await interaction.response.send_message(embed=nova_embed("aFK mENTIONS", f"yOU wERE mENTIONED bY: {', '.join(names)}"), ephemeral=True)
        else:
            await interaction.response.send_message(embed=nova_embed("aFK", "nO oNE mENTIONED yOU wHILE yOU wERE aWAY!"), ephemeral=True)



@bot.command()
async def mute(ctx, member: discord.Member = None):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("mUTE", "yOU dON'T hAVE pERMISSION!"))
        return
    if not member:
        await ctx.send(embed=nova_embed("mUTE", "yOU nEED tO mENTION sOMEONE!"))
        return
    if member == ctx.author:
        await ctx.send(embed=nova_embed("mUTE", "nICE tRY, bUT yOU cAN'T mUTE yOURSELF!"))
        return
    role = await get_or_create_muted_role(ctx.guild)
    if not role:
        await ctx.send(embed=nova_embed("mUTE", "cOULD nOT cREATE oR fIND tHE mUTED rOLE!"))
        return
    if role in member.roles:
        await ctx.send(embed=nova_embed("mUTE", f"{member.mention} iS aLREADY mUTED!"))
        return
    try:
        await member.add_roles(role, reason="Muted by Nova")
        await ctx.send(embed=nova_embed("mUTE", f"{member.mention} hAS bEEN mUTED sERVER-WIDE!"))
        await ctx.send("Usage: ?mute @user - Mutes a member server-wide. Only mods/admins can use this.")
    except Exception:
        await ctx.send(embed=nova_embed("mUTE", "cOULD nOT mUTE tHAT uSER!"))

@bot.tree.command(name="mute", description="Mute a member server-wide (admin only)")
@app_commands.describe(member="Member to mute")
async def mute_slash(interaction: discord.Interaction, member: discord.Member):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("mUTE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    if member == interaction.user:
        await interaction.response.send_message(embed=nova_embed("mUTE", "nICE tRY, bUT yOU cAN'T mUTE yOURSELF!"), ephemeral=True)
        return
    role = await get_or_create_muted_role(interaction.guild)
    if not role:
        await interaction.response.send_message(embed=nova_embed("mUTE", "cOULD nOT cREATE oR fIND tHE mUTED rOLE!"), ephemeral=True)
        return
    if role in member.roles:
        await interaction.response.send_message(embed=nova_embed("mUTE", f"{member.mention} iS aLREADY mUTED!"), ephemeral=True)
        return
    try:
        await member.add_roles(role, reason="Muted by Nova")
        await interaction.response.send_message(embed=nova_embed("mUTE", f"{member.mention} hAS bEEN mUTED sERVER-WIDE!"))
        await interaction.followup.send("Usage: /mute @user - Mutes a member server-wide. Only mods/admins can use this.", ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("mUTE", "cOULD nOT mUTE tHAT uSER!"), ephemeral=True)

@bot.command()
async def unmute(ctx, member: discord.Member = None):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("uNMUTE", "yOU dON'T hAVE pERMISSION!"))
        return
    if member is None:
        await ctx.send(embed=nova_embed("uNMUTE", "uSAGE: ?unmute @user"))
        return
    role = discord.utils.get(ctx.guild.roles, name="Muted")
    if not role or role not in member.roles:
        await ctx.send(embed=nova_embed("uNMUTE", f"{member.mention} iS nOT mUTED!"))
        return
    try:
        await member.remove_roles(role, reason="Unmuted by Nova")
        await ctx.send(embed=nova_embed("uNMUTE", f"{member.mention} hAS bEEN uNMUTED!"))
        log_case(ctx.guild.id, 'Unmute', member, ctx.channel, datetime.now(timezone.utc))
    except Exception:
        await ctx.send(embed=nova_embed("uNMUTE", "cOULD nOT uNMUTE tHAT uSER!"))

@bot.tree.command(name="unmute", description="Unmute a member server-wide (admin only)")
@app_commands.describe(member="Member to unmute")
async def unmute_slash(interaction: discord.Interaction, member: discord.Member):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("uNMUTE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    role = discord.utils.get(interaction.guild.roles, name="Muted")
    if not role or role not in member.roles:
        await interaction.response.send_message(embed=nova_embed("uNMUTE", f"{member.mention} iS nOT mUTED!"), ephemeral=True)
        return
    try:
        await member.remove_roles(role, reason="Unmuted by Nova")
        await interaction.response.send_message(embed=nova_embed("uNMUTE", f"{member.mention} hAS bEEN uNMUTED!"))
        log_case(interaction.guild.id, 'Unmute', member, interaction.channel, datetime.now(timezone.utc))
    except Exception:
        await interaction.response.send_message(embed=nova_embed("uNMUTE", "cOULD nOT uNMUTE tHAT uSER!"), ephemeral=True)

@bot.command()
async def case(ctx):
    cases = mod_cases.get(ctx.guild.id, [])
    if not cases:
        await ctx.send(embed=nova_embed("cASES", "nO mODERATION cASES fOUND!"))
        return
    desc = ""
    for i, c in enumerate(cases, 1):
        desc += f"**{i}.** `{c['action']}` by {c['user']} in {c['channel']} ‚Ä¢ {c['time'].strftime('%Y-%m-%d %H:%M:%S')}\n"
    await ctx.send(embed=nova_embed("cASES", desc))

@bot.tree.command(name="case", description="Show all moderation actions in this server (up to 20)")
async def case_slash(interaction: discord.Interaction):
    cases = mod_cases.get(interaction.guild.id, [])
    if not cases:
        await interaction.response.send_message(embed=nova_embed("cASES", "nO mODERATION cASES fOUND!"), ephemeral=True)
        return
    desc = ""
    for i, c in enumerate(cases, 1):
        desc += f"**{i}.** `{c['action']}` by {c['user']} in {c['channel']} ‚Ä¢ {c['time'].strftime('%Y-%m-%d %H:%M:%S')}\n"
    await interaction.response.send_message(embed=nova_embed("cASES", desc))
    await interaction.response.send_message("Usage: /case - Shows the last 20 moderation actions. Only mods/admins can use this.", ephemeral=True)

@bot.command()
async def snipe(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sNIPE", "yOU dON'T hAVE pERMISSION!"))
        return
    data = snipes.get(ctx.channel.id)
    if not data:
        await ctx.send(embed=nova_embed("sNIPE", "nOTHING tO sNIPE!"))
        return
    embed = nova_embed("sNIPE", data['content'])
    embed.set_footer(text=f"{data['author']} ‚Ä¢ {data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)

@bot.tree.command(name="snipe", description="Show the last deleted message in this channel")
async def snipe_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("sNIPE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    data = snipes.get(interaction.channel.id)
    if not data:
        await interaction.response.send_message(embed=nova_embed("sNIPE", "nOTHING tO sNIPE!"), ephemeral=True)
        return
    embed = nova_embed("sNIPE", data['content'])
    embed.set_footer(text=f"{data['author']} ‚Ä¢ {data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed)

@bot.command()
async def edsnipe(ctx):
    data = edsnipes.get(ctx.channel.id)
    if not data:
        await ctx.send(embed=nova_embed("eDSNIPE", "nOTHING tO eDSNIPE!"))
        return
    embed = nova_embed("eDSNIPE", data['content'])
    embed.set_footer(text=f"{data['author']} ‚Ä¢ {data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)

@bot.tree.command(name="edsnipe", description="Show the last edited (before) message in this channel")
async def edsnipe_slash(interaction: discord.Interaction):
    data = edsnipes.get(interaction.channel.id)
    if not data:
        await interaction.response.send_message(embed=nova_embed("eDSNIPE", "nOTHING tO eDSNIPE!"), ephemeral=True)
        return
    embed = nova_embed("eDSNIPE", data['content'])
    embed.set_footer(text=f"{data['author']} ‚Ä¢ {data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed)

@bot.command()
async def slowmode(ctx, seconds: int = 0):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sLOWMODE", "yOU dON'T hAVE pERMISSION!"))
        return
    await ctx.channel.edit(slowmode_delay=seconds)
    await ctx.send(embed=nova_embed("sLOWMODE", f"sLOWMODE sET tO {seconds} sECONDS iN {ctx.channel.mention}!"))
    await ctx.send("Usage: ?slowmode [seconds] - Sets slowmode in the current channel. Only mods/admins can use this.")

@bot.tree.command(name="slowmode", description="Set slowmode in the current channel (admin only)")
@app_commands.describe(seconds="Number of seconds for slowmode")
async def slowmode_slash(interaction: discord.Interaction, seconds: int = 0):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("sLOWMODE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    await interaction.channel.edit(slowmode_delay=seconds)
    await interaction.response.send_message(embed=nova_embed("sLOWMODE", f"sLOWMODE sET tO {seconds} sECONDS iN {interaction.channel.mention}!"), ephemeral=True)
    await interaction.followup.send("Usage: /slowmode [seconds] - Sets slowmode in the current channel. Only mods/admins can use this.", ephemeral=True)

# Economy
@bot.command()
async def pay(ctx, user: discord.Member, amount: int):
    if amount <= 0:
        await ctx.send(embed=nova_embed("pAY", "aMOUNT mUST bE pOSITIVE!"))
        return
    if get_balance(ctx.author.id) < amount:
        await ctx.send(embed=nova_embed("pAY", "nOT eNOUGH dOLLARIANAS!"))
        return
    change_balance(ctx.author.id, -amount)
    change_balance(user.id, amount)
    await ctx.send(embed=nova_embed("pAY", f"{ctx.author.display_name} sENT {amount} {CURRENCY_NAME} tO {user.display_name}!"))

@bot.tree.command(name="pay", description="Send currency to another user")
@app_commands.describe(user="The user to pay", amount="Amount to send")
async def pay_slash(interaction: discord.Interaction, user: discord.Member, amount: int):
    if amount <= 0:
        await interaction.response.send_message(embed=nova_embed("pAY", "aMOUNT mUST bE pOSITIVE!"), ephemeral=True)
        return
    if get_balance(interaction.user.id) < amount:
        await interaction.response.send_message(embed=nova_embed("pAY", "nOT eNOUGH dOLLARIANAS!"), ephemeral=True)
        return
    change_balance(interaction.user.id, -amount)
    change_balance(user.id, amount)
    await interaction.response.send_message(embed=nova_embed("pAY", f"{interaction.user.display_name} sENT {amount} {CURRENCY_NAME} tO {user.display_name}!"))

@bot.command()
async def shop(ctx):
    lines = [f"‚Ä¢ {item} ‚Äî {price} {CURRENCY_NAME}" for item, price in SHOP_ITEMS.items()]
    await ctx.send(embed=nova_embed("üõçÔ∏è nOVA'S sHOP", "\n".join(lines)))

@bot.tree.command(name="shop", description="Show items available to buy")
async def shop_slash(interaction: discord.Interaction):
    lines = [f"‚Ä¢ {item} ‚Äî {price} {CURRENCY_NAME}" for item, price in SHOP_ITEMS.items()]
    await interaction.response.send_message(embed=nova_embed("üõçÔ∏è nOVA'S sHOP", "\n".join(lines)))

@bot.command()
async def buy(ctx, *, item: str):
    item = item.strip().lower()
    matched = next((k for k in SHOP_ITEMS if k.lower() == item), None)
    if not matched:
        await ctx.send(embed=nova_embed("bUY", "iTEM nOT fOUND iN tHE sHOP!"))
        return
    price = SHOP_ITEMS[matched]
    if get_balance(ctx.author.id) < price:
        await ctx.send(embed=nova_embed("bUY", "nOT eNOUGH dOLLARIANAS!"))
        return
    change_balance(ctx.author.id, -price)
    inventory = load_inventory()
    user_inv = inventory.get(str(ctx.author.id), [])
    user_inv.append(matched)
    inventory[str(ctx.author.id)] = user_inv
    save_inventory(inventory)
    await ctx.send(embed=nova_embed("bUY", f"yOU bOUGHT: {matched} fOR {price} {CURRENCY_NAME}!"))

@bot.tree.command(name="buy", description="Purchase an item from the shop")
@app_commands.describe(item="The item to buy")
async def buy_slash(interaction: discord.Interaction, item: str):
    item = item.strip().lower()
    matched = next((k for k in SHOP_ITEMS if k.lower() == item), None)
    if not matched:
        await interaction.response.send_message(embed=nova_embed("bUY", "iTEM nOT fOUND iN tHE sHOP!"), ephemeral=True)
        return
    price = SHOP_ITEMS[matched]
    if get_balance(interaction.user.id) < price:
        await interaction.response.send_message(embed=nova_embed("bUY", "nOT eNOUGH dOLLARIANAS!"), ephemeral=True)
        return
    change_balance(interaction.user.id, -price)
    inventory = load_inventory()
    user_inv = inventory.get(str(interaction.user.id), [])
    user_inv.append(matched)
    inventory[str(interaction.user.id)] = user_inv
    save_inventory(inventory)
    await interaction.response.send_message(embed=nova_embed("bUY", f"yOU bOUGHT: {matched} fOR {price} {CURRENCY_NAME}!"))

@bot.command()
async def inventory(ctx):
    inventory = load_inventory()
    user_inv = inventory.get(str(ctx.author.id), [])
    if not user_inv:
        await ctx.send(embed=nova_embed("iNVENTORY", "yOU dON'T oWN aNY iTEMS!"))
        return
    lines = [f"‚Ä¢ {item}" for item in user_inv]
    await ctx.send(embed=nova_embed("iNVENTORY", "\n".join(lines)))

@bot.tree.command(name="inventory", description="Show items you own")
async def inventory_slash(interaction: discord.Interaction):
    inventory = load_inventory()
    user_inv = inventory.get(str(interaction.user.id), [])
    if not user_inv:
        await interaction.response.send_message(embed=nova_embed("iNVENTORY", "yOU dON'T oWN aNY iTEMS!"), ephemeral=True)
        return
    lines = [f"‚Ä¢ {item}" for item in user_inv]
    await interaction.response.send_message(embed=nova_embed("iNVENTORY", "\n".join(lines)))

# Welcome/Rules
@bot.command()
async def welcome(ctx):
    embed = discord.Embed(
        title="üëã wELCOME tO tHE sERVER!",
        description="i'M nOVA, yOUR fABULOUS bOT. mAKE yOURSELF aT hOME!",
        color=0xff69b4
    )
    embed.set_footer(text="nOVA wELCOMES yOU üíñ")
    await ctx.send(embed=embed)

@bot.command()
async def rules(ctx):
    embed = discord.Embed(
        title="üìú sERVER rULES",
        description="1. bE rESPECTFUL\n2. nO sPAM\n3. sTAY oN tOPIC\n4. nO nSFW\n5. lISTEN tO mODS\n6. hAVE fUN!",
        color=0xff69b4
    )
    embed.set_footer(text="nOVA sAYS: fOLLOW tHE rULES oR eLSE üíÖ")
    await ctx.send(embed=embed)

# Fun
@bot.command()
async def votekick(ctx, user: discord.Member):
    embed = nova_embed("vOTEKICK", f"sHOULD wE kICK {user.mention}?\n‚úÖ = yES, ‚ùå = nO\n(vOTE eNDS iN 15 sECONDS)")
    msg = await ctx.send(embed=embed)
    await msg.add_reaction("‚úÖ")
    await msg.add_reaction("‚ùå")
    await asyncio.sleep(15)
    msg = await ctx.channel.fetch_message(msg.id)
    yes = 0
    no = 0
    for reaction in msg.reactions:
        if str(reaction.emoji) == "‚úÖ":
            yes = reaction.count - 1  # exclude bot
        elif str(reaction.emoji) == "‚ùå":
            no = reaction.count - 1
    if yes > no:
        result = f"{user.mention} wAS (nOT rEALLY) kICKED! "
    else:
        result = f"{user.mention} sTAYS... fOR nOW! "
    await ctx.send(embed=nova_embed("vOTEKICK rESULT", result))

@bot.tree.command(name="votekick", description="Start a fake vote to kick someone (fun only)")
@app_commands.describe(user="The user to (fake) kick")
async def votekick_slash(interaction: discord.Interaction, user: discord.Member):
    embed = nova_embed("vOTEKICK", f"sHOULD wE kICK {user.mention}?\n‚úÖ = yES, ‚ùå = nO\n(vOTE eNDS iN 15 sECONDS)")
    msg = await interaction.channel.send(embed=embed)
    await msg.add_reaction("‚úÖ")
    await msg.add_reaction("‚ùå")
    await interaction.response.send_message(embed=nova_embed("vOTEKICK", f"vOTE sTARTED fOR {user.mention}!"), ephemeral=True)
    await asyncio.sleep(15)
    msg = await interaction.channel.fetch_message(msg.id)
    yes = 0
    no = 0
    for reaction in msg.reactions:
        if str(reaction.emoji) == "‚úÖ":
            yes = reaction.count - 1
        elif str(reaction.emoji) == "‚ùå":
            no = reaction.count - 1
    if yes > no:
        result = f"{user.mention} wAS (nOT rEALLY) kICKED! "
    else:
        result = f"{user.mention} sTAYS... fOR nOW! "
    await interaction.channel.send(embed=nova_embed("vOTEKICK rESULT", result))

@bot.command()
async def explode(ctx):
    if ctx.author.id != OWNER_ID:
        await ctx.send("Only the owner can use this command.")
        return
    await ctx.send("üí• Nova is self-destructing... (feature coming soon!)")

# Utility/External
@bot.command()
async def google(ctx, *, query: str):
    await ctx.send("Google search feature coming soon!")

@bot.command()
async def image(ctx, *, query: str):
    await ctx.send("Image search feature coming soon!")

@bot.command()
async def calc(ctx, *, equation: str):
    await ctx.send("Calculator feature coming soon!")

# Timezone/Birthday
@bot.command()
async def timezone(ctx, *, location: str = None):
    await ctx.send("Timezone feature coming soon!")

@bot.command()
async def tz(ctx, *, location: str = None):
    await ctx.send("Timezone shortcut feature coming soon!")

@bot.command()
async def settz(ctx, *, timezone: str):
    await ctx.send("Set timezone feature coming soon!")

@bot.command()
async def settimezone(ctx, *, timezone: str):
    await ctx.send("Set timezone (alias) feature coming soon!")

@bot.command()
async def birthday(ctx, user: discord.Member = None):
    """Show a user's birthday. Usage: ?birthday [@user]"""
    user = user or ctx.author
    birthdays = load_birthdays()
    bday = birthdays.get(str(user.id))
    if bday:
        await ctx.send(f"{user.display_name}'s birthday is {bday}!")
    else:
        await ctx.send(f"No birthday set for {user.display_name}.")

@bot.command()
async def bday(ctx, user: discord.Member = None, date: str = None):
    await ctx.send("Birthday shortcut feature coming soon!")

@bot.command()
async def setbday(ctx, date: str):
    """Set your birthday. Usage: ?setbday DD-MM"""
    # Basic validation
    try:
        day, month = map(int, date.split("-"))
        assert 1 <= month <= 12
        assert 1 <= day <= 31
    except Exception:
        await ctx.send("Please use the format DD-MM, e.g. 15-04 for April 15th.")
        return
    birthdays = load_birthdays()
    birthdays[str(ctx.author.id)] = date
    save_birthdays(birthdays)
    await ctx.send(f"Birthday set to {date}!")

@bot.command()
async def setbirthday(ctx, *, date: str):
    await ctx.send("Set birthday (alias) feature coming soon!")

@bot.command()
async def birthdays(ctx):
    """List all birthdays in the server."""
    birthdays = load_birthdays()
    if not birthdays:
        await ctx.send("No birthdays set yet!")
        return
    lines = []
    for user_id, date in birthdays.items():
        member = ctx.guild.get_member(int(user_id))
        if member:
            lines.append(f"{member.display_name}: {date}")
    if lines:
        await ctx.send("**Server Birthdays:**\n" + "\n".join(lines))
    else:
        await ctx.send("No birthdays set for current server members.")

@bot.command()
async def today(ctx):
    """Shows today's international day, Nova style, in a vibrant embed."""
    now = datetime.now()
    key = now.strftime("%d-%m")
    day = INTERNATIONAL_DAYS.get(key)
    if day:
        embed = discord.Embed(
            title="üåç tODAY iS...",
            description=f"**{day}!**",
            color=0xff69b4  # Hot pink for Nova!
        )
        embed.set_footer(text="nOVA bRINGS yOU tHE dAY!")
    else:
        embed = discord.Embed(
            title="nO iNTERNATIONAL dAY tODAY!",
            description="tRY aGAIN tOMORROW bABY ",
            color=0x7289da  # Discord blurple
        )
        embed.set_footer(text="nOVA sAYS: mAYBE nEXT tIME!")
    await ctx.send(embed=embed)

# Confessions/8ball/Therapy
@bot.command()
async def confess(ctx, *, message: str):
    if CONFESS_CHANNEL_ID is None:
        await ctx.send(embed=nova_embed("cONFESSION", "cONFESSION cHANNEL nOT sET! aSK aN aDMIN."))
        return
    try:
        channel = bot.get_channel(CONFESS_CHANNEL_ID)
        if not channel:
            await ctx.send(embed=nova_embed("cONFESSION", "cOULD nOT fIND tHE cONFESSION cHANNEL!"))
            return
        embed = nova_embed("aNONYMOUS cONFESSION", message)
        await channel.send(embed=embed)
        await ctx.author.send(embed=nova_embed("cONFESSION sENT", "yOUR cONFESSION wAS sENT aNONYMOUSLY!"))
        await ctx.send(embed=nova_embed("cONFESSION", "yOUR cONFESSION wAS sENT aNONYMOUSLY! cHECK yOUR dMS."))
    except Exception:
        await ctx.send(embed=nova_embed("cONFESSION", "cOULD nOT sEND cONFESSION!"))

@bot.tree.command(name="confess", description="Send an anonymous confession to a private channel")
@app_commands.describe(message="Your confession")
async def confess_slash(interaction: discord.Interaction, message: str):
    if CONFESS_CHANNEL_ID is None:
        await interaction.response.send_message(embed=nova_embed("cONFESSION", "cONFESSION cHANNEL nOT sET! aSK aN aDMIN."), ephemeral=True)
        return
    try:
        channel = bot.get_channel(CONFESS_CHANNEL_ID)
        if not channel:
            await interaction.response.send_message(embed=nova_embed("cONFESSION", "cOULD nOT fIND tHE cONFESSION cHANNEL!"), ephemeral=True)
            return
        embed = nova_embed("aNONYMOUS cONFESSION", message)
        await channel.send(embed=embed)
        await interaction.user.send(embed=nova_embed("cONFESSION sENT", "yOUR cONFESSION wAS sENT aNONYMOUSLY!"))
        await interaction.response.send_message(embed=nova_embed("cONFESSION", "yOUR cONFESSION wAS sENT aNONYMOUSLY! cHECK yOUR dMS."), ephemeral=True)
    except Exception:
        await interaction.response.send_message(embed=nova_embed("cONFESSION", "cOULD nOT sEND cONFESSION!"), ephemeral=True)

@bot.command(name="8ball")
async def _8ball(ctx, *, question: str):
    responses = [
        "yES, dARLING!",
        "nO, sWEETIE!",
        "mAYBE... aSK aGAIN lATER!",
        "aBSOLUTELY!",
        "nOT iN a mILLION yEARS!",
        "oF cOURSE!",
        "i wOULDN'T cOUNT oN iT!",
        "tHE sTARS sAY yES!",
        "mY sOURCES sAY nO!",
        "aSK yOUR mOTHER!",
        "iT iS cERTAIN!",
        "oUTLOOK nOT sO gOOD!",
        "yOU aLREADY kNOW tHE aNSWER!",
        "dON'T bET oN iT!",
        "sLAY, bUT nO!"
    ]
    answer = random.choice(responses)
    embed = nova_embed("üé± 8bALL", f"qUESTION: {question}\n**aNSWER:** {answer}")
    await ctx.send(embed=embed)

@bot.tree.command(name="8ball", description="Ask Nova the magic 8ball!")
@app_commands.describe(question="Your question for the 8ball")
async def _8ball_slash(interaction: discord.Interaction, question: str):
    responses = [
        "yES, dARLING!",
        "nO, sWEETIE!",
        "mAYBE... aSK aGAIN lATER!",
        "aBSOLUTELY!",
        "nOT iN a mILLION yEARS!",
        "oF cOURSE!",
        "i wOULDN'T cOUNT oN iT!",
        "tHE sTARS sAY yES!",
        "mY sOURCES sAY nO!",
        "aSK yOUR mOTHER!",
        "iT iS cERTAIN!",
        "oUTLOOK nOT sO gOOD!",
        "yOU aLREADY kNOW tHE aNSWER!",
        "dON'T bET oN iT!",
        "sLAY, bUT nO!"
    ]
    answer = random.choice(responses)
    embed = nova_embed("üé± 8bALL", f"qUESTION: {question}\n**aNSWER:** {answer}")
    await interaction.response.send_message(embed=embed)

@bot.command()
async def mood(ctx):
    moods = [
        "fEELING fANTABULOUS ",
        "i'M iN a cUNT mOOD ",
        "dRAMATIC tODAY ",
        "cHAOTIC eNERGY ",
        "lOVING tHE vIBE ",
        "cHILE...",
        "bORED... ",
        "rEADY tO mOTHER üëë",
        "cAFFEINATED aND dANGEROUS ",
        "i'M yOUR bESTIE tODAY..."
    ]
    mood = random.choice(moods)
    await ctx.send(embed=nova_embed("nOVA'S mOOD", mood))

@bot.tree.command(name="mood", description="Show Nova's current mood!")
async def mood_slash(interaction: discord.Interaction):
    moods = [
        "fEELING fANTABULOUS ",
        "i'M iN a cUNT mOOD ",
        "dRAMATIC tODAY ",
        "cHAOTIC eNERGY ",
        "lOVING tHE vIBE ",
        "cHILE...",
        "bORED... ",
        "rEADY tO mOTHER üëë",
        "cAFFEINATED aND dANGEROUS ",
        "i'M yOUR bESTIE tODAY..."
    ]
    mood = random.choice(moods)
    await interaction.response.send_message(embed=nova_embed("nOVA'S mOOD", mood))

@bot.command()
async def remindme(ctx, time: str, *, message: str):
    seconds = parse_time(time)
    if seconds is None or seconds <= 0:
        await ctx.send(embed=nova_embed("rEMINDER", "iNVALID tIME! uSE s, m, h, oR d (e.g. 10m, 2h)"))
        return
    reminders = load_reminders()
    user_reminders = reminders.get(str(ctx.author.id), {})
    reminder_id = str(len(user_reminders) + 1)
    user_reminders[reminder_id] = {"message": message, "time": int(asyncio.get_event_loop().time()) + seconds}
    reminders[str(ctx.author.id)] = user_reminders
    save_reminders(reminders)
    await ctx.send(embed=nova_embed("rEMINDER sET", f"i'LL rEMIND yOU iN {time}: {message}"))
    bot.loop.create_task(reminder_task(ctx.author.id, reminder_id, seconds, message))

@bot.tree.command(name="remindme", description="Set a reminder to ping you later")
@app_commands.describe(time="Time (e.g. 10m, 2h, 1d)", message="Reminder message")
async def remindme_slash(interaction: discord.Interaction, time: str, message: str):
    seconds = parse_time(time)
    if seconds is None or seconds <= 0:
        await interaction.response.send_message(embed=nova_embed("rEMINDER", "iNVALID tIME! uSE s, m, h, oR d (e.g. 10m, 2h)"), ephemeral=True)
        return
    reminders = load_reminders()
    user_reminders = reminders.get(str(interaction.user.id), {})
    reminder_id = str(len(user_reminders) + 1)
    user_reminders[reminder_id] = {"message": message, "time": int(asyncio.get_event_loop().time()) + seconds}
    reminders[str(interaction.user.id)] = user_reminders
    save_reminders(reminders)
    await interaction.response.send_message(embed=nova_embed("rEMINDER sET", f"i'LL rEMIND yOU iN {time}: {message}"), ephemeral=True)
    bot.loop.create_task(reminder_task(interaction.user.id, reminder_id, seconds, message))

@bot.command()
async def reminderlist(ctx):
    reminders = load_reminders()
    user_reminders = reminders.get(str(ctx.author.id), {})
    if not user_reminders:
        await ctx.send(embed=nova_embed("rEMINDERS", "nO aCTIVE rEMINDERS!"))
        return
    lines = []
    now = int(asyncio.get_event_loop().time())
    for rid, data in user_reminders.items():
        left = max(0, data["time"] - now)
        mins, secs = divmod(left, 60)
        hours, mins = divmod(mins, 60)
        if hours:
            tstr = f"{int(hours)}h {int(mins)}m"
        elif mins:
            tstr = f"{int(mins)}m {int(secs)}s"
        else:
            tstr = f"{int(secs)}s"
        lines.append(f"‚Ä¢ {data['message']} (in {tstr})")
    await ctx.send(embed=nova_embed("yOUR rEMINDERS", "\n".join(lines)))

@bot.tree.command(name="reminderlist", description="List your active reminders")
async def reminderlist_slash(interaction: discord.Interaction):
    reminders = load_reminders()
    user_reminders = reminders.get(str(interaction.user.id), {})
    if not user_reminders:
        await interaction.response.send_message(embed=nova_embed("rEMINDERS", "nO aCTIVE rEMINDERS!"), ephemeral=True)
        return
    lines = []
    now = int(asyncio.get_event_loop().time())
    for rid, data in user_reminders.items():
        left = max(0, data["time"] - now)
        mins, secs = divmod(left, 60)
        hours, mins = divmod(mins, 60)
        if hours:
            tstr = f"{int(hours)}h {int(mins)}m"
        elif mins:
            tstr = f"{int(mins)}m {int(secs)}s"
        else:
            tstr = f"{int(secs)}s"
        lines.append(f"‚Ä¢ {data['message']} (in {tstr})")
    await interaction.response.send_message(embed=nova_embed("yOUR rEMINDERS", "\n".join(lines)), ephemeral=True)

# Translate/Weather/Avatar/Fact
@bot.command()
async def translate(ctx, language: str, *, text: str):
    await ctx.send("Translate feature coming soon!")

@bot.command()
async def weather(ctx, *, city: str):
    await ctx.send("Weather feature coming soon!")

@bot.command()
async def avatar(ctx, user: discord.Member = None):
    user = user or ctx.author
    embed = nova_embed(
        title=f"{user.display_name}'s aVATAR",
        description=f"hERE'S tHE aVATAR fOR {user.mention}",
        color=0xff69b4
    )
    embed.set_image(url=user.display_avatar.url)
    await ctx.send(embed=embed)

@bot.tree.command(name="avatar", description="Show the avatar of a user")
async def avatar_slash(interaction: discord.Interaction, user: discord.Member = None):
    user = user or interaction.user
    embed = nova_embed(
        title=f"{user.display_name}'s aVATAR",
        description=f"hERE'S tHE aVATAR fOR {user.mention}",
        color=0xff69b4
    )
    embed.set_image(url=user.display_avatar.url)
    await interaction.response.send_message(embed=embed)

@bot.command()
async def fact(ctx):
    await ctx.send("Fact feature coming soon!")

# Lyrics/Nick/Jail/Autoplay
@bot.command()
async def lyrics(ctx, *, query: str):
    await ctx.send("Lyrics feature coming soon!")

@bot.command()
async def nick(ctx, user: discord.Member, *, nickname: str):
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    await ctx.send("Nick feature coming soon!")

JAIL_CHANNEL_ID = None  # Set this to your jail channel ID (int)

@bot.command()
async def setjail(ctx, channel: discord.TextChannel):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET jAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    global JAIL_CHANNEL_ID
    JAIL_CHANNEL_ID = channel.id
    await ctx.send(embed=nova_embed("sET jAIL", f"jAIL cHANNEL sET tO {channel.mention}"))

@bot.tree.command(name="setjail", description="Set the jail channel (admin/mod only)")
@app_commands.describe(channel="The channel to use as jail")
async def setjail_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("sET jAIL", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    global JAIL_CHANNEL_ID
    JAIL_CHANNEL_ID = channel.id
    await interaction.response.send_message(embed=nova_embed("sET jAIL", f"jAIL cHANNEL sET tO {channel.mention}"), ephemeral=True)

@bot.command()
async def setrunway(ctx, channel: discord.TextChannel):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET rUNWAY", "yOU dON'T hAVE pERMISSION!"))
        return
    global RUNWAY_CHANNEL_ID
    RUNWAY_CHANNEL_ID = channel.id
    await ctx.send(embed=nova_embed("sET rUNWAY", f"rUNWAY cHANNEL sET tO {channel.mention}!"))

@bot.tree.command(name="setrunway", description="Set the runway channel (admin/mod only)")
@app_commands.describe(channel="The channel to use as runway")
async def setrunway_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("sET rUNWAY", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    global RUNWAY_CHANNEL_ID
    RUNWAY_CHANNEL_ID = channel.id
    await interaction.response.send_message(embed=nova_embed("sET rUNWAY", f"rUNWAY cHANNEL sET tO {channel.mention}!"), ephemeral=True)

@bot.command()
async def fixinmate(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("fIX iNMATE", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        inmate_role = discord.utils.get(ctx.guild.roles, name="iNMATE")
        if not inmate_role:
            await ctx.send(embed=nova_embed("fIX iNMATE", "iNMATE rOLE dOES nOT eXIST!"))
            return
        
        # Force update permissions for all channels
        updated_channels = 0
        for channel in ctx.guild.channels:
            if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                try:
                    await channel.set_permissions(inmate_role, 
                        send_messages=False, 
                        speak=False, 
                        add_reactions=False,
                        create_public_threads=False,
                        create_private_threads=False,
                        send_messages_in_threads=False,
                        view_channel=True,
                        read_message_history=True
                    )
                    updated_channels += 1
                except discord.Forbidden:
                    continue
        
        await ctx.send(embed=nova_embed("fIX iNMATE", f"uPDATED pERMISSIONS fOR {updated_channels} cHANNELS!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("fIX iNMATE", f"eRROR: {str(e)}"))

@bot.tree.command(name="fixinmate", description="Fix inmate role permissions for all channels (admin/mod only)")
async def fixinmate_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("fIX iNMATE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        inmate_role = discord.utils.get(interaction.guild.roles, name="iNMATE")
        if not inmate_role:
            await interaction.response.send_message(embed=nova_embed("fIX iNMATE", "iNMATE rOLE dOES nOT eXIST!"), ephemeral=True)
            return
        
        # Force update permissions for all channels
        updated_channels = 0
        for channel in interaction.guild.channels:
            if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                try:
                    await channel.set_permissions(inmate_role, 
                        send_messages=False, 
                        speak=False, 
                        add_reactions=False,
                        create_public_threads=False,
                        create_private_threads=False,
                        send_messages_in_threads=False,
                        view_channel=True,
                        read_message_history=True
                    )
                    updated_channels += 1
                except discord.Forbidden:
                    continue
        
        await interaction.response.send_message(embed=nova_embed("fIX iNMATE", f"uPDATED pERMISSIONS fOR {updated_channels} cHANNELS!"), ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("fIX iNMATE", f"eRROR: {str(e)}"), ephemeral=True)

@bot.command()
async def jail(ctx, user: discord.Member = None):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("jAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    if user is None:
        await ctx.send(embed=nova_embed("jAIL", "uSAGE: ?jail @user"))
        return
    
    if JAIL_CHANNEL_ID is None:
        await ctx.send(embed=nova_embed("jAIL", "jAIL cHANNEL nOT sET!"))
        return
    try:
        jail_channel = ctx.guild.get_channel(JAIL_CHANNEL_ID)
        if not jail_channel:
            await ctx.send(embed=nova_embed("jAIL", "cOULD nOT fIND tHE jAIL cHANNEL!"))
            return
        
        # Create or get inmate role
        inmate_role = discord.utils.get(ctx.guild.roles, name="iNMATE")
        if not inmate_role:
            try:
                inmate_role = await ctx.guild.create_role(
                    name="iNMATE",
                    color=discord.Color.dark_red(),
                    reason="Jail system role"
                )
                # Set permissions for all channels
                for channel in ctx.guild.channels:
                    if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                        try:
                            await channel.set_permissions(inmate_role, 
                                send_messages=False, 
                                speak=False, 
                                add_reactions=False,
                                create_public_threads=False,
                                create_private_threads=False,
                                send_messages_in_threads=False,
                                view_channel=True,
                                read_message_history=True
                            )
                        except discord.Forbidden:
                            continue  # Skip channels we can't modify
            except discord.Forbidden:
                await ctx.send(embed=nova_embed("jAIL", "cAN'T cREATE iNMATE rOLE - nO pERMISSION!"))
                return
        else:
            # If role exists, make sure permissions are set correctly
            for channel in ctx.guild.channels:
                if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                    try:
                        await channel.set_permissions(inmate_role, 
                            send_messages=False, 
                            speak=False, 
                            add_reactions=False,
                            create_public_threads=False,
                            create_private_threads=False,
                            send_messages_in_threads=False,
                            view_channel=True,
                            read_message_history=True
                        )
                    except discord.Forbidden:
                        continue  # Skip channels we can't modify
        
        # Add inmate role to user
        if inmate_role not in user.roles:
            await user.add_roles(inmate_role, reason="Jailed by Nova")
        
        # Try to move user to jail channel if they're in voice
        if user.voice:
            try:
                await user.move_to(jail_channel)
            except discord.Forbidden:
                pass  # Don't fail if we can't move them
            except Exception:
                pass  # Don't fail if we can't move them
        
        await ctx.send(embed=nova_embed("jAIL", f"{user.mention} hAS bEEN jAILED! tHEY cAN'T tALK aNYWHERE nOW!"))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("jAIL", "nO pERMISSION tO mANAGE rOLES oR cHANNELS!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("jAIL", f"eRROR: {str(e)}"))

@bot.tree.command(name="jail", description="Move a user to the jail channel and restrict permissions (admin/mod only)")
@app_commands.describe(user="The user to jail")
async def jail_slash(interaction: discord.Interaction, user: discord.Member):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("jAIL", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    if JAIL_CHANNEL_ID is None:
        await interaction.response.send_message(embed=nova_embed("jAIL", "jAIL cHANNEL nOT sET!"), ephemeral=True)
        return
    try:
        jail_channel = interaction.guild.get_channel(JAIL_CHANNEL_ID)
        if not jail_channel:
            await interaction.response.send_message(embed=nova_embed("jAIL", "cOULD nOT fIND tHE jAIL cHANNEL!"), ephemeral=True)
            return
        
        # Create or get inmate role
        inmate_role = discord.utils.get(interaction.guild.roles, name="iNMATE")
        if not inmate_role:
            try:
                inmate_role = await interaction.guild.create_role(
                    name="iNMATE",
                    color=discord.Color.dark_red(),
                    reason="Jail system role"
                )
                # Set permissions for all channels
                for channel in interaction.guild.channels:
                    if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                        try:
                            await channel.set_permissions(inmate_role, 
                                send_messages=False, 
                                speak=False, 
                                add_reactions=False,
                                create_public_threads=False,
                                create_private_threads=False,
                                send_messages_in_threads=False,
                                view_channel=True,
                                read_message_history=True
                            )
                        except discord.Forbidden:
                            continue  # Skip channels we can't modify
            except discord.Forbidden:
                await interaction.response.send_message(embed=nova_embed("jAIL", "cAN'T cREATE iNMATE rOLE - nO pERMISSION!"), ephemeral=True)
                return
        else:
            # If role exists, make sure permissions are set correctly
            for channel in interaction.guild.channels:
                if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                    try:
                        await channel.set_permissions(inmate_role, 
                            send_messages=False, 
                            speak=False, 
                            add_reactions=False,
                            create_public_threads=False,
                            create_private_threads=False,
                            send_messages_in_threads=False,
                            view_channel=True,
                            read_message_history=True
                        )
                    except discord.Forbidden:
                        continue  # Skip channels we can't modify
        
        # Add inmate role to user
        if inmate_role not in user.roles:
            await user.add_roles(inmate_role, reason="Jailed by Nova")
        
        # Try to move user to jail channel if they're in voice
        if user.voice:
            try:
                await user.move_to(jail_channel)
            except discord.Forbidden:
                pass  # Don't fail if we can't move them
            except Exception:
                pass  # Don't fail if we can't move them
        
        await interaction.response.send_message(embed=nova_embed("jAIL", f"{user.mention} hAS bEEN jAILED! tHEY cAN'T tALK aNYWHERE nOW!"))
    except discord.Forbidden:
        await interaction.response.send_message(embed=nova_embed("jAIL", "nO pERMISSION tO mANAGE rOLES oR cHANNELS!"), ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("jAIL", f"eRROR: {str(e)}"), ephemeral=True)

@bot.command()
async def runway(ctx, message_id: int = None):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("rUNWAY", "yOU dON'T hAVE pERMISSION!"))
        return
    if RUNWAY_CHANNEL_ID is None:
        await ctx.send(embed=nova_embed("rUNWAY", "rUNWAY cHANNEL nOT sET!"))
        return
    
    # Get the message to transfer
    if message_id:
        try:
            message = await ctx.channel.fetch_message(message_id)
        except discord.NotFound:
            await ctx.send(embed=nova_embed("rUNWAY", "mESSAGE nOT fOUND!"))
            return
        except discord.Forbidden:
            await ctx.send(embed=nova_embed("rUNWAY", "cAN'T aCCESS tHAT mESSAGE!"))
            return
    else:
        # Get the last message in the channel
        async for message in ctx.channel.history(limit=1):
            break
        else:
            await ctx.send(embed=nova_embed("rUNWAY", "nO mESSAGES tO tRANSFER!"))
            return
    
    try:
        runway_channel = ctx.guild.get_channel(RUNWAY_CHANNEL_ID)
        if not runway_channel:
            await ctx.send(embed=nova_embed("rUNWAY", "cOULD nOT fIND tHE rUNWAY cHANNEL!"))
            return
        
        # Create runway embed with crying emoji and message number
        embed = nova_embed("üò¢ #" + str(message.id), message.content)
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
        embed.add_field(name="oRIGINAL cHANNEL", value=ctx.channel.mention, inline=True)
        embed.set_footer(text=f"Message ID: {message.id}")
        
        # Send attachments separately if any
        files = []
        for attachment in message.attachments:
            try:
                file_data = await attachment.read()
                files.append(discord.File(io.BytesIO(file_data), filename=attachment.filename))
            except Exception:
                continue
        
        await runway_channel.send(embed=embed, files=files)
        await ctx.send(embed=nova_embed("rUNWAY", f"mESSAGE tRANSFERRED tO {runway_channel.mention}!"))
        
    except Exception as e:
        await ctx.send(embed=nova_embed("rUNWAY", f"eRROR: {str(e)}"))

@bot.tree.command(name="runway", description="Transfer a message to the runway channel (admin/mod only)")
@app_commands.describe(message_id="ID of the message to transfer (optional - uses last message)")
async def runway_slash(interaction: discord.Interaction, message_id: int = None):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("rUNWAY", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    if RUNWAY_CHANNEL_ID is None:
        await interaction.response.send_message(embed=nova_embed("rUNWAY", "rUNWAY cHANNEL nOT sET!"), ephemeral=True)
        return
    
    # Get the message to transfer
    if message_id:
        try:
            message = await interaction.channel.fetch_message(message_id)
        except discord.NotFound:
            await interaction.response.send_message(embed=nova_embed("rUNWAY", "mESSAGE nOT fOUND!"), ephemeral=True)
            return
        except discord.Forbidden:
            await interaction.response.send_message(embed=nova_embed("rUNWAY", "cAN'T aCCESS tHAT mESSAGE!"), ephemeral=True)
            return
    else:
        # Get the last message in the channel
        async for message in interaction.channel.history(limit=1):
            break
        else:
            await interaction.response.send_message(embed=nova_embed("rUNWAY", "nO mESSAGES tO tRANSFER!"), ephemeral=True)
            return
    
    try:
        runway_channel = interaction.guild.get_channel(RUNWAY_CHANNEL_ID)
        if not runway_channel:
            await interaction.response.send_message(embed=nova_embed("rUNWAY", "cOULD nOT fIND tHE rUNWAY cHANNEL!"), ephemeral=True)
            return
        
        # Create runway embed with crying emoji and message number
        embed = nova_embed("üò¢ #" + str(message.id), message.content)
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
        embed.add_field(name="oRIGINAL cHANNEL", value=interaction.channel.mention, inline=True)
        embed.set_footer(text=f"Message ID: {message.id}")
        
        # Send attachments separately if any
        files = []
        for attachment in message.attachments:
            try:
                file_data = await attachment.read()
                files.append(discord.File(io.BytesIO(file_data), filename=attachment.filename))
            except Exception:
                continue
        
        await runway_channel.send(embed=embed, files=files)
        await interaction.response.send_message(embed=nova_embed("rUNWAY", f"mESSAGE tRANSFERRED tO {runway_channel.mention}!"), ephemeral=True)
        
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("rUNWAY", f"eRROR: {str(e)}"), ephemeral=True)

@bot.command()
async def setautoplay(ctx, channel: discord.VoiceChannel):
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    await ctx.send("Set autoplay channel feature coming soon!")

@bot.command()
async def playlistshow(ctx):
    await ctx.send("Playlist show feature coming soon!")

@bot.command()
async def chatgpt(ctx, *, prompt: str):
    """Talk to ChatGPT!"""
    await ctx.send("ChatGPT feature coming soon!")

@bot.command()
async def generate(ctx, *, prompt: str):
    """Generate creative content with ChatGPT."""
    await ctx.send("Generate feature coming soon!")

# Helper functions for relationships

def load_relationships():
    try:
        with open(RELATIONSHIPS_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_relationships(relationships):
    with open(RELATIONSHIPS_FILE, "w") as f:
        json.dump(relationships, f)

def load_reminders():
    try:
        with open(REMINDERS_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_reminders(reminders):
    with open(REMINDERS_FILE, "w") as f:
        json.dump(reminders, f)

def parse_time(timestr):
    match = re.match(r"(\d+)([smhd])", timestr.lower())
    if not match:
        return None
    num, unit = int(match.group(1)), match.group(2)
    if unit == 's': return num
    if unit == 'm': return num * 60
    if unit == 'h': return num * 3600
    if unit == 'd': return num * 86400
    return None

async def reminder_task(user_id, reminder_id, seconds, message):
    await asyncio.sleep(seconds)
    user = await bot.fetch_user(int(user_id))
    embed = nova_embed("rEMINDER!", f"‚è∞ {message}")
    try:
        await user.send(embed=embed)
    except Exception:
        pass
    reminders = load_reminders()
    user_reminders = reminders.get(str(user_id), {})
    if reminder_id in user_reminders:
        del user_reminders[reminder_id]
        reminders[str(user_id)] = user_reminders
        save_reminders(reminders)

CONFESS_CHANNEL_ID = 1391874227774165132

@bot.command()
async def unjail(ctx, user: discord.Member):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("uNJAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    try:
        # Remove inmate role
        inmate_role = discord.utils.get(ctx.guild.roles, name="iNMATE")
        if inmate_role and inmate_role in user.roles:
            await user.remove_roles(inmate_role, reason="Unjailed by Nova")
            await ctx.send(embed=nova_embed("uNJAIL", f"{user.mention} hAS bEEN uNJAILed!"))
        else:
            await ctx.send(embed=nova_embed("uNJAIL", f"{user.mention} iS nOT jAILED!"))
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("uNJAIL", "nO pERMISSION tO mANAGE rOLES!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("uNJAIL", f"eRROR: {str(e)}"))

@bot.tree.command(name="unjail", description="Remove a user from jail (admin/mod only)")
@app_commands.describe(user="The user to unjail")
async def unjail_slash(interaction: discord.Interaction, user: discord.Member):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("uNJAIL", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        # Remove inmate role
        inmate_role = discord.utils.get(interaction.guild.roles, name="iNMATE")
        if inmate_role and inmate_role in user.roles:
            await user.remove_roles(inmate_role, reason="Unjailed by Nova")
            await interaction.response.send_message(embed=nova_embed("uNJAIL", f"{user.mention} hAS bEEN uNJAILed!"))
        else:
            await interaction.response.send_message(embed=nova_embed("uNJAIL", f"{user.mention} iS nOT jAILED!"), ephemeral=True)
    except discord.Forbidden:
        await interaction.response.send_message(embed=nova_embed("uNJAIL", "nO pERMISSION tO mANAGE rOLES!"), ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("uNJAIL", f"eRROR: {str(e)}"), ephemeral=True)

SHOP_ITEMS = {
    "cUSTOM rOLE": 5000,
    "xP bOOST": 2000,
    "sHOUTOUT": 2000,
    "pROMOTE yOURSELF": 5000,
    "rING a uSER": 2000,
    "cUSTOMIZE nOVA'S bIO (24h)": 10000
}
INVENTORY_FILE = "inventory.json"

def load_inventory():
    try:
        with open(INVENTORY_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_inventory(inventory):
    with open(INVENTORY_FILE, "w") as f:
        json.dump(inventory, f)

def load_thrift():
    try:
        with open(THRIFT_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def save_thrift(thrift):
    with open(THRIFT_FILE, "w") as f:
        json.dump(thrift, f)

@bot.command()
async def sell(ctx, item: str, price: int):
    item = item.strip()
    if price <= 0:
        await ctx.send(embed=nova_embed("sELL", "pRICE mUST bE pOSITIVE!"))
        return
    inventory = load_inventory()
    user_inv = inventory.get(str(ctx.author.id), [])
    matched = next((i for i in user_inv if i.lower() == item.lower()), None)
    if not matched:
        await ctx.send(embed=nova_embed("sELL", "yOU dON'T oWN tHAT iTEM!"))
        return
    user_inv.remove(matched)
    inventory[str(ctx.author.id)] = user_inv
    save_inventory(inventory)
    thrift = load_thrift()
    thrift.append({"item": matched, "price": price, "seller": ctx.author.id})
    save_thrift(thrift)
    await ctx.send(embed=nova_embed("sELL", f"yOU lISTED {matched} fOR sALE aT {price} {CURRENCY_NAME} iN tHE tHRIFT sTORE!"))

@bot.tree.command(name="sell", description="Sell an item from your inventory at a custom price")
@app_commands.describe(item="The item to sell", price="Sale price")
async def sell_slash(interaction: discord.Interaction, item: str, price: int):
    item = item.strip()
    if price <= 0:
        await interaction.response.send_message(embed=nova_embed("sELL", "pRICE mUST bE pOSITIVE!"), ephemeral=True)
        return
    inventory = load_inventory()
    user_inv = inventory.get(str(interaction.user.id), [])
    matched = next((i for i in user_inv if i.lower() == item.lower()), None)
    if not matched:
        await interaction.response.send_message(embed=nova_embed("sELL", "yOU dON'T oWN tHAT iTEM!"), ephemeral=True)
        return
    user_inv.remove(matched)
    inventory[str(interaction.user.id)] = user_inv
    save_inventory(inventory)
    thrift = load_thrift()
    thrift.append({"item": matched, "price": price, "seller": interaction.user.id})
    save_thrift(thrift)
    await interaction.response.send_message(embed=nova_embed("sELL", f"yOU lISTED {matched} fOR sALE aT {price} {CURRENCY_NAME} iN tHE tHRIFT sTORE!"))

@bot.command()
async def thrift(ctx):
    thrift = load_thrift()
    if not thrift:
        await ctx.send(embed=nova_embed("tHRIFT sTORE", "nO iTEMS fOR sALE rIGHT nOW!"))
        return
    lines = []
    for idx, entry in enumerate(thrift, 1):
        seller = ctx.guild.get_member(entry["seller"])
        seller_name = seller.display_name if seller else f"<@{entry['seller']}>"
        lines.append(f"{idx}. {entry['item']} ‚Äî {entry['price']} {CURRENCY_NAME} (by {seller_name})")
    await ctx.send(embed=nova_embed("tHRIFT sTORE", "\n".join(lines)))

@bot.tree.command(name="thrift", description="Show the thrift store (member sales)")
async def thrift_slash(interaction: discord.Interaction):
    thrift = load_thrift()
    if not thrift:
        await interaction.response.send_message(embed=nova_embed("tHRIFT sTORE", "nO iTEMS fOR sALE rIGHT nOW!"), ephemeral=True)
        return
    lines = []
    for idx, entry in enumerate(thrift, 1):
        seller = interaction.guild.get_member(entry["seller"])
        seller_name = seller.display_name if seller else f"<@{entry['seller']}>"
        lines.append(f"{idx}. {entry['item']} ‚Äî {entry['price']} {CURRENCY_NAME} (by {seller_name})")
    await interaction.response.send_message(embed=nova_embed("tHRIFT sTORE", "\n".join(lines)))

@bot.command()
async def buythrift(ctx, idx: int):
    thrift = load_thrift()
    if idx < 1 or idx > len(thrift):
        await ctx.send(embed=nova_embed("bUY tHRIFT", "iNVALID iTEM nUMBER!"))
        return
    entry = thrift[idx-1]
    if get_balance(ctx.author.id) < entry["price"]:
        await ctx.send(embed=nova_embed("bUY tHRIFT", "nOT eNOUGH dOLLARIANAS!"))
        return
    if entry["seller"] == ctx.author.id:
        await ctx.send(embed=nova_embed("bUY tHRIFT", "yOU cAN'T bUY yOUR oWN iTEM!"))
        return
    change_balance(ctx.author.id, -entry["price"])
    change_balance(entry["seller"], entry["price"])
    inventory = load_inventory()
    user_inv = inventory.get(str(ctx.author.id), [])
    user_inv.append(entry["item"])
    inventory[str(ctx.author.id)] = user_inv
    save_inventory(inventory)
    del thrift[idx-1]
    save_thrift(thrift)
    await ctx.send(embed=nova_embed("bUY tHRIFT", f"yOU bOUGHT {entry['item']} fOR {entry['price']} {CURRENCY_NAME}!"))

@bot.tree.command(name="buythrift", description="Buy an item from the thrift store")
@app_commands.describe(idx="The item number from /thrift")
async def buythrift_slash(interaction: discord.Interaction, idx: int):
    thrift = load_thrift()
    if idx < 1 or idx > len(thrift):
        await interaction.response.send_message(embed=nova_embed("bUY tHRIFT", "iNVALID iTEM nUMBER!"), ephemeral=True)
        return
    entry = thrift[idx-1]
    if get_balance(interaction.user.id) < entry["price"]:
        await interaction.response.send_message(embed=nova_embed("bUY tHRIFT", "nOT eNOUGH dOLLARIANAS!"), ephemeral=True)
        return
    if entry["seller"] == interaction.user.id:
        await interaction.response.send_message(embed=nova_embed("bUY tHRIFT", "yOU cAN'T bUY yOUR oWN iTEM!"), ephemeral=True)
        return
    change_balance(interaction.user.id, -entry["price"])
    change_balance(entry["seller"], entry["price"])
    inventory = load_inventory()
    user_inv = inventory.get(str(interaction.user.id), [])
    user_inv.append(entry["item"])
    inventory[str(interaction.user.id)] = user_inv
    save_inventory(inventory)
    del thrift[idx-1]
    save_thrift(thrift)
    await interaction.response.send_message(embed=nova_embed("bUY tHRIFT", f"yOU bOUGHT {entry['item']} fOR {entry['price']} {CURRENCY_NAME}!"))

# Store last deleted and edited messages per channel
snipes = {}
edsnipes = {}
rsnipes = {}  # channel_id: {'emoji': str, 'user': str, 'message_id': int, 'jump_url': str, 'time': datetime}

@bot.event
async def on_message_delete(message):
    if message.author.bot:
        return
    snipes[message.channel.id] = {
        'content': message.content,
        'author': str(message.author),
        'time': message.created_at
    }
    # Chat logs for mods - server-specific
    if message.guild:
        chat_logs_id = config.get(f"chat_logs_channel_id_{message.guild.id}")
        if chat_logs_id:
            log_channel = message.guild.get_channel(chat_logs_id)
            if log_channel:
                embed = nova_embed("üóëÔ∏è Message Deleted", f"**Author:** {message.author}\n**Channel:** {message.channel.mention}\n**Content:** {message.content}")
                embed.timestamp = datetime.now(timezone.utc)
                await log_channel.send(embed=embed)

@bot.event
async def on_message_edit(before, after):
    if before.author.bot or before.content == after.content:
        return
    edsnipes[before.channel.id] = {
        'content': before.content,
        'author': str(before.author),
        'time': before.edited_at or before.created_at
    }
    # Chat logs for mods - server-specific
    if before.guild:
        chat_logs_id = config.get(f"chat_logs_channel_id_{before.guild.id}")
        if chat_logs_id:
            log_channel = before.guild.get_channel(chat_logs_id)
            if log_channel:
                embed = nova_embed("‚úèÔ∏è Message Edited", f"**Author:** {before.author}\n**Channel:** {before.channel.mention}\n**Before:** {before.content}\n**After:** {after.content}")
                embed.timestamp = datetime.now(timezone.utc)
                await log_channel.send(embed=embed)

@bot.event
async def on_raw_reaction_remove(payload):
    # Store the last removed reaction for rsnipe
    if payload.guild_id is None:
        return
    channel = bot.get_channel(payload.channel_id)
    if channel is None:
        return
    user = None
    guild = bot.get_guild(payload.guild_id)
    if guild:
        user = guild.get_member(payload.user_id)
    if user is None or user.bot:
        return
    try:
        message = await channel.fetch_message(payload.message_id)
    except Exception:
        message = None
    jump_url = message.jump_url if message else None
    rsnipes[payload.channel_id] = {
        'emoji': str(payload.emoji),
        'user': str(user),
        'message_id': payload.message_id,
        'jump_url': jump_url,
        'time': datetime.now(timezone.utc)
    }

@bot.command()
async def rsnipe(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("rSNIPE", "yOU dON'T hAVE pERMISSION!"))
        return
    data = rsnipes.get(ctx.channel.id)
    if not data:
        await ctx.send(embed=nova_embed("rSNIPE", "nOTHING tO rSNIPE!"))
        return
    desc = f"{data['user']} rEMOVED rEACTION {data['emoji']}"
    if data['jump_url']:
        desc += f"\n[Jump to message]({data['jump_url']})"
    embed = nova_embed("rSNIPE", desc)
    embed.set_footer(text=f"{data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)

@bot.tree.command(name="rsnipe", description="Show the last removed reaction in this channel")
async def rsnipe_slash(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("rSNIPE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    data = rsnipes.get(interaction.channel.id)
    if not data:
        await interaction.response.send_message(embed=nova_embed("rSNIPE", "nOTHING tO rSNIPE!"), ephemeral=True)
        return
    desc = f"{data['user']} rEMOVED rEACTION {data['emoji']}"
    if data['jump_url']:
        desc += f"\n[Jump to message]({data['jump_url']})"
    embed = nova_embed("rSNIPE", desc)
    embed.set_footer(text=f"{data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed, ephemeral=True)

# Store moderation cases per guild
mod_cases = {}

def set_server_config(guild_id, key, value):
    """Set a configuration value for a specific server"""
    if guild_id not in SERVER_CONFIGS:
        SERVER_CONFIGS[guild_id] = {}
    SERVER_CONFIGS[guild_id][key] = value

# Helper functions for server-specific logging channels
def get_server_logs_channel(guild):
    """Get the server logs channel for a specific guild"""
    if not guild:
        return None
    channel_id = get_server_config(guild.id, "server_logs_channel_id")
    return guild.get_channel(channel_id) if channel_id else None

def get_mod_logs_channel(guild):
    """Get the mod logs channel for a specific guild"""
    if not guild:
        return None
    channel_id = get_server_config(guild.id, "mod_logs_channel_id")
    return guild.get_channel(channel_id) if channel_id else None

def get_chat_logs_channel(guild):
    """Get the chat logs channel for a specific guild"""
    if not guild:
        return None
    channel_id = get_server_config(guild.id, "chat_logs_channel_id")
    return guild.get_channel(channel_id) if channel_id else None

def get_join_leave_logs_channel(guild):
    """Get the join/leave logs channel for a specific guild"""
    if not guild:
        return None
    channel_id = get_server_config(guild.id, "join_leave_logs_channel_id")
    return guild.get_channel(channel_id) if channel_id else None

def log_case(guild_id, action, user, channel, time):
    if guild_id not in mod_cases:
        mod_cases[guild_id] = []
    mod_cases[guild_id].insert(0, {
        'action': action,
        'user': str(user),
        'channel': str(channel),
        'time': time
    })
    if len(mod_cases[guild_id]) > 20:
        mod_cases[guild_id] = mod_cases[guild_id][:20]

@bot.command()
async def dmtest(ctx):
    if ctx.guild is None:
        # In a DM
        await ctx.send(embed=nova_embed("dM tEST", "yOU'RE iN mY dMS, bABY! üíå"))
    else:
        # In a server
        await ctx.send(embed=nova_embed("dM tEST", "yOU'RE iN a sERVER, hONEY! üíÖ"))

@bot.command()
async def endimposter(ctx):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("eND iMPOSTER", "yOU dON'T hAVE pERMISSION!"))
        return
    game = IMPOSTER_GAMES.get(ctx.channel.id)
    if not game or not game.active:
        await ctx.send(embed=nova_embed("eND iMPOSTER", "nO aCTIVE iMPOSTER gAME tO eND!"))
        return
    game.end()
    del IMPOSTER_GAMES[ctx.channel.id]
    await ctx.send(embed=nova_embed("eND iMPOSTER", "tHE iMPOSTER gAME hAS bEEN eNDED bY a mOD!"))

@bot.command()
async def setchatlogs(ctx, channel: discord.TextChannel = None):
    """Set the chat logs channel for mod-only logs."""
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    if channel is None:
        config[f"chat_logs_channel_id_{ctx.guild.id}"] = None
        save_config()
        await ctx.send("Chat logs channel unset for this server.")
        return
    config[f"chat_logs_channel_id_{ctx.guild.id}"] = channel.id
    save_config()
    await ctx.send(f"Chat logs channel set to {channel.mention} for this server.")

@bot.tree.command(name="setchatlogs", description="Set the chat logs channel for mod-only logs.")
@app_commands.describe(channel="The channel to log deleted/edited messages")
async def setchatlogs_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    config[f"chat_logs_channel_id_{interaction.guild.id}"] = channel.id
    save_config()
    await interaction.response.send_message(f"Chat logs channel set to {channel.mention} for this server.", ephemeral=True)

# Welcome/Farewell system
WELCOME_CHANNEL_ID = None  # Set by ?setwelcome
FAREWELL_CHANNEL_ID = None  # Set by ?setfarewell

@bot.command()
async def setwelcome(ctx, channel: discord.TextChannel = None):
    """Set the welcome channel."""
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    global WELCOME_CHANNEL_ID
    if channel is None:
        WELCOME_CHANNEL_ID = None
        save_config()
        await ctx.send("Welcome channel unset.")
        return
    WELCOME_CHANNEL_ID = channel.id
    save_config()
    await ctx.send(f"Welcome channel set to {channel.mention}.")

@bot.tree.command(name="setwelcome", description="Set the welcome channel.")
@app_commands.describe(channel="The channel to send welcome messages")
async def setwelcome_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    global WELCOME_CHANNEL_ID
    WELCOME_CHANNEL_ID = channel.id
    save_config()
    await interaction.response.send_message(f"Welcome channel set to {channel.mention}.", ephemeral=True)

@bot.command()
async def setfarewell(ctx, channel: discord.TextChannel = None):
    """Set the farewell channel."""
    if not has_mod_or_admin(ctx):
        await ctx.send("You don't have permission to use this command.")
        return
    global FAREWELL_CHANNEL_ID
    if channel is None:
        FAREWELL_CHANNEL_ID = None
        save_config()
        await ctx.send("Farewell channel unset.")
        return
    FAREWELL_CHANNEL_ID = channel.id
    save_config()
    await ctx.send(f"Farewell channel set to {channel.mention}.")

@bot.tree.command(name="setfarewell", description="Set the farewell channel.")
@app_commands.describe(channel="The channel to send farewell messages")
async def setfarewell_slash(interaction: discord.Interaction, channel: discord.TextChannel):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message("You don't have permission to use this command.", ephemeral=True)
        return
    global FAREWELL_CHANNEL_ID
    FAREWELL_CHANNEL_ID = channel.id
    save_config()
    await interaction.response.send_message(f"Farewell channel set to {channel.mention}.", ephemeral=True)

@bot.event
async def on_member_join(member):
    if WELCOME_CHANNEL_ID:
        channel = member.guild.get_channel(WELCOME_CHANNEL_ID)
        if channel:
            embed = nova_embed("üëã wELCOME!", f"wELCOME tO tHE sERVER, {member.mention}! mAKE yOURSELF aT hOME! üíñ")
            await channel.send(embed=embed)

@bot.event
async def on_member_remove(member):
    if FAREWELL_CHANNEL_ID:
        channel = member.guild.get_channel(FAREWELL_CHANNEL_ID)
        if channel:
            embed = nova_embed("üëã fAREWELL!", f"{member.display_name} hAS lEFT tHE sERVER. wE'LL mISS yOU! üò¢")
            await channel.send(embed=embed)
@bot.command()
async def imposter(ctx):
    if ctx.guild is None:
        await ctx.send(embed=nova_embed("iMPOSTER", "tHIS cOMMAND mUST bE uSED iN a sERVER cHANNEL!"))
        return
    word_list = [
        "banana", "apple", "grape", "peach", "lemon", "carrot", "onion", "potato", "pizza", "burger",
        "sushi", "taco", "pasta", "croissant", "ramen", "falafel", "burrito", "cheesecake", "donut", "waffle",
        "mountain", "beach", "desert", "forest", "island", "volcano", "river", "ocean", "cave", "valley",
        "laptop", "phone", "keyboard", "camera", "guitar", "piano", "bicycle", "skateboard", "umbrella", "backpack",
        "dragon", "unicorn", "zombie", "robot", "pirate", "wizard", "ghost", "alien", "vampire", "mermaid",
        "diamond", "gold", "ruby", "sapphire", "emerald", "pearl", "opal", "jade", "topaz", "amethyst"
    ]
    join_msg = await ctx.send(embed=nova_embed("iMPOSTER gAME", f"rEACT wITH üïµÔ∏è tO jOIN!\n\nyOU hAVE 30 sECONDS..."))
    await join_msg.add_reaction("üïµÔ∏è")
    reacted_users = set()
    def check(reaction, user):
        return (
            reaction.message.id == join_msg.id and
            str(reaction.emoji) == "üïµÔ∏è" and
            not user.bot and
            user not in reacted_users
        )
    
    try:
        while True:
            reaction, user = await bot.wait_for("reaction_add", timeout=30.0, check=check)
            reacted_users.add(user)
    except asyncio.TimeoutError:
        pass
    players = list(reacted_users)
    if len(players) < 3:
        await ctx.send(embed=nova_embed("iMPOSTER", "nOT eNOUGH pLAYERS rEACTED! gAME cANCELLED, bABY!"))
        return
    imposter = random.choice(players)
    secret_word = random.choice(word_list)
    imposter_word = random.choice([w for w in word_list if w != secret_word])
    failed = []
    for m in players:
        try:
            if m == imposter:
                await m.send(embed=nova_embed("iMPOSTER wORD", f"yOU aRE tHE iMPOSTER! yOUR wORD iS: **{imposter_word}**"))
            else:
                await m.send(embed=nova_embed("iMPOSTER wORD", f"yOUR wORD iS: **{secret_word}**"))
        except Exception:
            failed.append(m.display_name)
    joined_names = ", ".join([f"**{u.display_name}**" for u in players])
    await ctx.send(embed=nova_embed("iMPOSTER", f"aLL sECRET wORDS hAVE bEEN sENT!\n\n**pLAYERS:** {joined_names}"))
    if failed:
        await ctx.send(embed=nova_embed("iMPOSTER", f"cOULD nOT dM: {', '.join(failed)}"))
    # --- Rounds ---
    round_num = 1
    max_rounds = 10
    game_over = False
    while round_num <= max_rounds and not game_over:
        await ctx.send(embed=nova_embed(f"rOUND {round_num}", "eVERYONE, sAY yOUR wORD! nOVA wILL tAG yOU oNE bY oNE."))
        for p in players:
            await ctx.send(f"{p.mention}, iT'S yOUR tURN tO sAY yOUR wORD!")
            def msg_check(m):
                return m.author == p and m.channel == ctx.channel
            try:
                await bot.wait_for("message", timeout=60.0, check=msg_check)
            except asyncio.TimeoutError:
                await ctx.send(f"{p.mention} dID nOT rESPOND iN tIME!")
        # Voting to continue or end
        vote_msg = await ctx.send(embed=nova_embed("cONTINUE oR eND?", "rEACT wITH ‚úÖ tO cONTINUE, ‚ùå tO eND tHE gAME!"))
        await vote_msg.add_reaction("‚úÖ")
        await vote_msg.add_reaction("‚ùå")
        await asyncio.sleep(20)  # 20 seconds to vote
        vote_msg = await ctx.channel.fetch_message(vote_msg.id)
        cont_votes = 0
        end_votes = 0
        for reaction in vote_msg.reactions:
            if str(reaction.emoji) == "‚úÖ":
                cont_votes = reaction.count - 1
            elif str(reaction.emoji) == "‚ùå":
                end_votes = reaction.count - 1
        if end_votes > cont_votes:
            game_over = True
            await ctx.send(embed=nova_embed("gAME eNDING", "mAJORITY vOTED tO eND tHE gAME!"))
        else:
         round_num += 1
    # --- Final Voting ---
    await ctx.send(embed=nova_embed("vOTE tHE iMPOSTER!", "rEACT wITH tHE eMOJI fOR wHO yOU tHINK iS tHE iMPOSTER!"))
    emojis = [chr(0x1F1E6 + i) for i in range(len(players))]  # üá¶, üáß, üá®, ...
    vote_embed = discord.Embed(title="vOTE tHE iMPOSTER!", description="\n".join([f"{emojis[i]} {players[i].mention}" for i in range(len(players))]), color=0xff69b4)
    vote_embed.set_footer(text="nOVA")
    vote_msg = await ctx.send(embed=vote_embed)
    for e in emojis:
        await vote_msg.add_reaction(e)
    await asyncio.sleep(20)  # 20 seconds to vote
    vote_msg = await ctx.channel.fetch_message(vote_msg.id)
    votes = [0] * len(players)
    for reaction in vote_msg.reactions:
        if reaction.emoji in emojis:
            idx = emojis.index(reaction.emoji)
            votes[idx] = reaction.count - 1
    max_votes = max(votes)
    if votes.count(max_votes) > 1:
        await ctx.send(embed=nova_embed("nO wINNER", "iT'S a tIE! nO oNE wINS!"))
        return
    voted_idx = votes.index(max_votes)
    voted_player = players[voted_idx]
    if voted_player == imposter:
        # Crew wins
        for p in players:
            if p != imposter:
                change_balance(p.id, 200)
        await ctx.send(embed=nova_embed("cREW wINS!", f"tHE cREW fOUND tHE iMPOSTER!\n\n{imposter.mention} wAS tHE iMPOSTER!\n\n{', '.join([pl.mention for pl in players if pl != imposter])} gET 200 {CURRENCY_NAME} eACH!"))
    else:
        # Imposter wins
        change_balance(imposter.id, 500)
        await ctx.send(embed=nova_embed("iMPOSTER wINS!", f"{imposter.mention} sURVIVED! tHEY gET 500 {CURRENCY_NAME}!"))

@bot.tree.command(name="imposter", description="Start an imposter game and DM secret words!")
async def imposter_slash(interaction: discord.Interaction):
    if interaction.guild is None or interaction.channel is None:
        await interaction.response.send_message(embed=nova_embed("iMPOSTER", "tHIS cOMMAND mUST bE uSED iN a sERVER cHANNEL!"), ephemeral=True)
        return
    await interaction.response.defer(ephemeral=True, thinking=True)
    # Get all non-bot members who can see the channel
    channel = interaction.channel
    if not hasattr(channel, 'members'):
        await interaction.followup.send(embed=nova_embed("iMPOSTER", "cOULD nOT gET cHANNEL mEMBERS!"), ephemeral=True)
        return
    members = [m for m in channel.members if not m.bot]
    if len(members) < 3:
        await interaction.followup.send(embed=nova_embed("iMPOSTER", "nEED aT lEAST 3 pEOPLE tO pLAY!"), ephemeral=True)
        return
    imposter = random.choice(members)
    word_list = ["banana", "apple", "grape", "peach", "lemon", "carrot", "onion", "potato", "pizza", "burger"]
    secret_word = random.choice(word_list)
    imposter_word = random.choice([w for w in word_list if w != secret_word])
    # Send game start message
    msg = await channel.send(embed=nova_embed("iMPOSTER gAME", f"rEACT wITH üïµÔ∏è tO tHIS mESSAGE tO jOIN!\n\nyOU hAVE 45 sECONDS..."))
    await msg.add_reaction("üïµÔ∏è")
    failed = []
    for m in members:
        try:
            if m == imposter:
                await m.send(embed=nova_embed("iMPOSTER wORD", f"yOU aRE tHE iMPOSTER! yOUR wORD iS: **{imposter_word}**"))
            else:
                await m.send(embed=nova_embed("iMPOSTER wORD", f"yOUR wORD iS: **{secret_word}**"))
        except Exception:
            failed.append(m.display_name)
    if failed:
        await channel.send(embed=nova_embed("iMPOSTER", f"cOULD nOT dM: {', '.join(failed)}"))
    await channel.send(embed=nova_embed("iMPOSTER", "aLL sECRET wORDS hAVE bEEN sENT!"))
    await interaction.followup.send(embed=nova_embed("iMPOSTER", "gAME sTARTED! cHECK yOUR dMS!"), ephemeral=True)
    

@bot.command()
async def warn(ctx, member: discord.Member = None, *, reason="No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("wARN", "yOU dON'T hAVE pERMISSION!"))
        return
    if member is None:
        await ctx.send("Usage: ?warn @user [reason] - Warns a member. Only mods/admins can use this.")
        return
    try:
        # Log the warning
        log_case(ctx.guild.id, "Warn", ctx.author, ctx.channel, datetime.now(timezone.utc))
        # DM the user
        try:
            await member.send(embed=nova_embed("wARNED bY nOVA", f"yOU wERE wARNED iN {ctx.guild.name} bY {ctx.author.mention} fOR: {reason}"))
        except Exception:
            pass  # Ignore if DMs are closed
        await ctx.send(embed=nova_embed("wARN", f"{member.mention} wAS wARNED fOR: {reason}"))
        await ctx.send("Usage: ?warn @user [reason] - Warns a member. Only mods/admins can use this.")
    except Exception as e:
        await ctx.send(embed=nova_embed("wARN", f"cOULD nOT wARN: {e}"))

# Slash command version of warn
@bot.tree.command(name="warn", description="Warn a member (mods only)")
@app_commands.describe(member="The member to warn", reason="Reason for warning")
async def warn_slash(interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
    ctx = await bot.get_context(interaction)
    if not has_mod_or_admin(ctx):
        await interaction.response.send_message(embed=nova_embed("wARN", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    try:
        log_case(interaction.guild.id, "Warn", interaction.user, interaction.channel, datetime.now(timezone.utc))
        try:
            await member.send(embed=nova_embed("wARNED bY nOVA", f"yOU wERE wARNED iN {interaction.guild.name} bY {interaction.user.mention} fOR: {reason}"))
        except Exception:
            pass
        await interaction.response.send_message(embed=nova_embed("wARN", f"{member.mention} wAS wARNED fOR: {reason}"))
        await interaction.followup.send("Usage: /warn @user [reason] - Warns a member. Only mods/admins can use this.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("wARN", f"cOULD nOT wARN: {e}"), ephemeral=True)

# Pet System Commands
PET_DATA = {}  # user_id: {"name": str, "type": str, "level": int, "xp": int, "hunger": int, "cleanliness": int, "happiness": int}

def load_pets():
    global PET_DATA
    try:
        with open("pets.json", "r") as f:
            PET_DATA = json.load(f)
    except FileNotFoundError:
        PET_DATA = {}

def save_pets():
    with open("pets.json", "w") as f:
        json.dump(PET_DATA, f, indent=4)

class PetView(discord.ui.View):
    def __init__(self, user_id):
        super().__init__(timeout=300)
        self.user_id = user_id
    
    @discord.ui.button(label='Feed', style=discord.ButtonStyle.primary, emoji='üçé')
    async def feed_pet(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("tHIS iSN'T yOUR pET!", ephemeral=True)
            return
        
        pet = PET_DATA[self.user_id]
        if pet["hunger"] >= 100:
            await interaction.response.send_message(f"{pet['name']} iS aLREADY fULL!", ephemeral=True)
            return
        
        pet["hunger"] = min(100, pet["hunger"] + 25)
        pet["happiness"] = min(100, pet["happiness"] + 5)
        pet["xp"] += 2
        save_pets()
        
        await interaction.response.send_message(f"yOU fED {pet['name']}! hUNGER: {pet['hunger']}/100")
    
    @discord.ui.button(label='Clean', style=discord.ButtonStyle.secondary, emoji='üßΩ')
    async def clean_pet(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("tHIS iSN'T yOUR pET!", ephemeral=True)
            return
        
        pet = PET_DATA[self.user_id]
        if pet["cleanliness"] >= 100:
            await interaction.response.send_message(f"{pet['name']} iS aLREADY cLEAN!", ephemeral=True)
            return
        
        pet["cleanliness"] = min(100, pet["cleanliness"] + 30)
        pet["happiness"] = min(100, pet["happiness"] + 5)
        pet["xp"] += 3
        save_pets()
        
        await interaction.response.send_message(f"yOU cLEANED {pet['name']}! cLEANLINESS: {pet['cleanliness']}/100")
    
    @discord.ui.button(label='Play', style=discord.ButtonStyle.success, emoji='üéæ')
    async def play_pet(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id:
            await interaction.response.send_message("tHIS iSN'T yOUR pET!", ephemeral=True)
            return
        
        pet = PET_DATA[self.user_id]
        pet["happiness"] = min(100, pet["happiness"] + 15)
        pet["hunger"] = max(0, pet["hunger"] - 5)
        pet["cleanliness"] = max(0, pet["cleanliness"] - 5)
        pet["xp"] += 5
        save_pets()
        
        await interaction.response.send_message(f"yOU pLAYED wITH {pet['name']}! hAPPINESS: {pet['happiness']}/100")

@bot.command()
async def adoptpet(ctx):
    """Adopt a virtual pet"""
    user_id = str(ctx.author.id)
    
    if user_id in PET_DATA:
        await ctx.send(embed=nova_embed("aDOPT pET", f"yOU aLREADY hAVE a pET nAMED {PET_DATA[user_id]['name']}!"))
        return
    
    animals = ["Cat", "Dog", "Red Panda", "Raven", "Octopus", "Goldfish", "Tortoise", "Owl", "Lizard", "Bat", "Dove", "Fox"]
    animal_emojis = {"Cat": "üê±", "Dog": "üê∂", "Red Panda": "üêº", "Raven": "üê¶‚Äç‚¨õ", "Octopus": "üêô", 
                    "Goldfish": "üê†", "Tortoise": "üê¢", "Owl": "ü¶â", "Lizard": "ü¶é", "Bat": "ü¶á", "Dove": "üïäÔ∏è", "Fox": "ü¶ä"}
    
    animal_list = "\n".join([f"{animal_emojis[animal]} {animal}" for animal in animals])
    
    embed = nova_embed(
        "üè† aDOPT a pET",
        f"cHOOSE yOUR pET:\n{animal_list}\n\ntYPE tHE aNIMAL nAME tO aDOPT!"
    )
    await ctx.send(embed=embed)
    
    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel and m.content.title() in animals
    
    try:
        msg = await bot.wait_for('message', check=check, timeout=30.0)
        chosen_animal = msg.content.title()
        
        await ctx.send(embed=nova_embed("nAME yOUR pET", f"wHAT wOULD yOU lIKE tO nAME yOUR {chosen_animal}?"))
        
        def name_check(m):
            return m.author == ctx.author and m.channel == ctx.channel and len(m.content) <= 20
        
        name_msg = await bot.wait_for('message', check=name_check, timeout=30.0)
        pet_name = name_msg.content
        
        # Create pet data
        PET_DATA[user_id] = {
            "name": pet_name,
            "type": chosen_animal,
            "level": 1,
            "xp": 0,
            "hunger": 100,
            "cleanliness": 100,
            "happiness": 100
        }
        save_pets()
        
        embed = nova_embed(
            "üéâ aDOPTION sUCCESSFUL!",
            f"cONGRATULATIONS! yOU aDOPTED {pet_name} tHE {chosen_animal}!\n"
            f"uSE `?pet` tO iNTERACT wITH yOUR nEW fRIEND!"
        )
        embed.set_thumbnail(url=ctx.author.avatar.url if ctx.author.avatar else None)
        await ctx.send(embed=embed)
        
    except asyncio.TimeoutError:
        await ctx.send(embed=nova_embed("aDOPT pET", "aDOPTION tIMED oUT! tRY aGAIN lATER."))

@bot.command()
async def pet(ctx):
    """Interact with your pet"""
    user_id = str(ctx.author.id)
    
    if user_id not in PET_DATA:
        await ctx.send(embed=nova_embed("pET", "yOU dON'T hAVE a pET! uSE `?adoptpet` tO gET oNE!"))
        return
    
    pet = PET_DATA[user_id]
    animal_emojis = {"Cat": "üê±", "Dog": "üê∂", "Red Panda": "üêº", "Raven": "üê¶‚Äç‚¨õ", "Octopus": "üêô", 
                    "Goldfish": "üê†", "Tortoise": "üê¢", "Owl": "ü¶â", "Lizard": "ü¶é", "Bat": "ü¶á", "Dove": "üïäÔ∏è", "Fox": "ü¶ä"}
    
    emoji = animal_emojis.get(pet["type"], "üêæ")
    
    embed = nova_embed(
        f"{emoji} {pet['name']} tHE {pet['type']}",
        f"**lEVEL:** {pet['level']} (XP: {pet['xp']})\n"
        f"**hUNGER:** {pet['hunger']}/100\n"
        f"**cLEANLINESS:** {pet['cleanliness']}/100\n"
        f"**hAPPINESS:** {pet['happiness']}/100"
    )
    
    view = PetView(user_id)
    await ctx.send(embed=embed, view=view)

@bot.command()
async def petname(ctx, *, new_name: str = None):
    """Change your pet's name (can only be done once)"""
    user_id = str(ctx.author.id)
    
    if user_id not in PET_DATA:
        await ctx.send(embed=nova_embed("pET nAME", "yOU dON'T hAVE a pET!"))
        return
    
    if not new_name:
        await ctx.send(embed=nova_embed("pET nAME", "pLEASE pROVIDE a nEW nAME!"))
        return
    
    if len(new_name) > 20:
        await ctx.send(embed=nova_embed("pET nAME", "nAME mUST bE 20 cHARACTERS oR lESS!"))
        return
    
    pet = PET_DATA[user_id]
    old_name = pet["name"]
    pet["name"] = new_name
    save_pets()
    
    await ctx.send(embed=nova_embed("pET nAME", f"yOUR pET'S nAME hAS bEEN cHANGED fROM {old_name} tO {new_name}!"))

@bot.command()
async def changepet(ctx):
    """Change your pet type (resets all stats)"""
    user_id = str(ctx.author.id)
    
    if user_id not in PET_DATA:
        await ctx.send(embed=nova_embed("cHANGE pET", "yOU dON'T hAVE a pET!"))
        return
    
    embed = nova_embed(
        "‚ö†Ô∏è cHANGE pET",
        "aRE yOU sURE yOU wANT tO cHANGE yOUR pET?\n"
        "tHIS wILL rESET aLL sTATS!\n\n"
        "tYPE 'yes' tO cONFIRM oR 'no' tO cANCEL"
    )
    await ctx.send(embed=embed)
    
    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel and m.content.lower() in ['yes', 'no']
    
    try:
        msg = await bot.wait_for('message', check=check, timeout=30.0)
        if msg.content.lower() == 'no':
            await ctx.send(embed=nova_embed("cHANGE pET", "cANCELLED!"))
            return
        
        # Delete current pet and start adoption process
        del PET_DATA[user_id]
        save_pets()
        await adoptpet(ctx)
        
    except asyncio.TimeoutError:
        await ctx.send(embed=nova_embed("cHANGE pET", "tIMED oUT!"))

# Additional missing commands
BLACKLIST_WORDS = set()
LOTTERY_PARTICIPANTS = set()

@bot.command()
async def blacklist(ctx, *, word=None):
    """Add or remove words from the blacklist (mods only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("bLACKLIST", "Only mods/admins can manage the blacklist!"))
        return
    
    if not word:
        if BLACKLIST_WORDS:
            word_list = ", ".join(BLACKLIST_WORDS)
            await ctx.send(embed=nova_embed("bLACKLIST", f"cURRENT bLACKLISTED wORDS: {word_list}"))
        else:
            await ctx.send(embed=nova_embed("bLACKLIST", "nO wORDS iN bLACKLIST!"))
        return
    
    word = word.lower()
    if word in BLACKLIST_WORDS:
        BLACKLIST_WORDS.remove(word)
        await ctx.send(embed=nova_embed("bLACKLIST", f"rEMOVED '{word}' fROM bLACKLIST!"))
    else:
        BLACKLIST_WORDS.add(word)
        await ctx.send(embed=nova_embed("bLACKLIST", f"aDDED '{word}' tO bLACKLIST!"))

@bot.command()
async def lottery(ctx, action=None, price: int = None):
    """Manage the weekly server lottery (owner only)"""
    if ctx.author.id != OWNER_ID:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "Only the owner can manage the lottery!"))
        return
    
    if action == "start":
        if not price or price < 1:
            await ctx.send(embed=nova_embed("üé∞ lOTTERY", "pLEASE pROVIDE a vALID tICKET pRICE!"))
            return
        LOTTERY_PARTICIPANTS.clear()
        await ctx.send(embed=nova_embed("üé∞ lOTTERY sTARTED!", f"tICKET pRICE: {price} {CURRENCY_NAME}\nuSE `?buyticket` tO eNTER!"))
    elif action == "draw":
        if not LOTTERY_PARTICIPANTS:
            await ctx.send(embed=nova_embed("üé∞ lOTTERY", "nO pARTICIPANTS!"))
            return
        winner = random.choice(list(LOTTERY_PARTICIPANTS))
        prize = len(LOTTERY_PARTICIPANTS) * (price or 100)
        add_balance(winner, prize)
        await ctx.send(embed=nova_embed("üé∞ lOTTERY wINNER!", f"<@{winner}> wON {prize} {CURRENCY_NAME}!"))
        LOTTERY_PARTICIPANTS.clear()
    else:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "uSAGE: ?lottery start <price> | ?lottery draw"))

# Additional missing commands from GitHub diff
@bot.command()
async def mood(ctx):
    moods = [
        "fEELING fANTABULOUS ",
        "i'M iN a cUNT mOOD ",
        "dRAMATIC tODAY ",
        "lIVING mY bEST lIFE ",
        "cHAOTIC eNERGY ",
        "sERVING lOOKS ",
        "bEING iCONIC ",
        "fEELING mYSELF ",
        "oN tOP oF tHE wORLD ",
        "uNSTOPPABLE "
    ]
    mood = random.choice(moods)
    await ctx.send(embed=nova_embed("mOOD", f"{ctx.author.mention} iS {mood}‚ú®"))

@bot.command()
async def avatar(ctx, user: discord.Member = None):
    user = user or ctx.author
    embed = nova_embed(
        title=f"{user.display_name}'s aVATAR",
        description=f"hERE'S tHE aVATAR fOR {user.mention}",
    )
    embed.set_image(url=user.avatar.url if user.avatar else user.default_avatar.url)
    await ctx.send(embed=embed)

@bot.command()
async def calc(ctx, *, equation: str):
    await ctx.send("Calculator feature coming soon!")

@bot.command()
async def today(ctx):
    """Shows today's international day, Nova style, in a vibrant embed."""
    now = datetime.now()
    key = now.strftime("%d-%m")
    day = INTERNATIONAL_DAYS.get(key)
    
    if day:
        embed = nova_embed(
            "üåç tODAY'S iNTERNATIONAL dAY",
            f"tODAY iS **{day}**!"
        )
        embed.add_field(name="dATE", value=now.strftime("%B %d, %Y"), inline=True)
        await ctx.send(embed=embed)
    else:
        await ctx.send(embed=nova_embed("üåç tODAY", "nO sPECIAL iNTERNATIONAL dAY tODAY!"))

@bot.command()
async def whoasked(ctx, user: discord.Member = None):
    if not user:
        await ctx.send(embed=nova_embed("wHO aSKED", "nOBODY aSKED fOR yOUR oPINION!"))
        return
    responses = [
        f"nOBODY aSKED {user.mention}!",
        f"{user.mention} wHO gAVE yOU pERMISSION tO sPEAK?",
        f"dID aNYONE aSK {user.mention}? i dON'T tHINK sO!",
        f"{user.mention} kEEP yOUR oPINIONS tO yOURSELF!"
    ]
    response = random.choice(responses)
    await ctx.send(embed=nova_embed("wHO aSKED", response))

@bot.command()
async def nicki(ctx):
    lyrics = [
        "lIKE mJ dOCTOR, tHEY kILLIN mE. pROPOFOl, i kNOW tHEY hOPE i fALL.bUT tELL eM wINNIN iS mY mUTHUFUCKIN pROTOCOl..",
        "mE, nICKI m, i gOT tOO mANY m'S!!!",
        "aYO tONIGHT iS tHE nIGHT tHAT iMMMA gET tWISTED, mYX mOSCATO n vODKA iMA mIX iT.",
        "i fLY wITH tHE sTARS iN tHE sKIES, i aM nO lONGER tRYING tO sURVIVE.",
        "yOU a sTUPID hOE, yOU a sTUPID hOE, yOU a sTUPID hOE."
    ]
    lyric = random.choice(lyrics)
    await ctx.send(embed=nova_embed("nICKI mINAJ", lyric))

@bot.command()
async def buyticket(ctx):
    """Buy a lottery ticket"""
    user_id = ctx.author.id
    if user_id in LOTTERY_PARTICIPANTS:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "yOU aLREADY bOUGHT a tICKET!"))
        return
    
    # Assume ticket price is stored somewhere or default to 100
    ticket_price = 100
    if get_balance(user_id) < ticket_price:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", f"yOU nEED {ticket_price} {CURRENCY_NAME} tO bUY a tICKET!"))
        return
    
    subtract_balance(user_id, ticket_price)
    LOTTERY_PARTICIPANTS.add(user_id)
    await ctx.send(embed=nova_embed("üé∞ lOTTERY", f"tICKET pURCHASED! gOOD lUCK!"))

@bot.command()
async def thrift(ctx):
    thrift = load_thrift()
    if not thrift:
        await ctx.send(embed=nova_embed("tHRIFT sTORE", "nO iTEMS fOR sALE rIGHT nOW!"))
        return
    
    embed = nova_embed("üõçÔ∏è tHRIFT sTORE", "cHECK oUT tHESE iTEMS!")
    for item_id, item_data in list(thrift.items())[:10]:  # Show first 10 items
        embed.add_field(
            name=f"{item_data['name']} - {item_data['price']} {CURRENCY_NAME}",
            value=f"sOLD bY: <@{item_data['seller']}>\nID: {item_id}",
            inline=False
        )
    await ctx.send(embed=embed)

@bot.command()
async def sell(ctx, price: int, *, item_name: str):
    """Sell an item in the thrift store"""
    if price < 1:
        await ctx.send(embed=nova_embed("sELL", "pRICE mUST bE aT lEAST 1!"))
        return
    
    thrift = load_thrift()
    item_id = str(len(thrift) + 1)
    
    thrift[item_id] = {
        "name": item_name,
        "price": price,
        "seller": ctx.author.id,
        "date": datetime.now().isoformat()
    }
    
    save_thrift(thrift)
    await ctx.send(embed=nova_embed("sELL", f"iTEM '{item_name}' lISTED fOR {price} {CURRENCY_NAME}!"))

@bot.command()
async def buy(ctx, item_id: str):
    """Buy an item from the thrift store"""
    thrift = load_thrift()
    
    if item_id not in thrift:
        await ctx.send(embed=nova_embed("bUY", "iTEM nOT fOUND!"))
        return
    
    item = thrift[item_id]
    if item["seller"] == ctx.author.id:
        await ctx.send(embed=nova_embed("bUY", "yOU cAN'T bUY yOUR oWN iTEM!"))
        return
    
    if get_balance(ctx.author.id) < item["price"]:
        await ctx.send(embed=nova_embed("bUY", f"yOU nEED {item['price']} {CURRENCY_NAME}!"))
        return
    
    # Transfer money
    subtract_balance(ctx.author.id, item["price"])
    add_balance(item["seller"], item["price"])
    
    # Remove item from thrift store
    del thrift[item_id]
    save_thrift(thrift)
    
    await ctx.send(embed=nova_embed("bUY", f"yOU bOUGHT '{item['name']}' fOR {item['price']} {CURRENCY_NAME}!"))

# Auto-reaction system
AUTO_REACTIONS = {}  # word: emoji

@bot.command()
async def addreaction(ctx, word: str, emoji: str):
    """Add auto-reaction for a word (admin only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("aDD rEACTION", "yOU dON'T hAVE pERMISSION!"))
        return
    
    AUTO_REACTIONS[word.lower()] = emoji
    await ctx.send(embed=nova_embed("aDD rEACTION", f"aDDED rEACTION {emoji} fOR '{word}'!"))

@bot.command()
async def removereaction(ctx, word: str):
    """Remove auto-reaction for a word (admin only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("rEMOVE rEACTION", "yOU dON'T hAVE pERMISSION!"))
        return
    
    if word.lower() in AUTO_REACTIONS:
        del AUTO_REACTIONS[word.lower()]
        await ctx.send(embed=nova_embed("rEMOVE rEACTION", f"rEMOVED rEACTION fOR '{word}'!"))
    else:
        await ctx.send(embed=nova_embed("rEMOVE rEACTION", f"nO rEACTION fOUND fOR '{word}'!"))

@bot.command()
async def reactions(ctx):
    """List all auto-reactions"""
    if not AUTO_REACTIONS:
        await ctx.send(embed=nova_embed("rEACTIONS", "nO aUTO-rEACTIONS sET!"))
        return
    
    reaction_list = "\n".join([f"{word}: {emoji}" for word, emoji in AUTO_REACTIONS.items()])
    await ctx.send(embed=nova_embed("aUTO-rEACTIONS", reaction_list))

# Focus timer system
FOCUS_SESSIONS = {}  # user_id: {"start_time": datetime, "duration": int, "breaks": int}

@bot.command()
async def focus(ctx, duration: int = 25):
    """Start a focus timer (Pomodoro technique)"""
    if duration < 1 or duration > 120:
        await ctx.send(embed=nova_embed("fOCUS", "dURATION mUST bE bETWEEN 1-120 mINUTES!"))
        return
    
    user_id = ctx.author.id
    if user_id in FOCUS_SESSIONS:
        await ctx.send(embed=nova_embed("fOCUS", "yOU aLREADY hAVE a fOCUS sESSION rUNNING!"))
        return
    
    FOCUS_SESSIONS[user_id] = {
        "start_time": datetime.now(),
        "duration": duration,
        "breaks": 0
    }
    
    await ctx.send(embed=nova_embed("fOCUS sTARTED", f"fOCUS sESSION sTARTED fOR {duration} mINUTES! \n\nuSE `?focusstatus` tO cHECK pROGRESS"))

@bot.command()
async def focusstatus(ctx):
    """Check focus session status"""
    user_id = ctx.author.id
    if user_id not in FOCUS_SESSIONS:
        await ctx.send(embed=nova_embed("fOCUS sTATUS", "nO aCTIVE fOCUS sESSION!"))
        return
    
    session = FOCUS_SESSIONS[user_id]
    elapsed = datetime.now() - session["start_time"]
    remaining = timedelta(minutes=session["duration"]) - elapsed
    
    if remaining.total_seconds() <= 0:
        del FOCUS_SESSIONS[user_id]
        await ctx.send(embed=nova_embed("fOCUS cOMPLETE", "fOCUS sESSION cOMPLETED! gREAT jOB! \ud83c\udf89"))
    else:
        mins, secs = divmod(int(remaining.total_seconds()), 60)
        await ctx.send(embed=nova_embed("fOCUS sTATUS", f"tIME rEMAINING: {mins}:{secs:02d}"))

@bot.command()
async def focusbreak(ctx):
    """Take a break from focus session"""
    user_id = ctx.author.id
    if user_id not in FOCUS_SESSIONS:
        await ctx.send(embed=nova_embed("fOCUS bREAK", "nO aCTIVE fOCUS sESSION!"))
        return
    
    FOCUS_SESSIONS[user_id]["breaks"] += 1
    await ctx.send(embed=nova_embed("fOCUS bREAK", "bREAK tIME! rELAX fOR 5 mINUTES \ud83d\ude0c"))

@bot.command()
async def focusend(ctx):
    """End focus session early"""
    user_id = ctx.author.id
    if user_id not in FOCUS_SESSIONS:
        await ctx.send(embed=nova_embed("fOCUS eND", "nO aCTIVE fOCUS sESSION!"))
        return
    
    del FOCUS_SESSIONS[user_id]
    await ctx.send(embed=nova_embed("fOCUS eNDED", "fOCUS sESSION eNDED eARLY!"))

# Message count commands
@bot.command()
async def messagecount(ctx, timeframe: str = "lifetime", user: discord.Member = None):
    """Show message count for different timeframes"""
    target_user = user or ctx.author
    
    # This would need to be implemented with actual message tracking
    # For now, just show a placeholder
    timeframes = {
        "month": "lAST mONTH",
        "3months": "lAST 3 mONTHS", 
        "year": "lAST yEAR",
        "lifetime": "lIFETIME"
    }
    
    if timeframe not in timeframes:
        await ctx.send(embed=nova_embed("mESSAGE cOUNT", "vALID tIMEFRAMES: month, 3months, year, lifetime"))
        return
    
    # Placeholder - would need actual implementation
    count = random.randint(100, 5000)
    await ctx.send(embed=nova_embed(
        "mESSAGE cOUNT", 
        f"{target_user.mention} hAS sENT {count} mESSAGES iN {timeframes[timeframe]}!"
    ))

# Command disabling system
DISABLED_COMMANDS = {}  # guild_id: [command_names]

@bot.command()
async def disable(ctx, *, command_name: str):
    """Disable a command in this server (admin only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("dISABLE", "yOU dON'T hAVE pERMISSION!"))
        return
    
    guild_id = ctx.guild.id
    if guild_id not in DISABLED_COMMANDS:
        DISABLED_COMMANDS[guild_id] = []
    
    if command_name not in DISABLED_COMMANDS[guild_id]:
        DISABLED_COMMANDS[guild_id].append(command_name)
        await ctx.send(embed=nova_embed("dISABLE", f"dISABLED cOMMAND '{command_name}'!"))
    else:
        await ctx.send(embed=nova_embed("dISABLE", f"cOMMAND '{command_name}' iS aLREADY dISABLED!"))

@bot.command()
async def enable(ctx, *, command_name: str):
    """Enable a command in this server (admin only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("eNABLE", "yOU dON'T hAVE pERMISSION!"))
        return
    
    guild_id = ctx.guild.id
    if guild_id in DISABLED_COMMANDS and command_name in DISABLED_COMMANDS[guild_id]:
        DISABLED_COMMANDS[guild_id].remove(command_name)
        await ctx.send(embed=nova_embed("eNABLE", f"eNABLED cOMMAND '{command_name}'!"))
    else:
        await ctx.send(embed=nova_embed("eNABLE", f"cOMMAND '{command_name}' iS nOT dISABLED!"))

@bot.command()
async def disabledcommands(ctx):
    """List disabled commands in this server"""
    guild_id = ctx.guild.id
    if guild_id not in DISABLED_COMMANDS or not DISABLED_COMMANDS[guild_id]:
        await ctx.send(embed=nova_embed("dISABLED cOMMANDS", "nO cOMMANDS aRE dISABLED!"))
        return
    
    disabled_list = ", ".join(DISABLED_COMMANDS[guild_id])
    await ctx.send(embed=nova_embed("dISABLED cOMMANDS", f"dISABLED: {disabled_list}"))

# SOB board (like bleed board)
@bot.command()
async def sob(ctx):
    """Show the SOB leaderboard"""
    # This would need actual SOB tracking implementation
    await ctx.send(embed=nova_embed("sOB bOARD", "sOB bOARD cOMING sOON!"))

# Additional utility commands
@bot.command()
async def ping(ctx):
    """Check bot latency"""
    latency = round(bot.latency * 1000)
    await ctx.send(embed=nova_embed("pING", f"pONG! {latency}ms"))

@bot.command()
async def uptime(ctx):
    """Show bot uptime"""
    # This would need actual uptime tracking
    await ctx.send(embed=nova_embed("uPTIME", "uPTIME tRACKING cOMING sOON!"))

@bot.command()
async def serverinfo(ctx):
    """Show server information"""
    guild = ctx.guild
    embed = nova_embed(
        f"{guild.name} iNFO",
        f"**mEMBERS:** {guild.member_count}\n"
        f"**cREATED:** {guild.created_at.strftime('%B %d, %Y')}\n"
        f"**oWNER:** {guild.owner.mention if guild.owner else 'Unknown'}\n"
        f"**bOOST lEVEL:** {guild.premium_tier}\n"
        f"**bOOSTS:** {guild.premium_subscription_count}"
    )
    if guild.icon:
        embed.set_thumbnail(url=guild.icon.url)
    await ctx.send(embed=embed)

@bot.command()
async def userinfo(ctx, user: discord.Member = None):
    """Show user information"""
    user = user or ctx.author
    embed = nova_embed(
        f"{user.display_name}'s iNFO",
        f"**uSERNAME:** {user.name}\n"
        f"**dISPLAY nAME:** {user.display_name}\n"
        f"**iD:** {user.id}\n"
        f"**jOINED sERVER:** {user.joined_at.strftime('%B %d, %Y') if user.joined_at else 'Unknown'}\n"
        f"**aCCOUNT cREATED:** {user.created_at.strftime('%B %d, %Y')}\n"
        f"**rOLES:** {len(user.roles) - 1}"
    )
    embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
    await ctx.send(embed=embed)

# Load pets on startup
load_pets()

# Enhanced member join event with detailed logging
@bot.event
async def on_member_join(member):
    # Existing welcome message code
    if WELCOME_CHANNEL_ID:
        channel = member.guild.get_channel(WELCOME_CHANNEL_ID)
        if channel:
            member_number = member.guild.member_count
            
            # Create welcome message with specific rules channel
            description = f"wELCOME tO tHE sERVER, {member.mention}! üíñ\n\n"
            description += f"üìã pLEASE rEAD <#1390109532851535962> tO gET sTARTED!\n"
            description += f"üéâ yOU aRE oUR {member_number}th mEMBER!\n\n"
            description += "mAKE yOURSELF aT hOME!"
            
            embed = nova_embed("üëã wELCOME!", description)
            await channel.send(embed=embed)
    
    # New join logging
    if JOIN_LEAVE_LOGS_CHANNEL_ID:
        channel = member.guild.get_channel(JOIN_LEAVE_LOGS_CHANNEL_ID)
        if channel:
            embed = discord.Embed(
                title="üì• User Joined",
                color=0x00ff00,
                timestamp=datetime.now()
            )
            
            embed.add_field(name="User", value=f"{member.mention}\n{member.display_name}", inline=True)
            embed.add_field(name="ID", value=f"`{member.id}`", inline=True)
            embed.add_field(name="Members", value=f"{member.guild.member_count}", inline=True)
            
            embed.add_field(name="Account Created", value=f"<t:{int(member.created_at.timestamp())}:R>", inline=True)
            embed.add_field(name="Joined Server", value=f"<t:{int(member.joined_at.timestamp())}:R>", inline=True)
            
            if member.avatar:
                embed.set_thumbnail(url=member.avatar.url)
            
            embed.set_footer(text=f"Member #{member.guild.member_count}")
            
            try:
                await channel.send(embed=embed)
            except Exception as e:
                print(f"Failed to send join log: {e}")

@bot.event
async def on_member_remove(member):
    # Existing farewell message code
    if FAREWELL_CHANNEL_ID:
        channel = member.guild.get_channel(FAREWELL_CHANNEL_ID)
        if channel:
            embed = nova_embed(
                "üëã gOODBYE!",
                f"{member.display_name} hAS lEFT tHE sERVER. wE'LL mISS yOU! üíî"
            )
            await channel.send(embed=embed)
    
    # New leave logging
    if JOIN_LEAVE_LOGS_CHANNEL_ID:
        channel = member.guild.get_channel(JOIN_LEAVE_LOGS_CHANNEL_ID)
        if channel:
            embed = discord.Embed(
                title="üì§ User Left",
                color=0xff0000,
                timestamp=datetime.now()
            )
            
            embed.add_field(name="User", value=f"{member.mention}\n{member.display_name}", inline=True)
            embed.add_field(name="ID", value=f"`{member.id}`", inline=True)
            embed.add_field(name="Members", value=f"{member.guild.member_count}", inline=True)
            
            if member.joined_at:
                embed.add_field(name="Joined Server", value=f"<t:{int(member.joined_at.timestamp())}:R>", inline=True)
            
            # Get roles (excluding @everyone)
            roles = [role.mention for role in member.roles[1:]] if len(member.roles) > 1 else ["None"]
            if roles and roles != ["None"]:
                embed.add_field(name="Roles", value=", ".join(roles[:10]), inline=False)
            
            if member.avatar:
                embed.set_thumbnail(url=member.avatar.url)
            
            try:
                await channel.send(embed=embed)
            except Exception as e:
                print(f"Failed to send leave log: {e}")

# BCA Deadline Monitoring System
announcement_tracker = {
    'nomination_1h_warning': False,
    'nomination_closed': False,
    'voting_1h_warning': False,
    'voting_closed': False,
    'voting_opened': False
}

@bot.event
async def deadline_monitor():
    """Monitor BCA deadlines and send automatic announcements"""
    try:
        now_utc = datetime.now(dt_timezone.utc)
        est = pytz.timezone('US/Eastern')
        
        nomination_channel = bot.get_channel(BCA_NOMINATIONS_CHANNEL_ID) if BCA_NOMINATIONS_CHANNEL_ID else None
        
        # === NOMINATION DEADLINE MONITORING ===
        if BCA_NOMINATION_DEADLINE:
            time_until_nom_deadline = BCA_NOMINATION_DEADLINE - now_utc
            
            # 1 hour warning for nominations
            if (3540 <= time_until_nom_deadline.total_seconds() <= 3660 and 
                not announcement_tracker['nomination_1h_warning']):
                
                if nomination_channel:
                    deadline_est = BCA_NOMINATION_DEADLINE.astimezone(est)
                    embed = discord.Embed(
                        title="‚ö†Ô∏è nOMINATION dEADLINE wARNING!",
                        description=f"‚è∞ **1 hOUR lEFT tO nOMINATE!**\n\nDeadline: {deadline_est.strftime('%Y-%m-%d at %H:%M EST')}\n\nUse `?nominate @user <category>` to submit your nominations!",
                        color=0xffaa00
                    )
                    await nomination_channel.send(embed=embed)
                    announcement_tracker['nomination_1h_warning'] = True
            
            # Nominations closed announcement
            elif (time_until_nom_deadline.total_seconds() <= 0 and 
                  not announcement_tracker['nomination_closed']):
                
                if nomination_channel:
                    embed = discord.Embed(
                        title="üìù nOMINATIONS cLOSED!",
                        description="üìù **nOMINATIONS fOR aLL cATEGORIES hAVE cLOSED!**\n\nüó≥Ô∏è vOTING wILL oPEN sOON!",
                        color=0xff0000
                    )
                    await nomination_channel.send(embed=embed)
                    announcement_tracker['nomination_closed'] = True
                    announcement_tracker['voting_opened'] = False  # Reset for voting announcement
        
        # === VOTING DEADLINE MONITORING ===
        if BCA_VOTING_DEADLINE:
            time_until_vote_deadline = BCA_VOTING_DEADLINE - now_utc
            
            # 1 hour warning for voting
            if (3540 <= time_until_vote_deadline.total_seconds() <= 3660 and 
                not announcement_tracker['voting_1h_warning']):
                
                voting_channel = bot.get_channel(BCA_VOTING_CHANNEL_ID) if BCA_VOTING_CHANNEL_ID else nomination_channel
                if voting_channel:
                    deadline_est = BCA_VOTING_DEADLINE.astimezone(est)
                    embed = discord.Embed(
                        title="‚ö†Ô∏è vOTING dEADLINE wARNING!",
                        description=f"‚è∞ **1 hOUR lEFT tO vOTE!**\n\nDeadline: {deadline_est.strftime('%Y-%m-%d at %H:%M EST')}\n\nMods can use `?bcavote <category>` to create voting sessions!",
                        color=0xffaa00
                    )
                    await voting_channel.send(embed=embed)
                    announcement_tracker['voting_1h_warning'] = True
            
            # Voting closed announcement
            elif (time_until_vote_deadline.total_seconds() <= 0 and 
                  not announcement_tracker['voting_closed']):
                
                voting_channel = bot.get_channel(BCA_VOTING_CHANNEL_ID) if BCA_VOTING_CHANNEL_ID else nomination_channel
                if voting_channel:
                    embed = discord.Embed(
                        title="üó≥Ô∏è vOTING cLOSED!",
                        description="üó≥Ô∏è **vOTING fOR aLL cATEGORIES hAS cLOSED!**\n\nüèÜ rESULTS wILL bE aNNOUNCED sOON!",
                        color=0xff0000
                    )
                    await voting_channel.send(embed=embed)
                    announcement_tracker['voting_closed'] = True
        
        # === VOTING OPENED ANNOUNCEMENT ===
        # Announce when nominations are closed but voting hasn't started yet
        if (BCA_NOMINATION_DEADLINE and BCA_VOTING_DEADLINE and 
            now_utc > BCA_NOMINATION_DEADLINE and now_utc < BCA_VOTING_DEADLINE and 
            not announcement_tracker['voting_opened']):
            
            voting_channel = bot.get_channel(BCA_VOTING_CHANNEL_ID) if BCA_VOTING_CHANNEL_ID else nomination_channel
            if voting_channel:
                vote_deadline_est = BCA_VOTING_DEADLINE.astimezone(est)
                embed = discord.Embed(
                    title="üó≥Ô∏è vOTING iS nOW oPEN!",
                    description=f"üó≥Ô∏è **vOTING iS nOW oPEN!**\n\nVoting deadline: {vote_deadline_est.strftime('%Y-%m-%d at %H:%M EST')}\n\nMods can use `?bcavote <category>` to create voting sessions!",
                    color=0x00ff00
                )
                await voting_channel.send(embed=embed)
                announcement_tracker['voting_opened'] = True
    
    except Exception as e:
        print(f"Error in deadline_monitor: {e}")
        import traceback
        traceback.print_exc()

# Reset announcement tracker when deadlines are changed
def reset_announcement_tracker():
    """Reset announcement tracker when deadlines change"""
    global announcement_tracker
    announcement_tracker = {
        'nomination_1h_warning': False,
        'nomination_closed': False,
        'voting_1h_warning': False,
        'voting_closed': False,
        'voting_opened': False
    }

# Enhanced blacklist system with persistence
def save_blacklist():
    """Save blacklist to file"""
    try:
        with open("blacklist.json", "w") as f:
            json.dump(list(BLACKLIST_WORDS), f, indent=4)
    except Exception as e:
        print(f"Error saving blacklist: {e}")

def load_blacklist():
    """Load blacklist from file"""
    global BLACKLIST_WORDS
    try:
        with open("blacklist.json", "r") as f:
            BLACKLIST_WORDS = set(json.load(f))
    except FileNotFoundError:
        BLACKLIST_WORDS = set()
    except Exception as e:
        print(f"Error loading blacklist: {e}")
        BLACKLIST_WORDS = set()

# Enhanced focus timer command with automatic notifications
@bot.command()
async def focus(ctx, duration: int = 25):
    """Start a Pomodoro-style focus timer with automatic notifications"""
    if duration < 1 or duration > 120:
        await ctx.send(embed=nova_embed("fOCUS", "dURATION mUST bE bETWEEN 1-120 mINUTES!"))
        return
    
    user_id = ctx.author.id
    
    if user_id in FOCUS_SESSIONS:
        await ctx.send(embed=nova_embed("fOCUS", "yOU aLREADY hAVE aN aCTIVE fOCUS sESSION!"))
        return
    
    FOCUS_SESSIONS[user_id] = {
        "start_time": datetime.now(),
        "duration": duration,
        "breaks": 0
    }
    
    embed = nova_embed(
        "üéØ fOCUS sESSION sTARTED",
        f"fOCUSING fOR {duration} mINUTES!\n"
        f"i'LL pING yOU wHEN iT'S tIME fOR a bREAK!"
    )
    await ctx.send(embed=embed)
    
    # Wait for the duration and then notify
    await asyncio.sleep(duration * 60)
    
    if user_id in FOCUS_SESSIONS:
        FOCUS_SESSIONS[user_id]["breaks"] += 1
        breaks = FOCUS_SESSIONS[user_id]["breaks"]
        
        break_duration = 15 if breaks % 4 != 0 else 30  # Long break every 4 sessions
        
        embed = nova_embed(
            "‚è∞ fOCUS sESSION cOMPLETE!",
            f"gREAT jOB! tAKE a {break_duration}-mINUTE bREAK! üéâ\n"
            f"sESSIONS cOMPLETED: {breaks}"
        )
        await ctx.send(f"{ctx.author.mention}", embed=embed)
        
        # Remove session after break
        await asyncio.sleep(break_duration * 60)
        if user_id in FOCUS_SESSIONS:
            del FOCUS_SESSIONS[user_id]

# Enhanced lottery system with detailed management
@bot.command()
async def lottery(ctx, action=None, price: int = None):
    """Manage the weekly server lottery (owner only)"""
    if ctx.author.id != OWNER_ID:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "Only the owner can manage the lottery!"))
        return
    
    if action is None:
        # Show current lottery status
        embed = nova_embed(
            "üé∞ lOTTERY sTATUS",
            f"pARTICIPANTS: {len(LOTTERY_PARTICIPANTS)}\n"
            f"cURRENT eNTRY cOST: {config.get('lottery_price', 100)} {CURRENCY_NAME}\n\n"
            f"cOMMANDS:\n"
            f"`?lottery start [price]` - Start new lottery with optional price\n"
            f"`?lottery draw` - Draw winner and end current lottery\n"
            f"`?lottery reset` - Reset current lottery\n"
            f"`?lottery price [amount]` - Set entry price"
        )
        await ctx.send(embed=embed)
        return
    
    if action == "start":
        if price:
            config["lottery_price"] = price
            save_config()
        LOTTERY_PARTICIPANTS.clear()
        embed = nova_embed(
            "üé∞ lOTTERY sTARTED!",
            f"nEW lOTTERY hAS sTARTED!\n"
            f"eNTRY cOST: {config.get('lottery_price', 100)} {CURRENCY_NAME}\n"
            f"uSE `?buyticket` tO eNTER!"
        )
        await ctx.send(embed=embed)
    
    elif action == "draw":
        if not LOTTERY_PARTICIPANTS:
            await ctx.send(embed=nova_embed("üé∞ lOTTERY", "nO pARTICIPANTS iN cURRENT lOTTERY!"))
            return
        
        winner_id = random.choice(list(LOTTERY_PARTICIPANTS))
        prize = len(LOTTERY_PARTICIPANTS) * config.get('lottery_price', 100)
        
        add_balance(winner_id, prize)
        
        embed = nova_embed(
            "üéÜ lOTTERY wINNER!",
            f"üèÜ **<@{winner_id}> wON tHE lOTTERY!**\n\n"
            f"üí∞ pRIZE: {prize} {CURRENCY_NAME}\n"
            f"üé´ tOTAL tICKETS: {len(LOTTERY_PARTICIPANTS)}"
        )
        await ctx.send(embed=embed)
        
        LOTTERY_PARTICIPANTS.clear()
    
    elif action == "reset":
        LOTTERY_PARTICIPANTS.clear()
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "lOTTERY rESET! aLL tICKETS rEFUNDED."))
    
    elif action == "price":
        if price and price > 0:
            config["lottery_price"] = price
            save_config()
            await ctx.send(embed=nova_embed("üé∞ lOTTERY", f"eNTRY pRICE sET tO {price} {CURRENCY_NAME}!"))
        else:
            await ctx.send(embed=nova_embed("üé∞ lOTTERY", "pLEASE pROVIDE a vALID pRICE!"))
    
    else:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "vALID aCTIONS: start, draw, reset, price"))

# Enhanced buyticket command with better error handling
@bot.command()
async def buyticket(ctx):
    """Buy a lottery ticket"""
    user_id = ctx.author.id
    ticket_price = config.get('lottery_price', 100)
    
    if user_id in LOTTERY_PARTICIPANTS:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", "yOU aLREADY hAVE a tICKET!"))
        return
    
    if get_balance(user_id) < ticket_price:
        await ctx.send(embed=nova_embed("üé∞ lOTTERY", f"yOU nEED {ticket_price} {CURRENCY_NAME} tO bUY a tICKET!"))
        return
    
    subtract_balance(user_id, ticket_price)
    LOTTERY_PARTICIPANTS.add(user_id)
    
    embed = nova_embed(
        "üé´ tICKET pURCHASED!",
        f"gOOD lUCK! yOU'RE eNTERED iN tHE lOTTERY!\n"
        f"tOTAL pARTICIPANTS: {len(LOTTERY_PARTICIPANTS)}"
    )
    await ctx.send(embed=embed)

# Enhanced message activity tracking
@bot.event
async def on_message(message):
    """Enhanced message processing with activity tracking and auto-reactions"""
    if message.author.bot:
        return
    
    # Add XP for non-bot messages
    add_xp(message.author.id, 1)
    
    # Track message activity
    user_id = message.author.id
    guild_id = message.guild.id if message.guild else None
    
    if guild_id:
        # Initialize guild data if not exists
        if guild_id not in MESSAGE_ACTIVITY:
            MESSAGE_ACTIVITY[guild_id] = {}
        if user_id not in MESSAGE_ACTIVITY[guild_id]:
            MESSAGE_ACTIVITY[guild_id][user_id] = 0
        
        MESSAGE_ACTIVITY[guild_id][user_id] += 1
        
        # Save periodically (every 10 messages)
        if sum(MESSAGE_ACTIVITY[guild_id].values()) % 10 == 0:
            save_message_activity()
    
    # Check for auto-reactions
    if message.guild and AUTO_REACTIONS:
        content_lower = message.content.lower()
        for word, emoji in AUTO_REACTIONS.items():
            if word in content_lower:
                try:
                    await message.add_reaction(emoji)
                except:
                    pass  # Ignore reaction errors
    
    # Check for blacklisted words
    if message.guild and BLACKLIST_WORDS:
        content_lower = message.content.lower()
        for word in BLACKLIST_WORDS:
            if word in content_lower:
                try:
                    await message.delete()
                    embed = nova_embed(
                        "‚ö†Ô∏è bLACKLISTED wORD dETECTED",
                        f"{message.author.mention}, yOUR mESSAGE cONTAINED a bLACKLISTED wORD aNd wAS dELETED."
                    )
                    await message.channel.send(embed=embed, delete_after=5)
                    return
                except:
                    pass
    
    # Handle AFK mentions
    if message.mentions:
        for mentioned_user in message.mentions:
            if mentioned_user.id in AFK_STATUS:
                afk_info = AFK_STATUS[mentioned_user.id]
                since_time = afk_info["since"]
                reason = afk_info["reason"]
                
                # Calculate time difference
                time_diff = datetime.now(timezone.utc) - since_time
                hours, remainder = divmod(int(time_diff.total_seconds()), 3600)
                minutes, _ = divmod(remainder, 60)
                
                time_str = f"{hours}h {minutes}m" if hours > 0 else f"{minutes}m"
                
                embed = nova_embed(
                    "aFK",
                    f"{mentioned_user.display_name} iS cURRENTLY aFK ({time_str} aGO): {reason}"
                )
                await message.channel.send(embed=embed)
                
                # Add to mentions set
                afk_info["mentions"].add(message.author.id)
                save_afk()
    
    # Check if AFK user is speaking (remove AFK status)
    if message.author.id in AFK_STATUS:
        afk_info = AFK_STATUS[message.author.id]
        mentions = afk_info["mentions"]
        
        # Create mention list
        mention_list = []
        for user_id in mentions:
            user = bot.get_user(user_id)
            if user:
                mention_list.append(user.display_name)
        
        # Remove AFK status
        del AFK_STATUS[message.author.id]
        save_afk()
        
        # Send welcome back message
        embed = nova_embed(
            "wELCOME bACK!",
            f"wELCOME bACK, {message.author.display_name}! yOU'RE nO lONGER aFK."
        )
        
        if mention_list:
            embed.add_field(
                name="pEOPLE wHO mENTIONED yOU",
                value=", ".join(mention_list[:10]),
                inline=False
            )
        
        await message.channel.send(embed=embed)
    
    # Process commands
    await bot.process_commands(message)

# Load blacklist on startup
load_blacklist()

# Complex relationship and adoption system
pending_adoptions = {}  # adoptee_id: adopter_id

class AdoptionView(discord.ui.View):
    def __init__(self, adopter_id, adoptee_id):
        super().__init__(timeout=300)
        self.adopter_id = adopter_id
        self.adoptee_id = adoptee_id

    @discord.ui.button(label="aCCEPT", style=discord.ButtonStyle.green, emoji="‚úÖ")
    async def accept_adoption(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.adoptee_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION iS nOT fOR yOU!"), ephemeral=True)
            return
        
        if self.adoptee_id not in pending_adoptions or pending_adoptions[self.adoptee_id] != self.adopter_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION hAS eXPIRED!"), ephemeral=True)
            return
        
        adopter = interaction.guild.get_member(self.adopter_id)
        if not adopter:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "aDOPTER nOT fOUND!"), ephemeral=True)
            return
        
        relationships = load_relationships()
        key = f"adopted:{self.adopter_id}"
        relationships[key] = self.adoptee_id
        save_relationships(relationships)
        
        del pending_adoptions[self.adoptee_id]
        
        # Disable all buttons
        for child in self.children:
            child.disabled = True
        
        await interaction.response.edit_message(
            embed=nova_embed("aDOPTION aCCEPTED", f"üçº {interaction.user.display_name} hAS bEEN aDOPTED bY {adopter.display_name}!"),
            view=self
        )

    @discord.ui.button(label="dECLINE", style=discord.ButtonStyle.red, emoji="‚ùå")
    async def decline_adoption(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.adoptee_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION iS nOT fOR yOU!"), ephemeral=True)
            return
        
        if self.adoptee_id not in pending_adoptions or pending_adoptions[self.adoptee_id] != self.adopter_id:
            await interaction.response.send_message(embed=nova_embed("aDOPTION", "tHIS aDOPTION hAS eXPIRED!"), ephemeral=True)
            return
        
        adopter = interaction.guild.get_member(self.adopter_id)
        adopter_name = adopter.display_name if adopter else "Unknown"
        
        del pending_adoptions[self.adoptee_id]
        
        # Disable all buttons
        for child in self.children:
            child.disabled = True
        
        await interaction.response.edit_message(
            embed=nova_embed("aDOPTION dECLINED", f"üòî {interaction.user.display_name} dECLINED tHE aDOPTION fROM {adopter_name}!"),
            view=self
        )

@bot.command()
async def emancipate(ctx, user: discord.Member):
    relationships = load_relationships()
    key = f"adopted:{ctx.author.id}"
    if key not in relationships or relationships[key] != user.id:
        await ctx.send(embed=nova_embed("eMANCIPATE", "yOU hAVEN'T aDOPTED tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await ctx.send(embed=nova_embed("eMANCIPATE", f"{user.display_name} hAS bEEN eMANCIPATED bY {ctx.author.display_name}!"))

@bot.tree.command(name="emancipate", description="Free a previously adopted user")
async def emancipate_slash(interaction: discord.Interaction, user: discord.Member):
    relationships = load_relationships()
    key = f"adopted:{interaction.user.id}"
    if key not in relationships or relationships[key] != user.id:
        await interaction.response.send_message(embed=nova_embed("eMANCIPATE", "yOU hAVEN'T aDOPTED tHAT pERSON!"))
        return
    del relationships[key]
    save_relationships(relationships)
    await interaction.response.send_message(embed=nova_embed("eMANCIPATE", f"{user.display_name} hAS bEEN eMANCIPATED bY {interaction.user.display_name}!"))

@bot.command()
async def getemancipated(ctx):
    relationships = load_relationships()
    
    # Find if user is adopted by someone
    adopted_by = None
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == ctx.author.id:
            adopter_id = int(key.split(":")[1])
            adopted_by = ctx.guild.get_member(adopter_id)
            break
    
    if not adopted_by:
        await ctx.send(embed=nova_embed("gET eMANCIPATED", "yOU aREN'T aDOPTED bY aNYONE!"))
        return
    
    # Remove the adoption
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == ctx.author.id:
            del relationships[key]
            break
    
    save_relationships(relationships)
    await ctx.send(embed=nova_embed("gET eMANCIPATED", f"{ctx.author.display_name} hAS bEEN eMANCIPATED fROM {adopted_by.display_name}!"))

@bot.tree.command(name="getemancipated", description="Free yourself from adoption")
async def getemancipated_slash(interaction: discord.Interaction):
    relationships = load_relationships()
    
    # Find if user is adopted by someone
    adopted_by = None
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == interaction.user.id:
            adopter_id = int(key.split(":")[1])
            adopted_by = interaction.guild.get_member(adopter_id)
            break
    
    if not adopted_by:
        await interaction.response.send_message(embed=nova_embed("gET eMANCIPATED", "yOU aREN'T aDOPTED bY aNYONE!"))
        return
    
    # Remove the adoption
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == interaction.user.id:
            del relationships[key]
            break
    
    save_relationships(relationships)
    await interaction.response.send_message(embed=nova_embed("gET eMANCIPATED", f"{interaction.user.display_name} hAS bEEN eMANCIPATED fROM {adopted_by.display_name}!"))

# Family tree system
@bot.command()
async def familytree(ctx, user: discord.Member = None):
    user = user or ctx.author
    relationships = load_relationships()
    
    # Find spouse
    spouse = None
    spouse_key = f"married:{user.id}"
    if spouse_key in relationships:
        spouse_id = relationships[spouse_key]
        spouse = ctx.guild.get_member(spouse_id)
    
    # Find children (people this user adopted)
    children = []
    for key, value in relationships.items():
        if key.startswith("adopted:") and key.split(":")[1] == str(user.id):
            child = ctx.guild.get_member(value)
            if child:
                children.append(child)
    
    # Find parent (who adopted this user)
    parent = None
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == user.id:
            parent_id = int(key.split(":")[1])
            parent = ctx.guild.get_member(parent_id)
            break
    
    # Build family tree embed
    embed = nova_embed(f"{user.display_name}'s fAMILY tREE", "")
    
    if parent:
        embed.add_field(name="üë®‚Äçüë©‚Äçüëß‚Äçüë¶ pARENT", value=parent.mention, inline=True)
    else:
        embed.add_field(name="üë®‚Äçüë©‚Äçüëß‚Äçüë¶ pARENT", value="nONE", inline=True)
    
    if spouse:
        embed.add_field(name="üíç sPOUSE", value=spouse.mention, inline=True)
    else:
        embed.add_field(name="üíç sPOUSE", value="nONE", inline=True)
    
    if children:
        children_mentions = [child.mention for child in children[:10]]  # Limit to 10
        embed.add_field(name="üë∂ cHILDREN", value="\n".join(children_mentions), inline=False)
    else:
        embed.add_field(name="üë∂ cHILDREN", value="nONE", inline=False)
    
    embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
    await ctx.send(embed=embed)

@bot.tree.command(name="familytree", description="View a user's family tree")
async def familytree_slash(interaction: discord.Interaction, user: discord.Member = None):
    user = user or interaction.user
    relationships = load_relationships()
    
    # Find spouse
    spouse = None
    spouse_key = f"married:{user.id}"
    if spouse_key in relationships:
        spouse_id = relationships[spouse_key]
        spouse = interaction.guild.get_member(spouse_id)
    
    # Find children (people this user adopted)
    children = []
    for key, value in relationships.items():
        if key.startswith("adopted:") and key.split(":")[1] == str(user.id):
            child = interaction.guild.get_member(value)
            if child:
                children.append(child)
    
    # Find parent (who adopted this user)
    parent = None
    for key, value in relationships.items():
        if key.startswith("adopted:") and value == user.id:
            parent_id = int(key.split(":")[1])
            parent = interaction.guild.get_member(parent_id)
            break
    
    # Build family tree embed
    embed = nova_embed(f"{user.display_name}'s fAMILY tREE", "")
    
    if parent:
        embed.add_field(name="üë®‚Äçüë©‚Äçüëß‚Äçüë¶ pARENT", value=parent.mention, inline=True)
    else:
        embed.add_field(name="üë®‚Äçüë©‚Äçüëß‚Äçüë¶ pARENT", value="nONE", inline=True)
    
    if spouse:
        embed.add_field(name="üíç sPOUSE", value=spouse.mention, inline=True)
    else:
        embed.add_field(name="üíç sPOUSE", value="nONE", inline=True)
    
    if children:
        children_mentions = [child.mention for child in children[:10]]  # Limit to 10
        embed.add_field(name="üë∂ cHILDREN", value="\n".join(children_mentions), inline=False)
    else:
        embed.add_field(name="üë∂ cHILDREN", value="nONE", inline=False)
    
    embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
    await interaction.response.send_message(embed=embed)

# Enhanced reminder system
REMINDERS = {}  # user_id: [reminders]

@bot.command()
async def remind(ctx, time_str: str, *, message: str):
    """Set a reminder (e.g., ?remind 1h30m Buy groceries)"""
    try:
        # Parse time string (e.g., "1h30m", "45m", "2h")
        import re
        time_pattern = r'(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?'
        match = re.match(time_pattern, time_str.lower())
        
        if not match:
            await ctx.send(embed=nova_embed("rEMINDER", "iNVALID tIME fORMAT! uSE: 1h30m, 45m, 2h, etc."))
            return
        
        hours = int(match.group(1)) if match.group(1) else 0
        minutes = int(match.group(2)) if match.group(2) else 0
        seconds = int(match.group(3)) if match.group(3) else 0
        
        total_seconds = hours * 3600 + minutes * 60 + seconds
        
        if total_seconds == 0:
            await ctx.send(embed=nova_embed("rEMINDER", "pLEASE sPECIFY a vALID tIME!"))
            return
        
        if total_seconds > 86400 * 7:  # Max 7 days
            await ctx.send(embed=nova_embed("rEMINDER", "mAX rEMINDER tIME iS 7 dAYS!"))
            return
        
        # Create reminder
        reminder_time = datetime.now() + timedelta(seconds=total_seconds)
        reminder = {
            "message": message,
            "channel_id": ctx.channel.id,
            "time": reminder_time.isoformat(),
            "user_id": ctx.author.id
        }
        
        if ctx.author.id not in REMINDERS:
            REMINDERS[ctx.author.id] = []
        
        REMINDERS[ctx.author.id].append(reminder)
        
        # Format time display
        time_display = []
        if hours > 0:
            time_display.append(f"{hours}h")
        if minutes > 0:
            time_display.append(f"{minutes}m")
        if seconds > 0:
            time_display.append(f"{seconds}s")
        
        await ctx.send(embed=nova_embed(
            "‚è∞ rEMINDER sET",
            f"i'LL rEMIND yOU iN {' '.join(time_display)}!\n\n**mESSAGE:** {message}"
        ))
        
        # Wait and send reminder
        await asyncio.sleep(total_seconds)
        
        # Check if reminder still exists (user might have cancelled)
        if ctx.author.id in REMINDERS:
            REMINDERS[ctx.author.id] = [r for r in REMINDERS[ctx.author.id] if r != reminder]
            if not REMINDERS[ctx.author.id]:
                del REMINDERS[ctx.author.id]
        
        channel = bot.get_channel(ctx.channel.id)
        if channel:
            embed = nova_embed(
                "‚è∞ rEMINDER",
                f"{ctx.author.mention}, yOU aSKED mE tO rEMIND yOU:\n\n**{message}**"
            )
            await channel.send(embed=embed)
        
    except Exception as e:
        await ctx.send(embed=nova_embed("rEMINDER", f"eRROR sETTING rEMINDER: {str(e)}"))

@bot.command()
async def reminders(ctx):
    """List your active reminders"""
    if ctx.author.id not in REMINDERS or not REMINDERS[ctx.author.id]:
        await ctx.send(embed=nova_embed("rEMINDERS", "yOU hAVE nO aCTIVE rEMINDERS!"))
        return
    
    embed = nova_embed("yOUR rEMINDERS", "")
    
    for i, reminder in enumerate(REMINDERS[ctx.author.id][:10], 1):
        reminder_time = datetime.fromisoformat(reminder["time"])
        time_left = reminder_time - datetime.now()
        
        if time_left.total_seconds() > 0:
            hours, remainder = divmod(int(time_left.total_seconds()), 3600)
            minutes, _ = divmod(remainder, 60)
            time_str = f"{hours}h {minutes}m" if hours > 0 else f"{minutes}m"
            
            embed.add_field(
                name=f"#{i}",
                value=f"**{reminder['message'][:50]}{'...' if len(reminder['message']) > 50 else ''}**\nTime left: {time_str}",
                inline=False
            )
    
    await ctx.send(embed=embed)

# Enhanced mute/unmute system with role management
async def get_or_create_muted_role(guild):
    """Get or create the Muted role with proper permissions"""
    role = discord.utils.get(guild.roles, name="Muted")
    if role:
        return role
    
    try:
        # Create the Muted role
        role = await guild.create_role(
            name="Muted",
            color=discord.Color.dark_grey(),
            reason="Created Muted role for Nova bot"
        )
        
        # Set permissions for all channels
        for channel in guild.channels:
            if isinstance(channel, discord.TextChannel):
                await channel.set_permissions(
                    role,
                    send_messages=False,
                    add_reactions=False,
                    speak=False,
                    reason="Muted role permissions"
                )
            elif isinstance(channel, discord.VoiceChannel):
                await channel.set_permissions(
                    role,
                    speak=False,
                    connect=False,
                    reason="Muted role permissions"
                )
        
        return role
    except Exception as e:
        print(f"Error creating Muted role: {e}")
        return None

@bot.command()
async def mute(ctx, member: discord.Member = None, *, reason: str = "No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("mUTE", "yOU dON'T hAVE pERMISSION!"))
        return
    if not member:
        await ctx.send(embed=nova_embed("mUTE", "yOU nEED tO mENTION sOMEONE!"))
        return
    if member == ctx.author:
        await ctx.send(embed=nova_embed("mUTE", "nICE tRY, bUT yOU cAN'T mUTE yOURSELF!"))
        return
    if member.id == OWNER_ID:
        await ctx.send(embed=nova_embed("mUTE", "yOU cAN'T mUTE tHE bOT oWNER!"))
        return
    
    role = await get_or_create_muted_role(ctx.guild)
    if not role:
        await ctx.send(embed=nova_embed("mUTE", "cOULD nOT cREATE oR fIND tHE mUTED rOLE!"))
        return
    if role in member.roles:
        await ctx.send(embed=nova_embed("mUTE", f"{member.mention} iS aLREADY mUTED!"))
        return
    
    try:
        await member.add_roles(role, reason=f"Muted by {ctx.author}: {reason}")
        
        # Log the mute
        user_id = str(member.id)
        if user_id not in INFRACTIONS:
            INFRACTIONS[user_id] = []
        
        infraction = {
            "type": "mute",
            "reason": reason,
            "moderator": str(ctx.author.id),
            "date": datetime.now().isoformat()
        }
        INFRACTIONS[user_id].append(infraction)
        save_infractions()
        
        embed = nova_embed("mUTE", f"{member.mention} hAS bEEN mUTED sERVER-WIDE!")
        embed.add_field(name="rEASON", value=reason, inline=False)
        embed.add_field(name="mODERATOR", value=ctx.author.mention, inline=True)
        await ctx.send(embed=embed)
        
        # Log to mod channel
        mod_channel = get_mod_logs_channel(ctx.guild.id)
        if mod_channel:
            log_embed = nova_embed("mEMBER mUTED", f"{member.mention} was muted")
            log_embed.add_field(name="uSER", value=f"{member.mention} ({member.id})", inline=True)
            log_embed.add_field(name="mODERATOR", value=f"{ctx.author.mention} ({ctx.author.id})", inline=True)
            log_embed.add_field(name="rEASON", value=reason, inline=False)
            log_embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
            await mod_channel.send(embed=log_embed)
        
    except Exception as e:
        await ctx.send(embed=nova_embed("mUTE", f"cOULD nOT mUTE tHAT uSER! {str(e)}"))

@bot.tree.command(name="mute", description="Mute a member server-wide (admin only)")
@app_commands.describe(member="Member to mute", reason="Reason for muting")
async def mute_slash(interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
    if not has_mod_or_admin_interaction(interaction):
        await interaction.response.send_message(embed=nova_embed("mUTE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    if member == interaction.user:
        await interaction.response.send_message(embed=nova_embed("mUTE", "nICE tRY, bUT yOU cAN'T mUTE yOURSELF!"), ephemeral=True)
        return
    if member.id == OWNER_ID:
        await interaction.response.send_message(embed=nova_embed("mUTE", "yOU cAN'T mUTE tHE bOT oWNER!"), ephemeral=True)
        return
    
    role = await get_or_create_muted_role(interaction.guild)
    if not role:
        await interaction.response.send_message(embed=nova_embed("mUTE", "cOULD nOT cREATE oR fIND tHE mUTED rOLE!"), ephemeral=True)
        return
    if role in member.roles:
        await interaction.response.send_message(embed=nova_embed("mUTE", f"{member.mention} iS aLREADY mUTED!"), ephemeral=True)
        return
    
    try:
        await member.add_roles(role, reason=f"Muted by {interaction.user}: {reason}")
        
        # Log the mute
        user_id = str(member.id)
        if user_id not in INFRACTIONS:
            INFRACTIONS[user_id] = []
        
        infraction = {
            "type": "mute",
            "reason": reason,
            "moderator": str(interaction.user.id),
            "date": datetime.now().isoformat()
        }
        INFRACTIONS[user_id].append(infraction)
        save_infractions()
        
        embed = nova_embed("mUTE", f"{member.mention} hAS bEEN mUTED sERVER-WIDE!")
        embed.add_field(name="rEASON", value=reason, inline=False)
        embed.add_field(name="mODERATOR", value=interaction.user.mention, inline=True)
        await interaction.response.send_message(embed=embed)
        
        # Log to mod channel
        mod_channel = get_mod_logs_channel(interaction.guild.id)
        if mod_channel:
            log_embed = nova_embed("mEMBER mUTED", f"{member.mention} was muted")
            log_embed.add_field(name="uSER", value=f"{member.mention} ({member.id})", inline=True)
            log_embed.add_field(name="mODERATOR", value=f"{interaction.user.mention} ({interaction.user.id})", inline=True)
            log_embed.add_field(name="rEASON", value=reason, inline=False)
            log_embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
            await mod_channel.send(embed=log_embed)
        
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("mUTE", f"cOULD nOT mUTE tHAT uSER! {str(e)}"), ephemeral=True)

@bot.command()
async def unmute(ctx, member: discord.Member = None, *, reason: str = "No reason provided"):
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("uNMUTE", "yOU dON'T hAVE pERMISSION!"))
        return
    if not member:
        await ctx.send(embed=nova_embed("uNMUTE", "yOU nEED tO mENTION sOMEONE!"))
        return
    
    role = discord.utils.get(ctx.guild.roles, name="Muted")
    if not role or role not in member.roles:
        await ctx.send(embed=nova_embed("uNMUTE", f"{member.mention} iS nOT mUTED!"))
        return
    
    try:
        await member.remove_roles(role, reason=f"Unmuted by {ctx.author}: {reason}")
        
        # Log the unmute
        user_id = str(member.id)
        if user_id not in INFRACTIONS:
            INFRACTIONS[user_id] = []
        
        infraction = {
            "type": "unmute",
            "reason": reason,
            "moderator": str(ctx.author.id),
            "date": datetime.now().isoformat()
        }
        INFRACTIONS[user_id].append(infraction)
        save_infractions()
        
        embed = nova_embed("uNMUTE", f"{member.mention} hAS bEEN uNMUTED!")
        embed.add_field(name="rEASON", value=reason, inline=False)
        embed.add_field(name="mODERATOR", value=ctx.author.mention, inline=True)
        await ctx.send(embed=embed)
        
        # Log to mod channel
        mod_channel = get_mod_logs_channel(ctx.guild.id)
        if mod_channel:
            log_embed = nova_embed("mEMBER uNMUTED", f"{member.mention} was unmuted")
            log_embed.add_field(name="uSER", value=f"{member.mention} ({member.id})", inline=True)
            log_embed.add_field(name="mODERATOR", value=f"{ctx.author.mention} ({ctx.author.id})", inline=True)
            log_embed.add_field(name="rEASON", value=reason, inline=False)
            log_embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
            await mod_channel.send(embed=log_embed)
        
    except Exception as e:
        await ctx.send(embed=nova_embed("uNMUTE", f"cOULD nOT uNMUTE tHAT uSER! {str(e)}"))

@bot.tree.command(name="unmute", description="Unmute a member server-wide (admin only)")
@app_commands.describe(member="Member to unmute", reason="Reason for unmuting")
async def unmute_slash(interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
    if not has_mod_or_admin_interaction(interaction):
        await interaction.response.send_message(embed=nova_embed("uNMUTE", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    
    role = discord.utils.get(interaction.guild.roles, name="Muted")
    if not role or role not in member.roles:
        await interaction.response.send_message(embed=nova_embed("uNMUTE", f"{member.mention} iS nOT mUTED!"), ephemeral=True)
        return
    
    try:
        await member.remove_roles(role, reason=f"Unmuted by {interaction.user}: {reason}")
        
        # Log the unmute
        user_id = str(member.id)
        if user_id not in INFRACTIONS:
            INFRACTIONS[user_id] = []
        
        infraction = {
            "type": "unmute",
            "reason": reason,
            "moderator": str(interaction.user.id),
            "date": datetime.now().isoformat()
        }
        INFRACTIONS[user_id].append(infraction)
        save_infractions()
        
        embed = nova_embed("uNMUTE", f"{member.mention} hAS bEEN uNMUTED!")
        embed.add_field(name="rEASON", value=reason, inline=False)
        embed.add_field(name="mODERATOR", value=interaction.user.mention, inline=True)
        await interaction.response.send_message(embed=embed)
        
        # Log to mod channel
        mod_channel = get_mod_logs_channel(interaction.guild.id)
        if mod_channel:
            log_embed = nova_embed("mEMBER uNMUTED", f"{member.mention} was unmuted")
            log_embed.add_field(name="uSER", value=f"{member.mention} ({member.id})", inline=True)
            log_embed.add_field(name="mODERATOR", value=f"{interaction.user.mention} ({interaction.user.id})", inline=True)
            log_embed.add_field(name="rEASON", value=reason, inline=False)
            log_embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
            await mod_channel.send(embed=log_embed)
        
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("uNMUTE", f"cOULD nOT uNMUTE tHAT uSER! {str(e)}"), ephemeral=True)

# Case management system
@bot.command()
async def case(ctx, member: discord.Member = None):
    """Show a member's past infractions"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("cASE", "oNLY mODS/aDMINS cAN vIEW cASES!"))
        return
    
    if member is None:
        await ctx.send(embed=nova_embed("cASE", "pLEASE sPECIFY a mEMBER!"))
        return
    
    user_id = str(member.id)
    
    if user_id not in INFRACTIONS or not INFRACTIONS[user_id]:
        await ctx.send(embed=nova_embed("cASE", f"{member.display_name} hAS nO iNFRACTIONS oN rECORD!"))
        return
    
    infractions = INFRACTIONS[user_id]
    embed = nova_embed(f"{member.display_name}'s cASE fILE", f"tOTAL iNFRACTIONS: {len(infractions)}")
    embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
    
    # Show last 10 infractions
    for i, infraction in enumerate(infractions[-10:], 1):
        infraction_date = datetime.fromisoformat(infraction['date'])
        formatted_date = infraction_date.strftime("%Y-%m-%d %H:%M")
        
        moderator_id = infraction.get('moderator', 'Unknown')
        try:
            moderator = ctx.guild.get_member(int(moderator_id)) if moderator_id != 'Unknown' else None
            moderator_name = moderator.display_name if moderator else 'Unknown'
        except:
            moderator_name = 'Unknown'
        
        embed.add_field(
            name=f"#{len(infractions) - 10 + i} - {infraction['type'].upper()}",
            value=f"**rEASON:** {infraction['reason']}\n**mOD:** {moderator_name}\n**dATE:** {formatted_date}",
            inline=False
        )
    
    if len(infractions) > 10:
        embed.set_footer(text=f"sHOWING lAST 10 oF {len(infractions)} iNFRACTIONS")
    
    await ctx.send(embed=embed)

@bot.tree.command(name="case", description="View a member's infraction history")
@app_commands.describe(member="Member to view case file for")
async def case_slash(interaction: discord.Interaction, member: discord.Member):
    if not has_mod_or_admin_interaction(interaction):
        await interaction.response.send_message(embed=nova_embed("cASE", "oNLY mODS/aDMINS cAN vIEW cASES!"), ephemeral=True)
        return
    
    user_id = str(member.id)
    
    if user_id not in INFRACTIONS or not INFRACTIONS[user_id]:
        await interaction.response.send_message(embed=nova_embed("cASE", f"{member.display_name} hAS nO iNFRACTIONS oN rECORD!"))
        return
    
    infractions = INFRACTIONS[user_id]
    embed = nova_embed(f"{member.display_name}'s cASE fILE", f"tOTAL iNFRACTIONS: {len(infractions)}")
    embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
    
    # Show last 10 infractions
    for i, infraction in enumerate(infractions[-10:], 1):
        infraction_date = datetime.fromisoformat(infraction['date'])
        formatted_date = infraction_date.strftime("%Y-%m-%d %H:%M")
        
        moderator_id = infraction.get('moderator', 'Unknown')
        try:
            moderator = interaction.guild.get_member(int(moderator_id)) if moderator_id != 'Unknown' else None
            moderator_name = moderator.display_name if moderator else 'Unknown'
        except:
            moderator_name = 'Unknown'
        
        embed.add_field(
            name=f"#{len(infractions) - 10 + i} - {infraction['type'].upper()}",
            value=f"**rEASON:** {infraction['reason']}\n**mOD:** {moderator_name}\n**dATE:** {formatted_date}",
            inline=False
        )
    
    if len(infractions) > 10:
        embed.set_footer(text=f"sHOWING lAST 10 oF {len(infractions)} iNFRACTIONS")
    
    await interaction.response.send_message(embed=embed)

# Birthday system
BIRTHDAYS_FILE = "birthdays.json"

def load_birthdays():
    try:
        with open(BIRTHDAYS_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_birthdays(birthdays):
    with open(BIRTHDAYS_FILE, "w") as f:
        json.dump(birthdays, f, indent=4)

# International Days Dictionary
INTERNATIONAL_DAYS = {
    "01-01": "New Year's Day",
    "14-02": "Valentine's Day",
    "17-03": "St. Patrick's Day",
    "22-04": "Earth Day",
    "01-05": "International Workers' Day",
    "05-06": "World Environment Day",
    "04-07": "Independence Day (USA)",
    "31-10": "Halloween",
    "25-12": "Christmas Day",
    "08-03": "International Women's Day",
    "01-04": "April Fools' Day",
    "23-04": "World Book Day",
    "15-05": "International Day of Families",
    "21-06": "International Day of Yoga",
    "11-07": "World Population Day",
    "12-08": "International Youth Day",
    "21-09": "International Day of Peace",
    "16-10": "World Food Day",
    "20-11": "Universal Children's Day",
    "10-12": "Human Rights Day"
}

@bot.command()
async def setbirthday(ctx, date: str):
    """Set your birthday (format: DD-MM)"""
    try:
        # Validate date format
        day, month = map(int, date.split('-'))
        if not (1 <= day <= 31 and 1 <= month <= 12):
            raise ValueError
        # Reformat to ensure consistency
        date = f"{day:02d}-{month:02d}"
    except (ValueError, IndexError):
        await ctx.send(embed=nova_embed("üéÇ sET bIRTHDAY", "Please use the format DD-MM, e.g. 15-04 for April 15th."))
        return
    
    birthdays = load_birthdays()
    birthdays[str(ctx.author.id)] = date
    save_birthdays(birthdays)
    await ctx.send(embed=nova_embed("üéÇ sET bIRTHDAY", f"Birthday set to {date}!"))

@bot.tree.command(name="setbirthday", description="Set your birthday")
@app_commands.describe(date="Your birthday in DD-MM format (e.g., 15-04 for April 15th)")
async def setbirthday_slash(interaction: discord.Interaction, date: str):
    try:
        # Validate date format
        day, month = map(int, date.split('-'))
        if not (1 <= day <= 31 and 1 <= month <= 12):
            raise ValueError
        # Reformat to ensure consistency
        date = f"{day:02d}-{month:02d}"
    except (ValueError, IndexError):
        await interaction.response.send_message(embed=nova_embed("üéÇ sET bIRTHDAY", "Please use the format DD-MM, e.g. 15-04 for April 15th."), ephemeral=True)
        return
    
    birthdays = load_birthdays()
    birthdays[str(interaction.user.id)] = date
    save_birthdays(birthdays)
    await interaction.response.send_message(embed=nova_embed("üéÇ sET bIRTHDAY", f"Birthday set to {date}!"))

@bot.command()
async def birthdays(ctx):
    """Show upcoming birthdays in the server"""
    birthdays = load_birthdays()
    if not birthdays:
        await ctx.send(embed=nova_embed("üéÇ bIRTHDAYS", "No birthdays set yet! Use ?setbirthday to add yours."))
        return
    
    today = datetime.now()
    current_date = today.strftime("%d-%m")
    
    # Get today's birthdays
    today_birthdays = []
    upcoming_birthdays = []
    
    for user_id, birthday in birthdays.items():
        member = ctx.guild.get_member(int(user_id))
        if member:
            if birthday == current_date:
                today_birthdays.append(member)
            else:
                # Calculate days until birthday
                try:
                    day, month = map(int, birthday.split('-'))
                    this_year = today.year
                    birthday_date = datetime(this_year, month, day)
                    
                    if birthday_date < today:
                        birthday_date = datetime(this_year + 1, month, day)
                    
                    days_until = (birthday_date - today).days
                    upcoming_birthdays.append((member, days_until, birthday))
                except:
                    continue
    
    # Sort upcoming birthdays by days until
    upcoming_birthdays.sort(key=lambda x: x[1])
    
    embed = nova_embed("üéÇ bIRTHDAYS", "")
    
    if today_birthdays:
        birthday_list = "\n".join([f"üéâ {member.display_name}" for member in today_birthdays])
        embed.add_field(name="üéÇ tODAY'S bIRTHDAYS!", value=birthday_list, inline=False)
    
    if upcoming_birthdays:
        upcoming_list = "\n".join([
            f"{member.display_name} - {days} day{'s' if days != 1 else ''} ({birthday})"
            for member, days, birthday in upcoming_birthdays[:10]
        ])
        embed.add_field(name="üìÖ uPCOMING bIRTHDAYS", value=upcoming_list, inline=False)
    
    if not today_birthdays and not upcoming_birthdays:
        embed.description = "No birthdays found for server members!"
    
    await ctx.send(embed=embed)

@bot.command()
async def today(ctx):
    """Shows today's international day, Nova style, in a vibrant embed."""
    now = datetime.now()
    key = now.strftime("%d-%m")
    day = INTERNATIONAL_DAYS.get(key)
    if day:
        embed = discord.Embed(
            title="üåç tODAY iS...",
            description=f"**{day}!**",
            color=0xff69b4  # Hot pink for Nova!
        )
        embed.set_footer(text="nOVA bRINGS yOU tHE dAY!")
    else:
        embed = discord.Embed(
            title="nO iNTERNATIONAL dAY tODAY!",
            description="tRY aGAIN tOMORROW bABY üòò",
            color=0x7289da  # Discord blurple
        )
        embed.set_footer(text="nOVA sAYS: mAYBE nEXT tIME!")
    await ctx.send(embed=embed)

@bot.tree.command(name="today", description="Show today's international day")
async def today_slash(interaction: discord.Interaction):
    now = datetime.now()
    key = now.strftime("%d-%m")
    day = INTERNATIONAL_DAYS.get(key)
    if day:
        embed = discord.Embed(
            title="üåç tODAY iS...",
            description=f"**{day}!**",
            color=0xff69b4  # Hot pink for Nova!
        )
        embed.set_footer(text="nOVA bRINGS yOU tHE dAY!")
    else:
        embed = discord.Embed(
            title="nO iNTERNATIONAL dAY tODAY!",
            description="tRY aGAIN tOMORROW bABY üòò",
            color=0x7289da  # Discord blurple
        )
        embed.set_footer(text="nOVA sAYS: mAYBE nEXT tIME!")
    await interaction.response.send_message(embed=embed)

# Enhanced profile system with detailed logging
@bot.command()
async def aboutme(ctx, user: discord.Member = None):
    """View someone's about me description."""
    target_user = user or ctx.author
    profiles = load_profiles()
    
    user_profile = profiles.get(str(target_user.id))
    if not user_profile or "about_me" not in user_profile:
        if target_user == ctx.author:
            await ctx.send(embed=nova_embed("üìù aBOUT mE", "You haven't set an about me yet! Use /setaboutme <description> to set one."))
        else:
            await ctx.send(embed=nova_embed("üìù aBOUT mE", f"{target_user.display_name} hasn't set an about me yet."))
        return
    
    embed = discord.Embed(
        title=f"üìù {target_user.display_name}'s About Me",
        description=user_profile["about_me"],
        color=0xff69b4
    )
    embed.set_thumbnail(url=target_user.display_avatar.url)
    embed.set_footer(text=f"Set on {datetime.fromisoformat(user_profile['set_date']).strftime('%B %d, %Y')}")
    
    await ctx.send(embed=embed)

@bot.tree.command(name="aboutme", description="View someone's about me description")
@app_commands.describe(user="User to view about me for (optional)")
async def aboutme_slash(interaction: discord.Interaction, user: discord.Member = None):
    target_user = user or interaction.user
    profiles = load_profiles()
    
    user_profile = profiles.get(str(target_user.id))
    if not user_profile or "about_me" not in user_profile:
        if target_user == interaction.user:
            await interaction.response.send_message(embed=nova_embed("üìù aBOUT mE", "You haven't set an about me yet! Use /setaboutme <description> to set one."))
        else:
            await interaction.response.send_message(embed=nova_embed("üìù aBOUT mE", f"{target_user.display_name} hasn't set an about me yet."))
        return
    
    embed = discord.Embed(
        title=f"üìù {target_user.display_name}'s About Me",
        description=user_profile["about_me"],
        color=0xff69b4
    )
    embed.set_thumbnail(url=target_user.display_avatar.url)
    embed.set_footer(text=f"Set on {datetime.fromisoformat(user_profile['set_date']).strftime('%B %d, %Y')}")
    
    await interaction.response.send_message(embed=embed)

# Enhanced setaboutme with comprehensive logging
@bot.tree.command(name="setaboutme", description="Set your about me description")
@app_commands.describe(description="Your about me description (max 500 characters)")
async def setaboutme_slash(interaction: discord.Interaction, description: str):
    if len(description) > 500:
        await interaction.response.send_message(embed=nova_embed("üìù sET aBOUT mE", "Description too long! Maximum 500 characters."), ephemeral=True)
        return
    
    profiles = load_profiles()
    
    # Get old about me for logging
    old_profile = profiles.get(str(interaction.user.id))
    old_about_me = old_profile.get("about_me", "None") if old_profile else "None"
    
    profiles[str(interaction.user.id)] = {
        "about_me": description,
        "set_date": datetime.now().isoformat()
    }
    save_profiles(profiles)
    
    # Log to server logs channel
    server_logs_channel = get_server_logs_channel(interaction.guild.id)
    if server_logs_channel:
        try:
            embed = discord.Embed(
                title="üìù About Me Updated",
                color=0xff69b4,
                timestamp=datetime.now()
            )
            embed.add_field(name="User", value=f"{interaction.user.mention}\n`{interaction.user.id}`", inline=True)
            embed.add_field(name="Changes", value=f"**About Me:**\nBefore: `{old_about_me}`\nAfter: `{description}`", inline=False)
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            
            await server_logs_channel.send(embed=embed)
        except Exception as e:
            print(f"Failed to send about me update log: {e}")
    
    await interaction.response.send_message(embed=nova_embed("üìù aBOUT mE uPDATED", f"Your about me has been set to:\n\n*{description}*"))

# Weather system
@bot.command()
async def weather(ctx, *, location: str = None):
    """Get weather information for a location"""
    if not location:
        await ctx.send(embed=nova_embed("üå§Ô∏è wEATHER", "Please provide a location! Example: ?weather London"))
        return
    
    # This is a placeholder - you would need to integrate with a weather API
    embed = nova_embed("üå§Ô∏è wEATHER", f"Weather data for {location} would appear here!")
    embed.add_field(name="üìç lOCATION", value=location, inline=True)
    embed.add_field(name="‚ö†Ô∏è nOTE", value="Weather API integration needed", inline=False)
    await ctx.send(embed=embed)

@bot.tree.command(name="weather", description="Get weather information for a location")
@app_commands.describe(location="Location to get weather for")
async def weather_slash(interaction: discord.Interaction, location: str):
    # This is a placeholder - you would need to integrate with a weather API
    embed = nova_embed("üå§Ô∏è wEATHER", f"Weather data for {location} would appear here!")
    embed.add_field(name="üìç lOCATION", value=location, inline=True)
    embed.add_field(name="‚ö†Ô∏è nOTE", value="Weather API integration needed", inline=False)
    await interaction.response.send_message(embed=embed)

# Comprehensive jail system with role management
JAIL_CHANNEL_ID = None  # Set this to your jail channel ID

@bot.command()
async def setjail(ctx, channel: discord.TextChannel = None):
    """Set the jail channel (admin only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET jAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    
    if not channel:
        await ctx.send(embed=nova_embed("sET jAIL", "pLEASE mENTION a cHANNEL!"))
        return
    
    global JAIL_CHANNEL_ID
    JAIL_CHANNEL_ID = channel.id
    
    # Save to server config
    set_server_config(ctx.guild.id, "jail_channel_id", channel.id)
    
    await ctx.send(embed=nova_embed("sET jAIL", f"jAIL cHANNEL sET tO {channel.mention}!"))

@bot.command()
async def jail(ctx, user: discord.Member = None, *, reason: str = "No reason provided"):
    """Move a user to the jail channel and restrict permissions (admin/mod only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("jAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    
    if not user:
        await ctx.send(embed=nova_embed("jAIL", "pLEASE mENTION a uSER!"))
        return
    
    if user == ctx.author:
        await ctx.send(embed=nova_embed("jAIL", "yOU cAN'T jAIL yOURSELF!"))
        return
    
    if user.id == OWNER_ID:
        await ctx.send(embed=nova_embed("jAIL", "yOU cAN'T jAIL tHE bOT oWNER!"))
        return
    
    # Get jail channel from server config
    jail_channel_id = get_server_config(ctx.guild.id, "jail_channel_id")
    if not jail_channel_id:
        await ctx.send(embed=nova_embed("jAIL", "jAIL cHANNEL nOT sET! uSE ?setjail #channel"))
        return
    
    try:
        jail_channel = ctx.guild.get_channel(jail_channel_id)
        if not jail_channel:
            await ctx.send(embed=nova_embed("jAIL", "cOULD nOT fIND tHE jAIL cHANNEL!"))
            return
        
        # Create or get inmate role
        inmate_role = discord.utils.get(ctx.guild.roles, name="iNMATE")
        if not inmate_role:
            try:
                inmate_role = await ctx.guild.create_role(
                    name="iNMATE",
                    color=discord.Color.dark_red(),
                    reason="Jail system role"
                )
                # Set permissions for all channels
                for channel in ctx.guild.channels:
                    if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                        try:
                            await channel.set_permissions(inmate_role, 
                                send_messages=False, 
                                speak=False, 
                                add_reactions=False,
                                create_public_threads=False,
                                create_private_threads=False,
                                send_messages_in_threads=False,
                                view_channel=True,
                                read_message_history=True
                            )
                        except discord.Forbidden:
                            continue  # Skip channels we can't modify
            except discord.Forbidden:
                await ctx.send(embed=nova_embed("jAIL", "cAN'T cREATE iNMATE rOLE - nO pERMISSION!"))
                return
        else:
            # If role exists, make sure permissions are set correctly
            for channel in ctx.guild.channels:
                if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                    try:
                        await channel.set_permissions(inmate_role, 
                            send_messages=False, 
                            speak=False, 
                            add_reactions=False,
                            create_public_threads=False,
                            create_private_threads=False,
                            send_messages_in_threads=False,
                            view_channel=True,
                            read_message_history=True
                        )
                    except discord.Forbidden:
                        continue  # Skip channels we can't modify
        
        # Allow speaking in jail channel
        try:
            await jail_channel.set_permissions(inmate_role, 
                send_messages=True, 
                add_reactions=True,
                view_channel=True,
                read_message_history=True
            )
        except discord.Forbidden:
            pass
        
        # Add inmate role to user
        if inmate_role not in user.roles:
            await user.add_roles(inmate_role, reason=f"Jailed by {ctx.author}: {reason}")
        
        # Try to move user to jail channel if they're in voice
        if user.voice:
            try:
                await user.move_to(jail_channel)
            except (discord.Forbidden, discord.HTTPException):
                pass  # Don't fail if we can't move them
        
        # Log the jail
        user_id = str(user.id)
        if user_id not in INFRACTIONS:
            INFRACTIONS[user_id] = []
        
        infraction = {
            "type": "jail",
            "reason": reason,
            "moderator": str(ctx.author.id),
            "date": datetime.now().isoformat()
        }
        INFRACTIONS[user_id].append(infraction)
        save_infractions()
        
        embed = nova_embed("jAIL", f"{user.mention} hAS bEEN jAILED!")
        embed.add_field(name="rEASON", value=reason, inline=False)
        embed.add_field(name="mODERATOR", value=ctx.author.mention, inline=True)
        embed.add_field(name="jAIL cHANNEL", value=jail_channel.mention, inline=True)
        await ctx.send(embed=embed)
        
        # Log to mod channel
        mod_channel = get_mod_logs_channel(ctx.guild.id)
        if mod_channel:
            log_embed = nova_embed("mEMBER jAILED", f"{user.mention} was jailed")
            log_embed.add_field(name="uSER", value=f"{user.mention} ({user.id})", inline=True)
            log_embed.add_field(name="mODERATOR", value=f"{ctx.author.mention} ({ctx.author.id})", inline=True)
            log_embed.add_field(name="rEASON", value=reason, inline=False)
            log_embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
            await mod_channel.send(embed=log_embed)
        
    except discord.Forbidden:
        await ctx.send(embed=nova_embed("jAIL", "nO pERMISSION tO mANAGE rOLES oR cHANNELS!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("jAIL", f"eRROR: {str(e)}"))

@bot.tree.command(name="jail", description="Move a user to the jail channel and restrict permissions (admin/mod only)")
@app_commands.describe(user="The user to jail", reason="Reason for jailing")
async def jail_slash(interaction: discord.Interaction, user: discord.Member, reason: str = "No reason provided"):
    if not has_mod_or_admin_interaction(interaction):
        await interaction.response.send_message(embed=nova_embed("jAIL", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    
    if user == interaction.user:
        await interaction.response.send_message(embed=nova_embed("jAIL", "yOU cAN'T jAIL yOURSELF!"), ephemeral=True)
        return
    
    if user.id == OWNER_ID:
        await interaction.response.send_message(embed=nova_embed("jAIL", "yOU cAN'T jAIL tHE bOT oWNER!"), ephemeral=True)
        return
    
    # Get jail channel from server config
    jail_channel_id = get_server_config(interaction.guild.id, "jail_channel_id")
    if not jail_channel_id:
        await interaction.response.send_message(embed=nova_embed("jAIL", "jAIL cHANNEL nOT sET! uSE ?setjail #channel"), ephemeral=True)
        return
    
    try:
        jail_channel = interaction.guild.get_channel(jail_channel_id)
        if not jail_channel:
            await interaction.response.send_message(embed=nova_embed("jAIL", "cOULD nOT fIND tHE jAIL cHANNEL!"), ephemeral=True)
            return
        
        # Create or get inmate role
        inmate_role = discord.utils.get(interaction.guild.roles, name="iNMATE")
        if not inmate_role:
            try:
                inmate_role = await interaction.guild.create_role(
                    name="iNMATE",
                    color=discord.Color.dark_red(),
                    reason="Jail system role"
                )
                # Set permissions for all channels
                for channel in interaction.guild.channels:
                    if isinstance(channel, (discord.TextChannel, discord.VoiceChannel)):
                        try:
                            await channel.set_permissions(inmate_role, 
                                send_messages=False, 
                                speak=False, 
                                add_reactions=False,
                                create_public_threads=False,
                                create_private_threads=False,
                                send_messages_in_threads=False,
                                view_channel=True,
                                read_message_history=True
                            )
                        except discord.Forbidden:
                            continue  # Skip channels we can't modify
            except discord.Forbidden:
                await interaction.response.send_message(embed=nova_embed("jAIL", "cAN'T cREATE iNMATE rOLE - nO pERMISSION!"), ephemeral=True)
                return
        
        # Allow speaking in jail channel
        try:
            await jail_channel.set_permissions(inmate_role, 
                send_messages=True, 
                add_reactions=True,
                view_channel=True,
                read_message_history=True
            )
        except discord.Forbidden:
            pass
        
        # Add inmate role to user
        if inmate_role not in user.roles:
            await user.add_roles(inmate_role, reason=f"Jailed by {interaction.user}: {reason}")
        
        # Try to move user to jail channel if they're in voice
        if user.voice:
            try:
                await user.move_to(jail_channel)
            except (discord.Forbidden, discord.HTTPException):
                pass  # Don't fail if we can't move them
        
        # Log the jail
        user_id = str(user.id)
        if user_id not in INFRACTIONS:
            INFRACTIONS[user_id] = []
        
        infraction = {
            "type": "jail",
            "reason": reason,
            "moderator": str(interaction.user.id),
            "date": datetime.now().isoformat()
        }
        INFRACTIONS[user_id].append(infraction)
        save_infractions()
        
        embed = nova_embed("jAIL", f"{user.mention} hAS bEEN jAILED!")
        embed.add_field(name="rEASON", value=reason, inline=False)
        embed.add_field(name="mODERATOR", value=interaction.user.mention, inline=True)
        embed.add_field(name="jAIL cHANNEL", value=jail_channel.mention, inline=True)
        await interaction.response.send_message(embed=embed)
        
        # Log to mod channel
        mod_channel = get_mod_logs_channel(interaction.guild.id)
        if mod_channel:
            log_embed = nova_embed("mEMBER jAILED", f"{user.mention} was jailed")
            log_embed.add_field(name="uSER", value=f"{user.mention} ({user.id})", inline=True)
            log_embed.add_field(name="mODERATOR", value=f"{interaction.user.mention} ({interaction.user.id})", inline=True)
            log_embed.add_field(name="rEASON", value=reason, inline=False)
            log_embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
            await mod_channel.send(embed=log_embed)
        
    except discord.Forbidden:
        await interaction.response.send_message(embed=nova_embed("jAIL", "nO pERMISSION tO mANAGE rOLES oR cHANNELS!"), ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("jAIL", f"eRROR: {str(e)}"), ephemeral=True)

@bot.command()
async def unjail(ctx, user: discord.Member = None, *, reason: str = "No reason provided"):
    """Remove a user from jail (admin/mod only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("uNJAIL", "yOU dON'T hAVE pERMISSION!"))
        return
    
    if not user:
        await ctx.send(embed=nova_embed("uNJAIL", "pLEASE mENTION a uSER!"))
        return
    
    inmate_role = discord.utils.get(ctx.guild.roles, name="iNMATE")
    if not inmate_role or inmate_role not in user.roles:
        await ctx.send(embed=nova_embed("uNJAIL", f"{user.mention} iS nOT jAILED!"))
        return
    
    try:
        await user.remove_roles(inmate_role, reason=f"Unjailed by {ctx.author}: {reason}")
        
        # Log the unjail
        user_id = str(user.id)
        if user_id not in INFRACTIONS:
            INFRACTIONS[user_id] = []
        
        infraction = {
            "type": "unjail",
            "reason": reason,
            "moderator": str(ctx.author.id),
            "date": datetime.now().isoformat()
        }
        INFRACTIONS[user_id].append(infraction)
        save_infractions()
        
        embed = nova_embed("uNJAIL", f"{user.mention} hAS bEEN rELEASED fROM jAIL!")
        embed.add_field(name="rEASON", value=reason, inline=False)
        embed.add_field(name="mODERATOR", value=ctx.author.mention, inline=True)
        await ctx.send(embed=embed)
        
        # Log to mod channel
        mod_channel = get_mod_logs_channel(ctx.guild.id)
        if mod_channel:
            log_embed = nova_embed("mEMBER uNJAILED", f"{user.mention} was released from jail")
            log_embed.add_field(name="uSER", value=f"{user.mention} ({user.id})", inline=True)
            log_embed.add_field(name="mODERATOR", value=f"{ctx.author.mention} ({ctx.author.id})", inline=True)
            log_embed.add_field(name="rEASON", value=reason, inline=False)
            log_embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
            await mod_channel.send(embed=log_embed)
        
    except Exception as e:
        await ctx.send(embed=nova_embed("uNJAIL", f"eRROR: {str(e)}"))

@bot.tree.command(name="unjail", description="Remove a user from jail (admin/mod only)")
@app_commands.describe(user="The user to unjail", reason="Reason for unjailing")
async def unjail_slash(interaction: discord.Interaction, user: discord.Member, reason: str = "No reason provided"):
    if not has_mod_or_admin_interaction(interaction):
        await interaction.response.send_message(embed=nova_embed("uNJAIL", "yOU dON'T hAVE pERMISSION!"), ephemeral=True)
        return
    
    inmate_role = discord.utils.get(interaction.guild.roles, name="iNMATE")
    if not inmate_role or inmate_role not in user.roles:
        await interaction.response.send_message(embed=nova_embed("uNJAIL", f"{user.mention} iS nOT jAILED!"), ephemeral=True)
        return
    
    try:
        await user.remove_roles(inmate_role, reason=f"Unjailed by {interaction.user}: {reason}")
        
        # Log the unjail
        user_id = str(user.id)
        if user_id not in INFRACTIONS:
            INFRACTIONS[user_id] = []
        
        infraction = {
            "type": "unjail",
            "reason": reason,
            "moderator": str(interaction.user.id),
            "date": datetime.now().isoformat()
        }
        INFRACTIONS[user_id].append(infraction)
        save_infractions()
        
        embed = nova_embed("uNJAIL", f"{user.mention} hAS bEEN rELEASED fROM jAIL!")
        embed.add_field(name="rEASON", value=reason, inline=False)
        embed.add_field(name="mODERATOR", value=interaction.user.mention, inline=True)
        await interaction.response.send_message(embed=embed)
        
        # Log to mod channel
        mod_channel = get_mod_logs_channel(interaction.guild.id)
        if mod_channel:
            log_embed = nova_embed("mEMBER uNJAILED", f"{user.mention} was released from jail")
            log_embed.add_field(name="uSER", value=f"{user.mention} ({user.id})", inline=True)
            log_embed.add_field(name="mODERATOR", value=f"{interaction.user.mention} ({interaction.user.id})", inline=True)
            log_embed.add_field(name="rEASON", value=reason, inline=False)
            log_embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
            await mod_channel.send(embed=log_embed)
        
    except Exception as e:
        await interaction.response.send_message(embed=nova_embed("uNJAIL", f"eRROR: {str(e)}"), ephemeral=True)

# Store last deleted and edited messages per channel
snipes = {}  # channel_id: {'content': str, 'author': str, 'time': datetime}
edsnipes = {}  # channel_id: {'content': str, 'author': str, 'time': datetime}
rsnipes = {}  # channel_id: {'emoji': str, 'user': str, 'message_id': int, 'jump_url': str, 'time': datetime}

# Enhanced message deletion logging
@bot.event
async def on_message_delete(message):
    if message.author.bot:
        return
    
    # Store for snipe command
    snipes[message.channel.id] = {
        'content': message.content,
        'author': str(message.author),
        'time': message.created_at
    }
    
    # Chat logs for mods - Enhanced debugging
    print(f"DEBUG: Message deleted by {message.author} in {message.channel}")
    
    # Log to server-specific chat logs channel
    chat_logs_channel = get_chat_logs_channel(message.guild.id)
    if chat_logs_channel:
        try:
            content = message.content if message.content else "*[No text content]*"
            embed = nova_embed("üóëÔ∏è mESSAGE dELETED", f"**Author:** {message.author}\n**Channel:** {message.channel.mention}\n**Message ID:** {message.id}\n**Content:** {content}")
            embed.timestamp = datetime.now(dt_timezone.utc)
            await chat_logs_channel.send(embed=embed)
            print(f"DEBUG: Chat log sent successfully to {chat_logs_channel.name}")
        except Exception as e:
            print(f"ERROR: Failed to send chat log: {e}")
            import traceback
            traceback.print_exc()
    
    # Also log to central logging if configured
    if CENTRAL_LOGGING_ENABLED:
        try:
            # Get server logging category
            guild_name = sanitize_server_name(message.guild.name)
            category_name = f"{guild_name}-logs"
            
            category = discord.utils.get(bot.get_guild(CENTRAL_LOGGING_GUILD_ID).categories, name=category_name)
            if category:
                messages_channel = discord.utils.get(category.channels, name="messages")
                if messages_channel:
                    content = message.content if message.content else "*[No text content]*"
                    embed = nova_embed("üóëÔ∏è mESSAGE dELETED", f"**Server:** {message.guild.name}\n**Author:** {message.author}\n**Channel:** {message.channel.mention}\n**Message ID:** {message.id}\n**Content:** {content}")
                    embed.timestamp = datetime.now(dt_timezone.utc)
                    await messages_channel.send(embed=embed)
        except Exception as e:
            print(f"ERROR: Failed to send central message deletion log: {e}")

# Enhanced message edit logging
@bot.event
async def on_message_edit(before, after):
    if before.author.bot or before.content == after.content:
        return
    
    # Store for edsnipe command
    edsnipes[before.channel.id] = {
        'content': before.content,
        'author': str(before.author),
        'time': before.edited_at or before.created_at
    }
    
    # Chat logs for message edits - Enhanced debugging
    print(f"DEBUG: Message edited by {before.author} in {before.channel}")
    
    # Log to server-specific chat logs channel
    chat_logs_channel = get_chat_logs_channel(before.guild.id)
    if chat_logs_channel:
        try:
            before_content = before.content if before.content else "*[No text content]*"
            after_content = after.content if after.content else "*[No text content]*"
            
            embed = nova_embed(
                "‚úèÔ∏è mESSAGE eDITED", 
                f"**Author:** {before.author}\n**Channel:** {before.channel.mention}\n**Message ID:** {before.id}"
            )
            embed.add_field(name="Before", value=f"```{before_content[:1000]}```", inline=False)
            embed.add_field(name="After", value=f"```{after_content[:1000]}```", inline=False)
            embed.add_field(name="Jump to Message", value=f"[Click here]({after.jump_url})", inline=False)
            embed.timestamp = datetime.now(dt_timezone.utc)
            embed.color = 0xffcc00  # Yellow for edits
            
            await chat_logs_channel.send(embed=embed)
            print(f"DEBUG: Edit log sent successfully to {chat_logs_channel.name}")
        except Exception as e:
            print(f"ERROR: Failed to send edit log: {e}")
            import traceback
            traceback.print_exc()
    
    # Also log to central logging if configured
    if CENTRAL_LOGGING_ENABLED:
        try:
            # Get server logging category
            guild_name = sanitize_server_name(before.guild.name)
            category_name = f"{guild_name}-logs"
            
            category = discord.utils.get(bot.get_guild(CENTRAL_LOGGING_GUILD_ID).categories, name=category_name)
            if category:
                messages_channel = discord.utils.get(category.channels, name="messages")
                if messages_channel:
                    before_content = before.content if before.content else "*[No text content]*"
                    after_content = after.content if after.content else "*[No text content]*"
                    
                    embed = nova_embed(
                        "‚úèÔ∏è mESSAGE eDITED", 
                        f"**Server:** {before.guild.name}\n**Author:** {before.author}\n**Channel:** {before.channel.mention}\n**Message ID:** {before.id}"
                    )
                    embed.add_field(name="Before", value=f"```{before_content[:500]}```", inline=False)
                    embed.add_field(name="After", value=f"```{after_content[:500]}```", inline=False)
                    embed.timestamp = datetime.now(dt_timezone.utc)
                    embed.color = 0xffcc00
                    
                    await messages_channel.send(embed=embed)
        except Exception as e:
            print(f"ERROR: Failed to send central message edit log: {e}")

# Reaction logging and snipe
@bot.event
async def on_reaction_remove(reaction, user):
    if user.bot:
        return
    
    # Store for reaction snipe
    rsnipes[reaction.message.channel.id] = {
        'emoji': str(reaction.emoji),
        'user': str(user),
        'message_id': reaction.message.id,
        'jump_url': reaction.message.jump_url,
        'time': datetime.now()
    }
    
    # Log to chat logs channel
    chat_logs_channel = get_chat_logs_channel(reaction.message.guild.id)
    if chat_logs_channel:
        try:
            embed = nova_embed(
                "üí≠ rEACTION rEMOVED",
                f"**User:** {user}\n**Channel:** {reaction.message.channel.mention}\n**Emoji:** {reaction.emoji}\n**Message:** [Jump to message]({reaction.message.jump_url})"
            )
            embed.timestamp = datetime.now(dt_timezone.utc)
            embed.color = 0xff6b6b  # Red for reaction removal
            await chat_logs_channel.send(embed=embed)
        except Exception as e:
            print(f"ERROR: Failed to send reaction removal log: {e}")

# Snipe commands
@bot.command()
async def snipe(ctx, channel: discord.TextChannel = None):
    """Show the last deleted message in a channel"""
    target_channel = channel or ctx.channel
    
    if target_channel.id not in snipes:
        await ctx.send(embed=nova_embed("sNIPE", "nO dELETED mESSAGES fOUND!"))
        return
    
    snipe_data = snipes[target_channel.id]
    embed = nova_embed("üéØ sNIPED mESSAGE", f"**Author:** {snipe_data['author']}\n**Content:** {snipe_data['content']}")
    embed.set_footer(text=f"Deleted at {snipe_data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)

@bot.tree.command(name="snipe", description="Show the last deleted message in a channel")
@app_commands.describe(channel="Channel to snipe (optional)")
async def snipe_slash(interaction: discord.Interaction, channel: discord.TextChannel = None):
    target_channel = channel or interaction.channel
    
    if target_channel.id not in snipes:
        await interaction.response.send_message(embed=nova_embed("sNIPE", "nO dELETED mESSAGES fOUND!"))
        return
    
    snipe_data = snipes[target_channel.id]
    embed = nova_embed("üéØ sNIPED mESSAGE", f"**Author:** {snipe_data['author']}\n**Content:** {snipe_data['content']}")
    embed.set_footer(text=f"Deleted at {snipe_data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed)

@bot.command()
async def editsnipe(ctx, channel: discord.TextChannel = None):
    """Show the last edited message in a channel"""
    target_channel = channel or ctx.channel
    
    if target_channel.id not in edsnipes:
        await ctx.send(embed=nova_embed("eDIT sNIPE", "nO eDITED mESSAGES fOUND!"))
        return
    
    snipe_data = edsnipes[target_channel.id]
    embed = nova_embed("‚úèÔ∏è eDIT sNIPED", f"**Author:** {snipe_data['author']}\n**Original Content:** {snipe_data['content']}")
    embed.set_footer(text=f"Edited at {snipe_data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)

@bot.tree.command(name="editsnipe", description="Show the last edited message in a channel")
@app_commands.describe(channel="Channel to edit snipe (optional)")
async def editsnipe_slash(interaction: discord.Interaction, channel: discord.TextChannel = None):
    target_channel = channel or interaction.channel
    
    if target_channel.id not in edsnipes:
        await interaction.response.send_message(embed=nova_embed("eDIT sNIPE", "nO eDITED mESSAGES fOUND!"))
        return
    
    snipe_data = edsnipes[target_channel.id]
    embed = nova_embed("‚úèÔ∏è eDIT sNIPED", f"**Author:** {snipe_data['author']}\n**Original Content:** {snipe_data['content']}")
    embed.set_footer(text=f"Edited at {snipe_data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed)

@bot.command()
async def reactionsnipe(ctx, channel: discord.TextChannel = None):
    """Show the last removed reaction in a channel"""
    target_channel = channel or ctx.channel
    
    if target_channel.id not in rsnipes:
        await ctx.send(embed=nova_embed("rEACTION sNIPE", "nO rEMOVED rEACTIONS fOUND!"))
        return
    
    snipe_data = rsnipes[target_channel.id]
    embed = nova_embed(
        "üí≠ rEACTION sNIPED", 
        f"**User:** {snipe_data['user']}\n**Emoji:** {snipe_data['emoji']}\n**Message:** [Jump to message]({snipe_data['jump_url']})"
    )
    embed.set_footer(text=f"Removed at {snipe_data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await ctx.send(embed=embed)

@bot.tree.command(name="reactionsnipe", description="Show the last removed reaction in a channel")
@app_commands.describe(channel="Channel to reaction snipe (optional)")
async def reactionsnipe_slash(interaction: discord.Interaction, channel: discord.TextChannel = None):
    target_channel = channel or interaction.channel
    
    if target_channel.id not in rsnipes:
        await interaction.response.send_message(embed=nova_embed("rEACTION sNIPE", "nO rEMOVED rEACTIONS fOUND!"))
        return
    
    snipe_data = rsnipes[target_channel.id]
    embed = nova_embed(
        "üí≠ rEACTION sNIPED", 
        f"**User:** {snipe_data['user']}\n**Emoji:** {snipe_data['emoji']}\n**Message:** [Jump to message]({snipe_data['jump_url']})"
    )
    embed.set_footer(text=f"Removed at {snipe_data['time'].strftime('%Y-%m-%d %H:%M:%S')}")
    await interaction.response.send_message(embed=embed)

# Advanced inventory system
INVENTORY_FILE = "inventory.json"

def load_inventory():
    try:
        with open(INVENTORY_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_inventory(inventory):
    with open(INVENTORY_FILE, "w") as f:
        json.dump(inventory, f, indent=4)

@bot.command()
async def inventory(ctx, user: discord.Member = None):
    """View your or someone else's inventory"""
    target_user = user or ctx.author
    inventory = load_inventory()
    
    user_inventory = inventory.get(str(target_user.id), [])
    
    if not user_inventory:
        if target_user == ctx.author:
            await ctx.send(embed=nova_embed("üéí iNVENTORY", "yOUR iNVENTORY iS eMPTY!"))
        else:
            await ctx.send(embed=nova_embed("üéí iNVENTORY", f"{target_user.display_name}'s iNVENTORY iS eMPTY!"))
        return
    
    # Count items
    item_counts = {}
    for item in user_inventory:
        item_counts[item] = item_counts.get(item, 0) + 1
    
    embed = nova_embed(f"üéí {target_user.display_name}'s iNVENTORY", "")
    
    for item, count in item_counts.items():
        embed.add_field(name=item, value=f"x{count}", inline=True)
    
    embed.set_thumbnail(url=target_user.avatar.url if target_user.avatar else target_user.default_avatar.url)
    await ctx.send(embed=embed)

@bot.tree.command(name="inventory", description="View your or someone else's inventory")
@app_commands.describe(user="User to view inventory for (optional)")
async def inventory_slash(interaction: discord.Interaction, user: discord.Member = None):
    target_user = user or interaction.user
    inventory = load_inventory()
    
    user_inventory = inventory.get(str(target_user.id), [])
    
    if not user_inventory:
        if target_user == interaction.user:
            await interaction.response.send_message(embed=nova_embed("üéí iNVENTORY", "yOUR iNVENTORY iS eMPTY!"))
        else:
            await interaction.response.send_message(embed=nova_embed("üéí iNVENTORY", f"{target_user.display_name}'s iNVENTORY iS eMPTY!"))
        return
    
    # Count items
    item_counts = {}
    for item in user_inventory:
        item_counts[item] = item_counts.get(item, 0) + 1
    
    embed = nova_embed(f"üéí {target_user.display_name}'s iNVENTORY", "")
    
    for item, count in item_counts.items():
        embed.add_field(name=item, value=f"x{count}", inline=True)
    
    embed.set_thumbnail(url=target_user.avatar.url if target_user.avatar else target_user.default_avatar.url)
    await interaction.response.send_message(embed=embed)

# =========================
# Support Ticket System
# =========================

# Global variables for ticket system
TICKET_CATEGORY_ID = None
SUPPORT_ROLE_ID = None
TICKET_LOGS_CHANNEL_ID = None
ticket_counter = 1

class TicketModal(discord.ui.Modal, title='Create Support Ticket'):
    def __init__(self):
        super().__init__()
        
    subject = discord.ui.TextInput(
        label='Subject',
        placeholder='Brief description of your issue...',
        max_length=100,
        required=True
    )
    
    description = discord.ui.TextInput(
        label='Description',
        placeholder='Detailed description of your issue...',
        style=discord.TextStyle.paragraph,
        max_length=1000,
        required=True
    )
    
    priority = discord.ui.TextInput(
        label='Priority (Low/Normal/High/Urgent)',
        placeholder='Normal',
        default='Normal',
        max_length=10,
        required=False
    )
    
    async def on_submit(self, interaction: discord.Interaction):
        global ticket_counter
        
        # Create ticket channel
        guild = interaction.guild
        
        # Get ticket category from server config
        ticket_category_id = get_server_config(guild.id, "ticket_category_id")
        category = None
        if ticket_category_id:
            category = guild.get_channel(ticket_category_id)
        
        # Create channel with unique name
        channel_name = f"ticket-{ticket_counter:04d}-{interaction.user.name}"
        ticket_counter += 1
        
        # Set permissions
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            interaction.user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        
        # Add support role if set
        support_role_id = get_server_config(guild.id, "support_role_id")
        if support_role_id:
            support_role = guild.get_role(support_role_id)
            if support_role:
                overwrites[support_role] = discord.PermissionOverwrite(read_messages=True, send_messages=True)
        
        try:
            ticket_channel = await guild.create_text_channel(
                name=channel_name,
                category=category,
                overwrites=overwrites
            )
            
            # Validate and format priority
            priority_input = self.priority.value.strip().lower() if self.priority.value else 'normal'
            priority_emojis = {
                'low': 'üü¢ Low',
                'normal': 'üîµ Normal', 
                'high': 'üü† High',
                'urgent': 'üî¥ Urgent'
            }
            
            # Default to normal if invalid priority
            if priority_input not in priority_emojis:
                priority_input = 'normal'
            
            priority_display = priority_emojis[priority_input]
            
            # Create ticket embed
            embed = nova_embed(
                "üé´ sUPPORT tICKET",
                f"**Subject:** {self.subject.value}\n**Priority:** {priority_display}\n\n**Description:**\n{self.description.value}"
            )
            embed.add_field(name="üë§ cREATED bY", value=interaction.user.mention, inline=True)
            embed.add_field(name="üï∞Ô∏è cREATED aT", value=f"<t:{int(datetime.now().timestamp())}:F>", inline=True)
            embed.add_field(name="üéØ tICKET iD", value=f"`{ticket_channel.name}`", inline=True)
            embed.set_thumbnail(url=interaction.user.avatar.url if interaction.user.avatar else interaction.user.default_avatar.url)
            
            # Create close button view
            view = TicketView()
            
            await ticket_channel.send(embed=embed, view=view)
            
            # Send confirmation to user
            await interaction.response.send_message(
                embed=nova_embed("üé´ tICKET cREATED", f"Your ticket has been created: {ticket_channel.mention}"),
                ephemeral=True
            )
            
            # Log ticket creation
            ticket_logs_channel_id = get_server_config(guild.id, "ticket_logs_channel_id")
            if ticket_logs_channel_id:
                logs_channel = guild.get_channel(ticket_logs_channel_id)
                if logs_channel:
                    log_embed = nova_embed(
                        "üé´ tICKET cREATED",
                        f"**User:** {interaction.user.mention}\n**Channel:** {ticket_channel.mention}\n**Subject:** {self.subject.value}\n**Priority:** {priority_display}"
                    )
                    log_embed.set_thumbnail(url=interaction.user.avatar.url if interaction.user.avatar else interaction.user.default_avatar.url)
                    await logs_channel.send(embed=log_embed)
            
        except Exception as e:
            await interaction.response.send_message(
                embed=nova_embed("üé´ tICKET eRROR", f"Failed to create ticket: {str(e)}"),
                ephemeral=True
            )

class TicketView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
    
    @discord.ui.button(label="üîí cLOSE tICKET", style=discord.ButtonStyle.danger, emoji="üîí")
    async def close_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Check if user has permission to close ticket
        if not (interaction.user.guild_permissions.manage_channels or 
                interaction.channel.permissions_for(interaction.user).manage_channels or
                interaction.user.id == interaction.guild.owner_id):
            # Check if user is the ticket creator (channel name contains their name)
            if interaction.user.name not in interaction.channel.name:
                await interaction.response.send_message(
                    embed=nova_embed("üîí cLOSE tICKET", "You don't have permission to close this ticket!"),
                    ephemeral=True
                )
                return
        
        # Create transcript before closing
        transcript = []
        async for message in interaction.channel.history(limit=None, oldest_first=True):
            if not message.author.bot or message.embeds:
                timestamp = message.created_at.strftime("%Y-%m-%d %H:%M:%S")
                content = message.content if message.content else "[Embed/Attachment]"
                transcript.append(f"[{timestamp}] {message.author}: {content}")
        
        # Save transcript to file
        transcript_content = "\n".join(transcript)
        transcript_file = discord.File(
            io.StringIO(transcript_content),
            filename=f"{interaction.channel.name}-transcript.txt"
        )
        
        # Log ticket closure
        ticket_logs_channel_id = get_server_config(interaction.guild.id, "ticket_logs_channel_id")
        if ticket_logs_channel_id:
            logs_channel = interaction.guild.get_channel(ticket_logs_channel_id)
            if logs_channel:
                log_embed = nova_embed(
                    "üîí tICKET cLOSED",
                    f"**Channel:** {interaction.channel.name}\n**Closed by:** {interaction.user.mention}\n**Closed at:** <t:{int(datetime.now().timestamp())}:F>"
                )
                log_embed.set_thumbnail(url=interaction.user.avatar.url if interaction.user.avatar else interaction.user.default_avatar.url)
                await logs_channel.send(embed=log_embed, file=transcript_file)
        
        # Delete the channel
        await interaction.response.send_message(
            embed=nova_embed("üîí cLOSING tICKET", "This ticket will be closed in 5 seconds..."),
            ephemeral=False
        )
        
        await asyncio.sleep(5)
        await interaction.channel.delete(reason=f"Ticket closed by {interaction.user}")

@bot.command()
async def ticket(ctx):
    """Create a support ticket"""
    modal = TicketModal()
    try:
        # For regular commands, we need to create an interaction-like response
        await ctx.send(embed=nova_embed("üé´ cREATE tICKET", "Please use the slash command `/ticket` to create a ticket with the interactive form!"))
    except Exception as e:
        await ctx.send(embed=nova_embed("üé´ tICKET eRROR", f"Error: {str(e)}"))

@bot.tree.command(name="ticket", description="Create a support ticket")
async def ticket_slash(interaction: discord.Interaction):
    modal = TicketModal()
    await interaction.response.send_modal(modal)

@bot.command()
async def setticketcategory(ctx, category: discord.CategoryChannel = None):
    """Set the category for support tickets (admin only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET tICKET cATEGORY", "yOU dON'T hAVE pERMISSION!"))
        return
    
    if not category:
        await ctx.send(embed=nova_embed("sET tICKET cATEGORY", "pLEASE mENTION a cATEGORY!"))
        return
    
    # Save to server config
    set_server_config(ctx.guild.id, "ticket_category_id", category.id)
    
    await ctx.send(embed=nova_embed("sET tICKET cATEGORY", f"tICKET cATEGORY sET tO {category.name}!"))

@bot.command()
async def setsupportrole(ctx, role: discord.Role = None):
    """Set the support role for tickets (admin only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET sUPPORT rOLE", "yOU dON'T hAVE pERMISSION!"))
        return
    
    if not role:
        await ctx.send(embed=nova_embed("sET sUPPORT rOLE", "pLEASE mENTION a rOLE!"))
        return
    
    # Save to server config
    set_server_config(ctx.guild.id, "support_role_id", role.id)
    
    await ctx.send(embed=nova_embed("sET sUPPORT rOLE", f"sUPPORT rOLE sET tO {role.mention}!"))

@bot.command()
async def setticketlogs(ctx, channel: discord.TextChannel = None):
    """Set the ticket logs channel (admin only)"""
    if not has_mod_or_admin(ctx):
        await ctx.send(embed=nova_embed("sET tICKET lOGS", "yOU dON'T hAVE pERMISSION!"))
        return
    
    if not channel:
        await ctx.send(embed=nova_embed("sET tICKET lOGS", "pLEASE mENTION a cHANNEL!"))
        return
    
    # Save to server config
    set_server_config(ctx.guild.id, "ticket_logs_channel_id", channel.id)
    
    await ctx.send(embed=nova_embed("sET tICKET lOGS", f"tICKET lOGS cHANNEL sET tO {channel.mention}!"))

# Advanced search system
@bot.command()
async def search(ctx, *, query: str = None):
    """Search for messages in the server"""
    if not query:
        await ctx.send(embed=nova_embed("sEARCH", "pLEASE pROVIDE a sEARCH qUERY!"))
        return
    
    if len(query) < 3:
        await ctx.send(embed=nova_embed("sEARCH", "sEARCH qUERY mUST bE aT lEAST 3 cHARACTERS!"))
        return
    
    # Search through recent messages in all channels
    results = []
    search_limit = 100  # Limit search to prevent rate limits
    
    for channel in ctx.guild.text_channels:
        if channel.permissions_for(ctx.author).read_messages:
            try:
                async for message in channel.history(limit=search_limit):
                    if query.lower() in message.content.lower() and not message.author.bot:
                        results.append({
                            'message': message,
                            'channel': channel,
                            'relevance': message.content.lower().count(query.lower())
                        })
                        
                        if len(results) >= 10:  # Limit results
                            break
            except discord.Forbidden:
                continue
        
        if len(results) >= 10:
            break
    
    if not results:
        await ctx.send(embed=nova_embed("sEARCH", f"nO rESULTS fOUND fOR '{query}'"))
        return
    
    # Sort by relevance
    results.sort(key=lambda x: x['relevance'], reverse=True)
    
    embed = nova_embed(f"üîç sEARCH rESULTS fOR '{query}'", f"fOUND {len(results)} rESULT(S)")
    
    for i, result in enumerate(results[:5], 1):
        message = result['message']
        channel = result['channel']
        content = message.content[:100] + "..." if len(message.content) > 100 else message.content
        
        embed.add_field(
            name=f"#{i} - {message.author.display_name}",
            value=f"**Channel:** {channel.mention}\n**Content:** {content}\n**[Jump to Message]({message.jump_url})**",
            inline=False
        )
    
    await ctx.send(embed=embed)

@bot.tree.command(name="search", description="Search for messages in the server")
@app_commands.describe(query="Search query (minimum 3 characters)")
async def search_slash(interaction: discord.Interaction, query: str):
    if len(query) < 3:
        await interaction.response.send_message(embed=nova_embed("sEARCH", "sEARCH qUERY mUST bE aT lEAST 3 cHARACTERS!"), ephemeral=True)
        return
    
    await interaction.response.defer()
    
    # Search through recent messages in all channels
    results = []
    search_limit = 100  # Limit search to prevent rate limits
    
    for channel in interaction.guild.text_channels:
        if channel.permissions_for(interaction.user).read_messages:
            try:
                async for message in channel.history(limit=search_limit):
                    if query.lower() in message.content.lower() and not message.author.bot:
                        results.append({
                            'message': message,
                            'channel': channel,
                            'relevance': message.content.lower().count(query.lower())
                        })
                        
                        if len(results) >= 10:  # Limit results
                            break
            except discord.Forbidden:
                continue
        
        if len(results) >= 10:
            break
    
    if not results:
        await interaction.followup.send(embed=nova_embed("sEARCH", f"nO rESULTS fOUND fOR '{query}'"))
        return
    
    # Sort by relevance
    results.sort(key=lambda x: x['relevance'], reverse=True)
    
    embed = nova_embed(f"üîç sEARCH rESULTS fOR '{query}'", f"fOUND {len(results)} rESULT(S)")
    
    for i, result in enumerate(results[:5], 1):
        message = result['message']
        channel = result['channel']
        content = message.content[:100] + "..." if len(message.content) > 100 else message.content
        
        embed.add_field(
            name=f"#{i} - {message.author.display_name}",
            value=f"**Channel:** {channel.mention}\n**Content:** {content}\n**[Jump to Message]({message.jump_url})**",
            inline=False
        )
    
    await interaction.followup.send(embed=embed)

bot.run(TOKEN)
